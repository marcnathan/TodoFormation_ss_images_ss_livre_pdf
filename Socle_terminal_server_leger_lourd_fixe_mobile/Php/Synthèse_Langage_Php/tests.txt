> Notes
	- 
	- 
	- 
	- Php debugger (?)
	- Advanced PHP Debugger (APD) (?)
	- XDebug (?)
	- 

	
	
tests (Symfony, PhpUnit, Sélénium, Behat, Blackfire, Insight) (1 semaine)
	- synthèse des types de testes par techno
		- Tests Fonctionnel, Technique, Automatisée : Non-Régression, Compatibilité, Parseur de norme, de Charge, Profiling : Performence, de Chargement HTML PHP
			- du Framework
				- Symfony
					- console
					- web
			- PhpUnit (lu a syth et apprendre) 
			- Sélénium
			- Behat
			- Blackfire
	- système 
		- de gestion des exceptions
		- de gestion des sauvegarde des données
	- ressources
		- net
			- 
		- livre
			- 
	- lien indexe complet
		- 
	- procédées essentiels
		- installation
			- 
		- paramétrage
			- connexion aux servers (packagist, ...)
				- 
			- fichier  de configuration
				- 
		- commandes
			
			
			- Unit Testing Tutorial Part I: Introduction to PHPUnit
				- INSTALLING PHPUNIT
					- composer require "phpunit/phpunit"
				- RUNNING PHPUNIT
					- ./vendor/bin/phpunit -help
				- STRUCTURING THE PROJECT
					- {
							"require": {
							},
							"require-dev": {
								"symfony/phpunit-bridge": "^3.0"
							},
							"autoload": {
								"psr-0": {
									"psr-4": { "Tests\\": "tests/" }
								}
							}
						}
				- SETTING UP phpunit.xml
					- <?xml version="1.0" encoding="UTF-8"?>
						<phpunit colors="true">
							<testsuites>
								<testsuite name="Application Test Suite">
									<directory>./tests/</directory>
								</testsuite>
							</testsuites>
						</phpunit>
			- Mise en pratique des tests unitaires
				- Tester un filtre Twig
					- Écriture d’un premier test : le cas nominal
						<?php
							namespace TechCorp\FrontBundle\Tests\Unit\Component\Twig;
							use TechCorp\FrontBundle\Component\Twig\ElapsedTwigFilterExtension;
							class ElapsedTwigFilterExtensionTest extends \PHPUnit_Framework_TestCase
							{
								private $filter;
								public function setUp(){
									// Initialisation
									$this->filter = new ElapsedTwigFilterExtension(null);
								}
								public function testElapsedConvertsPastDatesInSeconds (){
									// Initialisation
									$previousDate = new \DateTime('-10 seconds');
									// Réalisation
									$elapsed = $this->filter->elapsedFilter($previousDate);
									// Vérification
									$this->assertEquals(10, $elapsed);
								}
							}
					- Des tests comme spécifications
						- bin/phpunit -c app --testdox
					- D’autres assertions
						- Dans le test que nous venons d’écrire, nous avons utilisé l’assertion assertEquals . Il en existe
						d’autres, dont voici quelques exemples :
						- assertTrue / assertFalse : vérifie que la variable d’entrée vaut true ou false .
						- assertGreaterThan : vérifie que la variable testée est plus grande qu’un seuil fixé. Il existe
						d’autres assertions similaires, pour l’infériorité et pour les cas non stricts : assertLessThan ,
						assertGreaterThanOrEqual et assertLessThanOrEqual .
						- assertInstanceOf : vérifie que l’objet testé est une instance de la classe donnée.
						- assertNull / assertNotNull : vérifie que la variable testée est nulle ou non.
						- assertRegExp : teste une variable contre une expression régulière.
					- Second test unitaire : conditions aux limites
						public function testElapsedConvertsCurrentDateToZeroSecond (){
							$previousDate = new \DateTime();
							$elapsed = $this->filter->elapsedFilter($previousDate);
							$this->assertEquals(0, $elapsed);
						}
					- Un troisième test : le cas d’erreur
						public function testElapsedThrowsExceptionWithDatesInTheFuture (){
							$this->setExpectedException ('InvalidArgumentException');
							$previousDate = new \DateTime('+10 seconds');
							$elapsed = $this->filter->elapsedFilter($previousDate);
						}
				- Test unitaire du filtre since
				- Test unitaire d’un contrôleur
				- Le cas nominal
						<?php
							namespace TechCorp\FrontBundle\Tests\Unit\Controller;
							use TechCorp\FrontBundle\Controller\UserController;
							class UserControllerTest extends \PHPUnit_Framework_TestCase
							{
								private function getMockSecurityContext($expectedUser){ 
									$token = $this->getMock('Symfony\Component\Security\Core\Authentication\
									Token\TokenInterface');
									
									$token->expects($this->once())
									->method('getUser') 
									->will($this->returnValue($expectedUser)); 
									
									$securityContext = $this->getMockBuilder('Symfony\Component\Security\Core\
									SecurityContextInterface')
									->disableOriginalConstructor()
									->getMock();
									$securityContext->expects($this->once())
									->method('getToken') 
									->will($this->returnValue($token)); 
									return $securityContext;
								}
								public function testAddFriendAuthenticatedWithValidFriendIs200(){ 
									$user = $this->getMock('\TechCorp\FrontBundle\Entity\User'); 
									$securityContext = $this->getMockSecurityContext($user); 
									// Our friend service
									$friendService = $this->getMockBuilder('\TechCorp\FrontBundle\Services\
									FriendService')
									->disableOriginalConstructor()
									->getMock();
									$friendService->expects($this->once()) 
									->method('addFriend') 
									->will($this->returnValue(true)); 
									$controller = new UserController($securityContext, $friendService);
									$response = $controller->addFriendAction(123);
									$this->assertEquals(200, $response->getStatusCode()); 
								}
							}
					- Un premier cas d’erreur : pas d’utilisateur authentifié
						public function testAddFriendNotAuthenticatedLeadsTo401(){
							// Le contexte de sécurité nous renvoie un utilisateur null
							$securityContext = $this->getMockSecurityContext(null); 
							// Nous mockons notre service d’amis
							$friendService = $this->getMockBuilder('\TechCorp\FrontBundle\Services\
							FriendService')
							->disableOriginalConstructor()
							->getMock();
							$friendService->expects($this->never())  // la méthode n'est jamais appelée
							->method('addFriend');
							$controller = new UserController($securityContext, $friendService);
							$response = $controller->addFriendAction(123);
							$this->assertEquals(401, $response->getStatusCode());
						}
					- Un second cas d’erreur : l’ajout d’ami échoue
						public function testAddFriendAuthenticatedWithInvalidFriendIs400(){
							$user = $this->getMock('\TechCorp\FrontBundle\Entity\User');
							$securityContext = $this->getMockSecurityContext($user); 
							// Our friend service
							$friendService = $this->getMockBuilder('\TechCorp\FrontBundle\Services\
							FriendService')
							->disableOriginalConstructor()
							->getMock();
							$friendService->expects($this->once()) 
							->method('addFriend')
							->will($this->returnValue(false)); 
							$controller = new UserController($securityContext, $friendService);
							$response = $controller->addFriendAction(123);
							$this->assertEquals(400, $response->getStatusCode()); 
						}
			- Mise en pratique des tests fonctionnels
			- Test fonctionnel du filtre since
				- Préparation du test
					<?php
					namespace TechCorp\FrontBundle\Tests\Functionnal\Component\Twig;
					use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
					use TechCorp\FrontBundle\Component\Twig\ElapsedTwigFilterExtension;
					class ElapsedTwigFilterExtensionTest extends WebTestCase{
						private $filter;
						public function setUp(){ 
							static::$kernel = static::createKernel();
							static::$kernel->boot();
							$this->filter = static::$kernel->getContainer()-
							>get('techcorp.elapsed_extension'); 
						}
						public function testSinceFilterConvertsPositiveSecondsToFrenchSentences(){ 
							$this->markTestIncomplete(); 
						}
					}
				- Écriture du test
					public function frenchSentencesProvider(){
						return array (
						array (1,'Il y a 1 seconde.'),
						array (10,'Il y a 10 secondes.'),
						array (59,'Il y a 59 secondes.'),								
						array (60,'Il y a 1 minute.'),
						array (120,'Il y a 2 minutes.'),
						array (3599,'Il y a 59 minutes.'),
						array (3600,'Il y a 1 heure.'),
						array (7200,'Il y a 2 heures.'),
						array (86399,'Il y a 23 heures.'),
						array (86400,'Il y a 1 jour.'),
						array (172799,'Il y a 1 jour.'),
						array (172800,'Il y a 2 jours.'),
						array (400000,'Il y a 4 jours.'),
						);
					}
					/**
					* @dataProvider frenchSentencesProvider
					*/
					public function testSinceFilterConvertsPositiveSecondsToFrenchSentences($seconds, $expected){
						$result = $this->filter->sinceFilter($seconds);
						$this->assertEquals ($expected, $result);
					}
			- Test du comportement de la page d’accueil
				<?php
					namespace TechCorp\FrontBundle\Tests\Functionnal\Controller;
					use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
					class StaticControllerTest extends WebTestCase
					{
						public function testFrenchHomepageMatchesRequirements(){
							$client = static::createClient();
							$crawler = $client->request('GET', '/fr/');
							$mainTitleContent = $crawler->filter('h1')->text(); 
							$responseCode = $client->getResponse()->getStatusCode();
							$this->assertEquals('Bienvenue !', $mainTitleContent);
							$this->assertEquals(200, $responseCode);
						}
						
						public function testEnglishHomepageMatchesRequirements(){
							$client = static::createClient();
							$crawler = $client->request('GET', '/en/');
							$mainTitleContent = $crawler->filter('h1')->text();
							$responseCode = $client->getResponse()->getStatusCode();
							$this->assertEquals('Welcome !', $mainTitleContent);
							$this->assertEquals(200, $responseCode);
						}
					}
			- Naviguer et manipuler la page
					$client = static::createClient();
					$crawler = $client->request('GET', '/en/');
					$mainTitleContent = $crawler->filter('h1')->text();
				- Le client
					C’est une instance de Symfony\Component\BrowserKit\Client
				- Le DomCrawler
					$crawler− >filter("div#content")− >text()
					$crawler− >filter("title")− >text();
					$crawler− >filter("title")− >attr("data− id");
					$crawler− >filter("td")− >first()− >text();
					$crawler− >filter("td")− >last()− >text();
				- Cliquer sur les liens
					$client = static::createClient();
					$crawler = $client− >request("GET","/fr/");
					$link = $crawler− >selectLink("about")− >link();
					$aboutCrawler = $client− >click($link);
					$lastContent=$client− >getResponse()− >getContent();
					$this− >assertContains("À propos",$lastContent);
				- Remplir les formulaires
					$client = static::createClient();
					$crawler = $client− >request("GET","/fr/timeline/123");
					$form = $crawler− >selectButton("Publier")− >form();
					$publishCrawler = $client− >submit($form,array(
					"send[content]" => "lorem ipsum depuis le form",
					));
					$client− >followRedirect();
					$lastContent = $client− >getResponse()− >getContent();
					$this− >assertContains("lorem ipsum depuis le form", $lastContent);
				- Apprendre à manipuler ces composants
					- http://symfony.com/doc/current/components/dom_crawler.html
					- http://api.symfony.com/2.6/Symfony/Component/DomCrawler/Crawler.html
			- Test fonctionnel de la redirection après authentification
				<?php
					namespace TechCorp\FrontBundle\Tests\Functionnal\Component\Security;
					use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
					class AuthenticationTest extends WebTestCase
					{
						public function testAfterAuthenticationUserIsRedirectedToTimeline(){
							$client = static::createClient();
							$crawler = $client->request('GET', '/fr/login');
							$form = $crawler->selectButton('Connexion')->form();
							$form['_username'] = 'user';
							$form['_password'] = 'password';
							$client->submit($form);
							$client->followRedirects();
							$finalUrl = $client->getResponse()->headers->get('location');
							$this->assertEquals(302, $client->getResponse()->getStatusCode());
							$this->assertEquals('/fr/timeline/11', $finalUrl);
						}
					}
			- Tests unitaires
				- Test de l’extension Twig // extends \Twig_Extension
					- <?php
						// src/Blogger/BlogBundle/Tests/Twig/Extensions/BloggerBlogExtensionTest.php

						namespace Blogger\BlogBundle\Tests\Twig\Extensions;

						use Blogger\BlogBundle\Twig\Extensions\BloggerBlogExtension;

						class BloggerBlogExtensionTest extends \PHPUnit_Framework_TestCase
						{
							public function testCreatedAgo()
							{
								$blog = new BloggerBlogExtension();

								$this->assertEquals("0 seconds ago", $blog->createdAgo(new \DateTime()));
								$this->assertEquals("34 seconds ago", $blog->createdAgo($this->getDateTime(-34)));
								$this->assertEquals("1 minute ago", $blog->createdAgo($this->getDateTime(-60)));
								$this->assertEquals("2 minutes ago", $blog->createdAgo($this->getDateTime(-120)));
								$this->assertEquals("1 hour ago", $blog->createdAgo($this->getDateTime(-3600)));
								$this->assertEquals("1 hour ago", $blog->createdAgo($this->getDateTime(-3601)));
								$this->assertEquals("2 hours ago", $blog->createdAgo($this->getDateTime(-7200)));

								// Cannot create time in the future
								$this->setExpectedException('\Exception');
								$blog->createdAgo($this->getDateTime(60));
							}

							protected function getDateTime($delta)
							{
								return new \DateTime(date("Y-m-d H:i:s", time()+$delta));
							}
						}
					- phpunit -c app src/Blogger/BlogBundle/Tests/Twig/Extensions/BloggerBlogExtensionTest.php
					- <?php
						// src/Blogger/BlogBundle/Twig/Extensions/BloggerBlogBundle.php

						namespace Blogger\BlogBundle\Twig\Extensions;

						class BloggerBlogExtension extends \Twig_Extension
						{
							// ..

							public function createdAgo(\DateTime $dateTime)
							{
								// ..
								if ($delta < 60)
								{
									// Secondes
									$time = $delta;
									$duration = $time . " second" . (($time === 0 || $time > 1) ? "s" : "") . " ago";
								}
								// ..
							}

							// ..
						}
					- <?php
						// src/Blogger/BlogBundle/Twig/Extensions/BloggerBlogBundle.php

						namespace Blogger\BlogBundle\Twig\Extensions;

						class BloggerBlogExtension extends \Twig_Extension
						{
							// ..

							public function createdAgo(\DateTime $dateTime)
							{
								// ..

								else if ($delta < 3600)
								{
									// Minutes
									$time = floor($delta / 60);
									$duration = $time . " minute" . (($time > 1) ? "s" : "") . " ago";
								}
								else if ($delta < 86400)
								{
									// Heures
									$time = floor($delta / 3600);
									$duration = $time . " hour" . (($time > 1) ? "s" : "") . " ago";
								}

								// ..
							}

							// ..
						}
				- Test de l’ajout de commentaire d’articles // extends WebTestCase
					- <?php
						// src/Blogger/BlogBundle/Tests/Controller/BlogControllerTest.php

						namespace Blogger\BlogBundle\Tests\Controller;

						use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;

						class BlogControllerTest extends WebTestCase
						{
							public function testAddBlogComment()
							{
								$client = static::createClient();

								$crawler = $client->request('GET', '/1/a-day-with-symfony');

								$this->assertEquals(1, $crawler->filter('h2:contains("A day with Symfony2")')->count());

								// Select based on button value, or id or name for buttons
								$form = $crawler->selectButton('Submit')->form();

								$crawler = $client->submit($form, array(
									'blogger_blogbundle_commenttype[user]'          => 'name',
									'blogger_blogbundle_commenttype[comment]'       => 'comment',
								));

								// Il faut suivre la redirection
								$crawler = $client->followRedirect();

								// On vérifie que le comment s'affiche, et que c'est le dernier. Cela assure que les commentaires
								// vont du plus vieux au plus récent.
								$articleCrawler = $crawler->filter('section .previous-comments article')->last();

								$this->assertEquals('name', $articleCrawler->filter('header span.highlight')->text());
								$this->assertEquals('comment', $articleCrawler->filter('p')->last()->text());

								// On vérifie que la barre latérale affiche bien 10 derniers articles.

								$this->assertEquals(10, $crawler->filter('aside.sidebar section')->last()
																->filter('article')->count()
								);

								$this->assertEquals('name', $crawler->filter('aside.sidebar section')->last()
																	->filter('article')->first()
																	->filter('header span.highlight')->text()
								);
							}
						}
					- phpunit -c app/ src/Blogger/BlogBundle/Tests/Controller/BlogControllerTest.php
				- Dépôt d’articles // extends \PHPUnit_Framework_TestCase
					- <?php
						// src/Blogger/BlogBundle/Tests/Repository/BlogRepositoryTest.php

						namespace Blogger\BlogBundle\Tests\Repository;

						use Blogger\BlogBundle\Repository\BlogRepository;
						use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;

						class BlogRepositoryTest extends WebTestCase
						{
							/**
							 * @var \Blogger\BlogBundle\Repository\BlogRepository
							 */
							private $blogRepository;

							public function setUp()
							{
								$kernel = static::createKernel();
								$kernel->boot();
								$this->blogRepository = $kernel->getContainer()
															   ->get('doctrine.orm.entity_manager')
															   ->getRepository('BloggerBlogBundle:Blog');
							}

							public function testGetTags()
							{
								$tags = $this->blogRepository->getTags();

								$this->assertTrue(count($tags) > 1);
								$this->assertContains('symblog', $tags);
							}

							public function testGetTagWeights()
							{
								$tagsWeight = $this->blogRepository->getTagWeights(
									array('php', 'code', 'code', 'symblog', 'blog')
								);

								$this->assertTrue(count($tagsWeight) > 1);

								// Cas ou le poids est supérieur 5
								$tagsWeight = $this->blogRepository->getTagWeights(
									array_fill(0, 10, 'php')
								);

								$this->assertTrue(count($tagsWeight) >= 1);

								// Cas où il y a plusieurs éléments dont le poids est supérieur à 5
								$tagsWeight = $this->blogRepository->getTagWeights(
									array_merge(array_fill(0, 10, 'php'), array_fill(0, 2, 'html'), array_fill(0, 6, 'js'))
								);

								$this->assertEquals(5, $tagsWeight['php']);
								$this->assertEquals(3, $tagsWeight['js']);
								$this->assertEquals(1, $tagsWeight['html']);

								// Cas vide
								$tagsWeight = $this->blogRepository->getTagWeights(array());

								$this->assertEmpty($tagsWeight);
							}
						}
					- phpunit -c app/ src/Blogger/BlogBundle/Tests/Repository/BlogRepositoryTest.php
			- Couverture de code
				- phpunit --coverage-html ./phpunit-report -c app/
			- Unit Testing Tutorial Part II: Assertions, Writing a Useful Test and @dataProvider
				- ASSERTIONS
					- Assertions evaluate to true
						- public function testTrueIsTrue()
							{
								$foo = false;
								$this->assertTrue($foo);
							}
						- public function testFalseIsFalse()
							{
								$foo = false;
								$this->assertFalse($foo);
							}
					- Available assertions
						- assertArrayHasKey(), assertEquals(), assertFalse(), assertSame() and assertTrue()
				- FIRST USEFUL TEST
					- The code
						- /phpUnitTutorial/URL.php
						<?php
							namespace phpUnitTutorial;
							class URL
							{
								public function sluggify($string, $separator = '-', $maxLength = 96)
								{
									$title = iconv('UTF-8', 'ASCII//TRANSLIT', $string);
									$title = preg_replace("%[^-/+|\w ]%", '', $title);
									$title = strtolower(trim(substr($title, 0, $maxLength), '-'));
									$title = preg_replace("/[\/_|+ -]+/", $separator, $title);

									return $title;
								}
							}
						- More scenarios
							- <?php
								namespace phpUnitTutorial\Test;
								use phpUnitTutorial\URL;
								class URLTest extends \PHPUnit_Framework_TestCase
								{
									public function testSluggifyReturnsSluggifiedString()
									{
										$originalString = 'This string will be sluggified';
										$expectedResult = 'this-string-will-be-sluggified';

										$url = new URL();

										$result = $url->sluggify($originalString);

										$this->assertEquals($expectedResult, $result);
									}

									public function testSluggifyReturnsExpectedForStringsContainingNumbers()
									{
										$originalString = 'This1 string2 will3 be 44 sluggified10';
										$expectedResult = 'this1-string2-will3-be-44-sluggified10';

										$url = new URL();

										$result = $url->sluggify($originalString);

										$this->assertEquals($expectedResult, $result);
									}

									public function testSluggifyReturnsExpectedForStringsContainingSpecialCharacters()
									{
										$originalString = 'This! @string#$ %$will ()be "sluggified';
										$expectedResult = 'this-string-will-be-sluggified';

										$url = new URL();

										$result = $url->sluggify($originalString);

										$this->assertEquals($expectedResult, $result);
									}

									public function testSluggifyReturnsExpectedForStringsContainingNonEnglishCharacters()
									{
										$originalString = "Tänk efter nu – förr'n vi föser dig bort";
										$expectedResult = 'tank-efter-nu-forrn-vi-foser-dig-bort';

										$url = new URL();

										$result = $url->sluggify($originalString);

										$this->assertEquals($expectedResult, $result);
									}

									public function testSluggifyReturnsExpectedForEmptyStrings()
									{
										$originalString = '';
										$expectedResult = '';

										$url = new URL();

										$result = $url->sluggify($originalString);

										$this->assertEquals($expectedResult, $result);
									}
								}
				- AN INTRODUCTION ANNOTATIONS
					- @dataProvider
						- /**
						 * @dataProvider providerTestFoo
						 */
						public function testFoo($variableOne, $variableTwo)
						{
							//
						}

						public function providerTestFoo()
						{
							return array(
								array('test 1, variable one', 'test 1, variable two'),
								array('test 2, variable one', 'test 2, variable two'),
								array('test 3, variable one', 'test 3, variable two'),
								array('test 4, variable one', 'test 4, variable two'),
								array('test 5, variable one', 'test 5, variable two'),
							);
						}
					- Test with @dataProvider
						- /phpUnitTutorial/Test/URLTest.php
						<?php
							namespace phpUnitTutorial\Test;
							use phpUnitTutorial\URL;
							class URLTest extends \PHPUnit_Framework_TestCase
							{
								/**
								 * @param string $originalString String to be sluggified
								 * @param string $expectedResult What we expect our slug result to be
								 *
								 * @dataProvider providerTestSluggifyReturnsSluggifiedString
								 */
								public function testSluggifyReturnsSluggifiedString($originalString, $expectedResult)
								{
									$url = new URL();

									$result = $url->sluggify($originalString);

									$this->assertEquals($expectedResult, $result);
								}

								public function providerTestSluggifyReturnsSluggifiedString()
								{
									return array(
										array('This string will be sluggified', 'this-string-will-be-sluggified'),
										array('THIS STRING WILL BE SLUGGIFIED', 'this-string-will-be-sluggified'),
										array('This1 string2 will3 be 44 sluggified10', 'this1-string2-will3-be-44-sluggified10'),
										array('This! @string#$ %$will ()be "sluggified', 'this-string-will-be-sluggified'),
										array("Tänk efter nu – förr'n vi föser dig bort", 'tank-efter-nu-forrn-vi-foser-dig-bort'),
										array('', ''),
									);
								}
							}
				- WRAPPING UP
			- Unit Testing Tutorial Part III: Testing Protected/Private Methods, Coverage Reports and CRAP
				- PROTECTED/PRIVATE METHOD TESTING
					- Stupid user class
						- <?php
								namespace phpUnitTutorial;
								class User
								{
									const MIN_PASS_LENGTH = 4;

									private $user = array();

									public function __construct(array $user)
									{
										$this->user = $user;
									}

									public function getUser()
									{
										return $this->user;
									}

									public function setPassword($password)
									{
										if (strlen($password) < self::MIN_PASS_LENGTH) {
											return false;
										}

										$this->user['password'] = $this->cryptPassword($password);

										return true;
									}

									private function cryptPassword($password)
									{
										return md5($password);
									}
								}
					- Creating your test
						- /phpUnitTutorial/User.php
						<?php
							namespace phpUnitTutorial;
							class User
							{
								const MIN_PASS_LENGTH = 4;

								private $user = array();

								public function __construct(array $user)
								{
									$this->user = $user;
								}

								public function getUser()
								{
									return $this->user;
								}

								public function setPassword($password)
								{
									if (strlen($password) < self::MIN_PASS_LENGTH) {
										return false;
									}

									$this->user['password'] = $this->cryptPassword($password);

									return true;
								}

								private function cryptPassword($password)
								{
									return md5($password);
								}
							}
						- <?php
							namespace phpUnitTutorial\Test;
							use phpUnitTutorial\User;
							class UserTest extends \PHPUnit_Framework_TestCase
							{
								public function testSetPasswordReturnsTrueWhenPasswordSuccessfullySet()
								{
									$details = array();

									$user = new User($details);
								}
							}
						- public function testSetPasswordReturnsTrueWhenPasswordSuccessfullySet()
							{
								$details = array();

								$user = new User($details);

								$password = 'fubar';

								$result = $user->setPassword($password);
							}
						- public function testSetPasswordReturnsTrueWhenPasswordSuccessfullySet()
							{
								$details = array();

								$user = new User($details);

								$password = 'fubar';

								$result = $user->setPassword($password);

								$this->assertTrue($result);
							}
						- public function testGetUserReturnsUserWithExpectedValues()
							{
								$details = array();

								$user = new User($details);

								$password = 'fubar';

								$user->setPassword($password);
							}
						- public function testGetUserReturnsUserWithExpectedValues()
							{
								$details = array();

								$user = new User($details);

								$password = 'fubar';

								$user->setPassword($password);

								$expectedPasswordResult = '5185e8b8fd8a71fc80545e144f91faf2';

								$currentUser = $user->getUser();

								$this->assertEquals($expectedPasswordResult, $currentUser['password']);
							}
					- Targeting private/protected methods directly
						- /**
							 * Call protected/private method of a class.
							 *
							 * @param object &$object    Instantiated object that we will run method on.
							 * @param string $methodName Method name to call
							 * @param array  $parameters Array of parameters to pass into method.
							 *
							 * @return mixed Method return.
							 */
							public function invokeMethod(&$object, $methodName, array $parameters = array())
							{
								$reflection = new \ReflectionClass(get_class($object));
								$method = $reflection->getMethod($methodName);
								$method->setAccessible(true);

								return $method->invokeArgs($object, $parameters);
							}
						- $this->invokeMethod($user, 'cryptPassword', array('passwordToCrypt'));
						- $user->cryptPassword('passwordToCrypt');
				- COVERAGE REPORT
					- Generating a coverage report
						- ./vendor/bin/phpunit --coverage-html coverage (Open the index.html file)
					- URL test coverage
						- Click into URL.php
					- User test coverage
						- click into User.php
						- phpUnitTutorial\Test\UserTest
							public function testSetPasswordReturnsFalseWhenPasswordLengthIsTooShort()
							{
								$details = array();

								$user = new User($details);

								$password = 'fub';

								$result = $user->setPassword($password);
							}
						- public function testSetPasswordReturnsFalseWhenPasswordLengthIsTooShort()
							{
								$details = array();

								$user = new User($details);

								$password = 'fub';

								$result = $user->setPassword($password);

								$this->assertFalse($result);
							}
			- Unit Testing Tutorial Part IV: Mock Objects, Stub Methods and Dependency Injection
				- PAYMENT CLASS
					- Grab the authorize.net files
						- ./composer.json
						{
							"require": {
								"ajbdev/authorizenet-php-api": "dev-master"
							},
							"require-dev": {
								"phpunit/phpunit": "3.7.14"
							},
							"autoload": {
								"psr-0": {
									"phpUnitTutorial": ""
								}
							}
						}
						./composer.phar update
					- Payment class
						- ./phpUnitTutorial/Payment.php
						<?php
							namespace phpUnitTutorial;
							class Payment
							{
								const API_ID = 123456;
								const TRANS_KEY = 'TRANSACTION KEY';

								public function processPayment(array $paymentDetails)
								{
									$transaction = new \AuthorizeNetAIM(self::API_ID, self::TRANS_KEY);
									$transaction->amount = $paymentDetails['amount'];
									$transaction->card_num = $paymentDetails['card_num'];
									$transaction->exp_date = $paymentDetails['exp_date'];

									$response = $transaction->authorizeAndCapture();

									if ($response->approved) {
										return $this->savePayment($response->transaction_id);
									} else {
										throw new \Exception($response->error_message);
									}
								}

								public function savePayment($transactionId)
								{
									// Logic for saving transaction ID to database or anywhere else would go in here
									return true;
								}
							}
						- Test skeleton
							- ./phpUnitTutorial/Test/PaymentTest.php
							<?php
								namespace phpUnitTutorial\Test;
								use phpUnitTutorial\Payment;
								class PaymentTest extends \PHPUnit_Framework_TestCase
								{
									//
								}
							<?php
								namespace phpUnitTutorial\Test;
								use phpUnitTutorial\Payment;
								class PaymentTest extends \PHPUnit_Framework_TestCase
								{
									public function testProcessPaymentReturnsTrueOnSuccessfulPayment()
									{
										$paymentDetails = array(
											'amount'   => 123.99,
											'card_num' => '4111-1111-1111-1111',
											'exp_date' => '03/2013',
										);

										$payment = new Payment();
										$result = $payment->processPayment($paymentDetails);

										$this->assertTrue($result);
									}
								}
				- ENTER THE MOCK
					- $transaction = new \AuthorizeNetAIM(self::API_ID, self::TRANS_KEY);
				- DEPENDING ON DEPENDENCY INJECTION
					- public function processPayment(array $paymentDetails)
						{
							$transaction = new \AuthorizeNetAIM(self::API_ID, self::TRANS_KEY);
							$transaction->amount = $paymentDetails['amount'];
							$transaction->card_num = $paymentDetails['card_num'];
							$transaction->exp_date = $paymentDetails['exp_date'];

							$response = $transaction->authorizeAndCapture();

							if ($response->approved) {
								return $this->savePayment($response->transaction_id);
							}

							throw new \Exception($response->error_message);
						}
					- public function processPayment(\AuthorizeNetAIM $transaction, array $paymentDetails)
						{
							$transaction->amount = $paymentDetails['amount'];
							$transaction->card_num = $paymentDetails['card_num'];
							$transaction->exp_date = $paymentDetails['exp_date'];

							$response = $transaction->authorizeAndCapture();

							if ($response->approved) {
								return $this->savePayment($response->transaction_id);
							}

							throw new \Exception($response->error_message);
						}
				- PHPUnit's Mock Helper
					- <?php
						namespace phpUnitTutorial\Test;
						use phpUnitTutorial\Payment;
						class PaymentTest extends \PHPUnit_Framework_TestCase
						{
							public function testProcessPaymentReturnsTrueOnSuccessfulPayment()
							{
								$paymentDetails = array(
									'amount'   => 123.99,
									'card_num' => '4111-1111-1111-1111',
									'exp_date' => '03/2013',
								);

								$payment = new Payment();

								$authorizeNet = new \AuthorizeNetAIM($payment::API_ID, $payment::TRANS_KEY);

								$result = $payment->processPayment($authorizeNet, $paymentDetails);

								$this->assertTrue($result);
							}
						}
					- PHPUnit to the rescue!
						- $authorizeNet = $this->getMock('\AuthorizeNetAIM', array(), array($payment::API_ID, $payment::TRANS_KEY));
					- Wait, what's that second parameter?
						- public function getMock($originalClassName, $methods = array(), array $arguments = array(), $mockClassName = '', $callOriginalConstructor = TRUE, $callOriginalClone = TRUE, $callAutoload = TRUE, $cloneArguments = TRUE)
					- getMockBuilder()
						- $authorizeNet = $this->getMockBuilder('\AuthorizeNetAIM')
						->setConstructorArgs(array($payment::API_ID, $payment::TRANS_KEY))
						->getMock();
				- EXAMINING A MOCKED OBJECT
					- $authorizeNet = $this->getMockBuilder('\AuthorizeNetAIM')
						->setConstructorArgs(array($payment::API_ID, $payment::TRANS_KEY))
						->getMock();

					var_dump($authorizeNet);
					- class Mock_AuthorizeNetAIM_084f7b20#17 (12) {
						private $__phpunit_invocationMocker => NULL
						protected $_x_post_fields           => array(5) {
							'version'        => string(3) "3.1"
							'delim_char'     => string(1) ","
							'delim_data'     => string(4) "TRUE"
							'relay_response' => string(5) "FALSE"
							'encap_char'     => string(1) "|"
						}
						private $_additional_line_items => array(0) {}
						protected $_custom_fields       => array(0) {}
						public $verify_x_fields         => bool(true)
						private $_all_aim_fields        => array(61) {
							[0]  => string(7) "address"
							[1]  => string(18) "allow_partial_auth"
							[2]  => string(6) "amount"
							[3]  => string(9) "auth_code"
							[4]  => string(24) "authentication_indicator"
							[5]  => string(13) "bank_aba_code"
							[6]  => string(14) "bank_acct_name"
							[7]  => string(13) "bank_acct_num"
							[8]  => string(14) "bank_acct_type"
							[9]  => string(17) "bank_check_number"
							[10] => string(9) "bank_name"
							[11] => string(9) "card_code"
							[12] => string(8) "card_num"
							[13] => string(31) "cardholder_authentication_value"
							[14] => string(4) "city"
							[15] => string(7) "company"
							[16] => string(7) "country"
							[17] => string(7) "cust_id"
							[18] => string(11) "customer_ip"
							[19] => string(10) "delim_char"
							[20] => string(10) "delim_data"
							[21] => string(11) "description"
							[22] => string(16) "duplicate_window"
							[23] => string(4) "duty"
							[24] => string(11) "echeck_type"
							[25] => string(5) "email"
							[26] => string(14) "email_customer"
							[27] => string(10) "encap_char"
							[28] => string(8) "exp_date"
							[29] => string(3) "fax"
							[30] => string(10) "first_name"
							[31] => string(20) "footer_email_receipt"
							[32] => string(7) "freight"
							[33] => string(20) "header_email_receipt"
							[34] => string(11) "invoice_num"
							[35] => string(9) "last_name"
							[36] => string(9) "line_item"
							[37] => string(5) "login"
							[38] => string(6) "method"
							[39] => string(5) "phone"
							[40] => string(6) "po_num"
							[41] => string(17) "recurring_billing"
							[42] => string(14) "relay_response"
							[43] => string(15) "ship_to_address"
							[44] => string(12) "ship_to_city"
							[45] => string(15) "ship_to_company"
							[46] => string(15) "ship_to_country"
							[47] => string(18) "ship_to_first_name"
							[48] => string(17) "ship_to_last_name"
							[49] => string(13) "ship_to_state"
							[50] => string(11) "ship_to_zip"
							[51] => string(15) "split_tender_id"
							[52] => string(5) "state"
							[53] => string(3) "tax"
							[54] => string(10) "tax_exempt"
							[55] => string(12) "test_request"
							[56] => string(8) "tran_key"
							[57] => string(8) "trans_id"
							[58] => string(4) "type"
							[59] => string(7) "version"
							[60] => string(3) "zip"
						}
						protected $_api_login       => int(123456)
						protected $_transaction_key => string(15) "TRANSACTION KEY"
						protected $_post_string     => NULL
						public $VERIFY_PEER         => bool(true)
						protected $_sandbox         => bool(true)
						protected $_log_file        => bool(false)
					}
					- print_r(get_class_methods($authorizeNet));
					- [0] => __clone
						[1] => authorizeAndCapture
						[2] => priorAuthCapture
						[3] => authorizeOnly
						[4] => void
						[5] => captureOnly
						[6] => credit
						[7] => __set
						[8] => setFields
						[9] => setCustomFields
						[10] => addLineItem
						[11] => setECheck
						[12] => setField
						[13] => setCustomField
						[14] => unsetField
						[15] => setSandbox
						[16] => setLogFile
						[17] => getPostString
						[18] => expects
						[19] => staticExpects
						[20] => __phpunit_getInvocationMocker
						[21] => __phpunit_getStaticInvocationMocker
						[22] => __phpunit_hasMatchers
						[23] => __phpunit_verify
						[24] => __phpunit_cleanup
						[25] => __construct
					- var_dump($authorizeNet->authorizeAndCapture());
				- STUB METHODS
					- \AuthorizeNetAIM
					- public function authorizeAndCapture($amount = false, $card_num = false, $exp_date = false)
						{
							($amount ? $this->amount = $amount : null);
							($card_num ? $this->card_num = $card_num : null);
							($exp_date ? $this->exp_date = $exp_date : null);
							$this->type = "AUTH_CAPTURE";
							return $this->_sendRequest();
						}
					- public function authorizeAndCapture($amount = false, $card_num = false, $exp_date = false)
						{
							return null;
						}
					- <?php
						namespace phpUnitTutorial\Test;
						use phpUnitTutorial\Payment;
						class PaymentTest extends \PHPUnit_Framework_TestCase
						{
							public function testProcessPaymentReturnsTrueOnSuccessfulPayment()
							{
								$paymentDetails = array(
									'amount'   => 123.99,
									'card_num' => '4111-1111-1111-1111',
									'exp_date' => '03/2013',
								);

								$payment = new Payment();

								$authorizeNet = $this->getMockBuilder('\AuthorizeNetAIM')
									->setConstructorArgs(array($payment::API_ID, $payment::TRANS_KEY))
									->getMock();

								$result = $payment->processPayment($authorizeNet, $paymentDetails);

								$this->assertTrue($result);
							}
						}
				- OVERRIDING STUB METHOD RETURN VALUES
					- $authorizeNet->expects($this->once())
						->method('authorizeAndCapture')
						->will($this->returnValue('RETURN VALUE HERE!'));
					- $response = new \stdClass();
						$response->approved = true;
						$response->transaction_id = 123;
					- <?php
						namespace phpUnitTutorial\Test;
						use phpUnitTutorial\Payment;
						class PaymentTest extends \PHPUnit_Framework_TestCase
						{
							public function testProcessPaymentReturnsTrueOnSuccessfulPayment()
							{
								$paymentDetails = array(
									'amount'   => 123.99,
									'card_num' => '4111-1111-1111-1111',
									'exp_date' => '03/2013',
								);

								$payment = new Payment();

								$response = new \stdClass();
								$response->approved = true;
								$response->transaction_id = 123;

								$authorizeNet = $this->getMockBuilder('\AuthorizeNetAIM')
									->setConstructorArgs(array($payment::API_ID, $payment::TRANS_KEY))
									->getMock();

								$authorizeNet->expects($this->once())
									->method('authorizeAndCapture')
									->will($this->returnValue($response));

								$result = $payment->processPayment($authorizeNet, $paymentDetails);

								$this->assertTrue($result);
							}
						}
				- WRAP IT UP
			- Unit Testing Tutorial Part V: Mock Methods and Overriding Constructors
				- INTRODUCING MOCK METHODS
					- Mock Object
					- Stub Method
					- Mock Method
				- THE FOUR PATHWAYS OF GETMOCKBUILDER()
					- Do not call setMethods()
						- $authorizeNet = $this->getMockBuilder('\AuthorizeNetAIM')
							->getMock();
					- Passing an empty array
						- $authorizeNet = $this->getMockBuilder('\AuthorizeNetAIM')
							->setMethods(array())
							->getMock();
					- Passing null
						- $authorizeNet = $this->getMockBuilder('\AuthorizeNetAIM')
							->setMethods(null)
							->getMock();
					- Passing an array containing method names
						- $authorizeNet = $this->getMockBuilder('\AuthorizeNetAIM')
							->setMethods(array('authorizeAndCapture', 'foobar'))
							->getMock();
				- WHY WOULD YOU WANT MOCK METHODS?
					- <?php
						namespace phpUnitTutorial;
						class BadCode
						{
							protected $user;

							public function __construct(array $user)
							{
								$this->user = $user;
							}

							public function authorize($password)
							{
								if ($this->checkPassword($password)) {
									return true;
								}

								return false;
							}

							protected function checkPassword($password)
							{
								if (empty($this->user['password']) || $this->user['password'] !== $password) {
									echo 'YOU SHALL NOT PASS';
									exit;
								}

								return true;
							}
						}
					- protected function checkPassword($password)
						{
							if (empty($this->user['password']) || $this->user['password'] !== $password) {
								echo 'YOU SHALL NOT PASS';
								$this->callExit();
							}

							return true;
						}

						protected function callExit()
						{
							exit;
						}
					- <?php
						namespace phpUnitTutorial\Test;
						class BadCodeTest extends \PHPUnit_Framework_TestCase
						{
							public function testAuthorizeExitsWhenPasswordNotSet()
							{
								$user = array('username' => 'jtreminio');
								$password = 'foo';

								$badCode = $this->getMockBuilder('phpUnitTutorial\BadCode')
									->setConstructorArgs(array($user))
									->setMethods(array('callExit'))
									->getMock();

								$badCode->expects($this->once())
									->method('callExit');

								$this->expectOutputString('YOU SHALL NOT PASS');

								$badCode->authorize($password);
							}
						}
					- $badCode->expects($this->once())
						->method('callExit');
				- HANDLING BAD CONSTRUCTORS
					- An example of bad constructor design
						- <?php
							namespace phpUnitTutorial;
							class NaughtyConstructor
							{
								public $html;

								public function __construct($url)
								{
									$this->html = file_get_contents($url);
								}

								public function getMetaTags()
								{
									$mime = 'text/plain';
									$filename = "data://{$mime};base64," . base64_encode($this->html);

									return get_meta_tags($filename);
								}

								public function getTitle()
								{
									preg_match("#<title>(.+)</title>#siU", $this->html, $matches);

									return !empty($matches[1]) ? $matches[1] : false;
								}
							}
						- $naughty = new NaughtyConstructor('http://jtreminio.com');
							$metaTags = $naughty->getMetaTags();
							$title = $naughty->getTitle();
						- ./phpUnitTutorial/Test/NaughtConstructorTest.php
							<?php
								namespace phpUnitTutorial\Test;
								use phpUnitTutorial\NaughtyConstructor;
								class NaughtyConstructorTest extends \PHPUnit_Framework_TestCase
								{
									public function testGetMetaTagsReturnsArrayOfProperties()
									{
										$naughty = new NaughtyConstructor('http://jtreminio.com');

										$result = $naughty->getMetaTags();

										$expectedAuthor = 'Juan Treminio';

										$this->assertEquals(
											$expectedAuthor,
											$result['author']
										);
									}
								}
					- __construct(), I hereby mock thee!
						- $naughty = $this->getMockBuilder('\phpUnitTutorial\NaughtyConstructor')
							->setMethods(array('__construct'))
							->setConstructorArgs(array('http://jtreminio.com'))
							->getMock();
					- You cannot stub the constructor!
						- $naughty = $this->getMockBuilder('\phpUnitTutorial\NaughtyConstructor')
							->setMethods(array('__construct'))
							->setConstructorArgs(array('http://jtreminio.com'))
							->disableOriginalConstructor()
							->getMock();
						- <?php
								namespace phpUnitTutorial\Test;
								use phpUnitTutorial\NaughtyConstructor;
								class NaughtyConstructorTest extends \PHPUnit_Framework_TestCase
								{
									public function testGetMetaTagsReturnsArrayOfProperties()
									{
										$naughty = $this->getMockBuilder('\phpUnitTutorial\NaughtyConstructor')
											->setMethods(array('__construct'))
											->setConstructorArgs(array('http://jtreminio.com'))
											->disableOriginalConstructor()
											->getMock();

										$naughty->html = $this->getHtml();

										$result = $naughty->getMetaTags();

										$expectedAuthor = 'Juan Treminio';

										$this->assertEquals(
											$expectedAuthor,
											$result['author']
										);
									}

									protected function getHtml()
									{
										return '
											 <!DOCTYPE html>
												<html lang="en">
												<head>
													<meta name="viewport" content="width=1, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"/>
													<meta name="description" content="Dallas PHP/MySQL Web Developer"/>
													<meta name="author" content="Juan Treminio"/>
													<meta name="generator" content="PieCrust 1.0.0-dev"/>
													<meta name="template-engine" content="Twig"/>
													<title>Juan Treminio - Dallas PHP/MySQL Web Developer &mdash; Blog</title>
												</head>
												<body>
												</body>
												</html>
										';
									}
								}
							- public function testGetTitleReturnsExpectedTitle()
								{
									$naughty = $this->getMockBuilder('\phpUnitTutorial\NaughtyConstructor')
										->setMethods(array('__construct'))
										->setConstructorArgs(array('http://jtreminio.com'))
										->disableOriginalConstructor()
										->getMock();

									$naughty->html = $this->getHtml();

									$result = $naughty->getTitle();

									$expectedTitle = 'Juan Treminio - Dallas PHP/MySQL Web Developer &mdash; Blog';

									$this->assertEquals(
										$expectedTitle,
										$result 
									);
								}
			- Sélénium
				- http://www.objis.com/formation-java/Tuto-Selenium-PHP-Jenkins
				- https://dzone.com/articles/selenium-2-php-code
				- https://www.sitepoint.com/using-selenium-with-phpunit/
		- outils
			- 


		
		