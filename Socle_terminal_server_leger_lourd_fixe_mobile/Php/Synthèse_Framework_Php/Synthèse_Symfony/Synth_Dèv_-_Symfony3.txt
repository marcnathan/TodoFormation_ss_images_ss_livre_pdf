

> Notes : 

	- https://openclassrooms.com/courses/developpez-votre-site-web-avec-le-framework-symfony/le-routeur-de-symfony
	- 
	- 
	
	
	
> Sommaire :	
	
	Partie 1 - Vue d'ensemble de Symfony
	1. Symfony, un framework PHP
	2. Vous avez dit Symfony ?
	3. Utilisons la console pour créer un bundle
	4. Aux origines de Symfony (interview)
	 Quiz : Quiz 1
	Partie 2 - Les bases de Symfony
	1. Mon premier « Hello World ! » avec Symfony
	2. Le routeur de Symfony
	3. Les contrôleurs avec Symfony
	4. Le moteur de templates Twig
	5. Installer un bundle grâce à Composer
	6. Les services, théorie et création
	 Quiz : Quiz 2
	 Activité : Créez votre CoreBundle pour les gouverner tous
	Partie 3 - Gérer la base de données avec Doctrine2
	1. La couche métier : les entités
	2. Manipuler ses entités avec Doctrine2
	3. Les relations entre entités avec Doctrine2
	4. Récupérer ses entités avec Doctrine2
	5. Les évènements et extensions Doctrine
	6. TP : Consolidation de notre code
	 Quiz : Quiz 3
	 Activité : Créer un système pour nettoyer vos entités
	Partie 4 - Allons plus loin avec Symfony
	1. Créer des formulaires avec Symfony
	2. Validez vos données
	3. Sécurité et gestion des utilisateurs
	4. Les services, utilisation poussée
	5. Le gestionnaire d'évènements de Symfony
	6. Traduire son site
	 Quiz : Quiz 4
	Partie 5 - Préparer la mise en ligne
	1. Convertir les paramètres de requêtes
	2. Personnaliser les pages d'erreur
	3. Utiliser Assetic pour gérer les codes CSS et JS de votre site
	4. Utiliser la console directement depuis le navigateur
	5. Déployer son site Symfony en production
	 Quiz : Quiz 5		
	
	Extention 1 - Complément manquant de la formation Symfony3 + liste certificat
		
		1. 
	
	Extention 2 - Complément manquant du manuel pdf Eyrolles Symfony2
	
		1. 






	
Partie 1 - Vue d'ensemble de Symfony
	
	1. Symfony, un framework PHP	

		> Install par composer
		***- sudo composer create-project symfony/framework-standard-edition eyrolles/ "2.6.*"

		> Install par installeur
		- sudo mkdir -p /usr/local/bin
		- sudo curl -LsS http://symfony.com/installer -o /usr/local/bin/symfony
		- sudo chmod a+x /usr/local/symfony

			> Install Symfony
			- cd /home/nathan/public_html/
			- symfony new symblog [version]

		> Test
		- cd public_html/symblog/
		- php bin/console server:run
		- ctrl+c pour quitter

		- Test Symfony 2
			
				- en terminal : php app/check.php
				- en nav : http://localhost/eyrolles/code/web/config.php

			- Configurer les permissions d’écriture
			
				- Utiliser chmod +a

				$ rm -rf app/cache/*
				$ rm -rf app/logs/*
				$ HTTPDUSER=`ps aux | grep -E '[a]pache|[h]ttpd|[_]www|[w]ww-data|[n]ginx' | grep -v root | head -1 | cut -d\ -f1`
				$ sudo chmod +a "$HTTPDUSER allow delete,write,append,file_inherit,directory_inherit" app/cache app/logs
				$ sudo chmod +a "`whoami` allow delete,write,append,file_inherit,directory_inherit" app/cache app/logs

				- Utiliser les ACL

				$ HTTPDUSER=`ps aux | grep -E '[a]pache|[h]ttpd|[_]www|[w]ww-data|[n]ginx' | grep -v root | head -1 | cut -d\ -f1`
				$ sudo setfacl -R -m u:"$HTTPDUSER":rwX -m u:`whoami`:rwX app/cache app/logs
				$ sudo setfacl -dR -m u:"$HTTPDUSER":rwX -m u:`whoami`:rwX app/cache app/logs
				
		- Test Symfony 3
		
			- rm -rf var/*
			
			- Ensuite, si votre distribution supporte le chmod+a (Mac), exécutez ces commandes pour définir les bons droits :
			
				HTTPDUSER=`ps aux | grep -E '[a]pache|[h]ttpd|[_]www|[w]ww-data|[n]ginx' | grep -v root | head -1 | cut -d\  -f1`

				sudo chmod +a "$HTTPDUSER allow delete,write,append,file_inherit,directory_inherit" var
				sudo chmod +a "`whoami` allow delete,write,append,file_inherit,directory_inherit" var
			
			***- Si vous rencontrez une erreur avec ces commandes (le chmod +a n'est pas disponible partout)(Linux), exécutez les commandes suivantes, qui n'utilisent pas le chmod+a:
			
				sudo getfacl /var/www/
			
				sudo adduser nom_utilisateur nom_groupe
					
				sudo chgrp www-data fichier2
			
				HTTPDUSER=`ps aux | grep -E '[a]pache|[h]ttpd|[_]www|[w]ww-data|[n]ginx' | grep -v root | head -1 | cut -d\  -f1`

				sudo setfacl -R -m u:"$HTTPDUSER":rwX -m u:`whoami`:rwX /var/www/--dossier--
				sudo setfacl -dR -m u:"$HTTPDUSER":rwX -m u:`whoami`:rwX /var/www/--dossier--
				
				sudo getfacl /var/www/
			
			- Enfin, si vous ne pouvez pas utiliser les ACL (utilisés dans les commandes précédentes), définissez simplement les droits comme suit :
			
				sudo chmod 777 -R var
				php bin/console cache:clear --no-warmup
				
		
		Le fil rouge de notre cours : une plateforme d'échange

			Dans ce cours, je vous propose de monter de toute pièce une plateforme d'échange. 
			Notre site proposera de poster des annonces de missions pour développeurs, designers, etc. 
			On pourra consulter ces annonces, les commenter, les chercher. 
			Tous les codes que vous trouverez dans ce cours s'articuleront donc autour de ce concept de plateforme d'échange, 
			pensez-y pour avoir une vision globale de ce qu'on construit ! 
		

		L'architecture des fichiers
		
			Liste des répertoires

			Ouvrez donc le répertoire dans lequel vous avez extrait les fichiers. Vous pouvez voir qu'il n'y a pas beaucoup de fichiers ici, seulement des répertoires. En effet, tout est bien rangé dans chaque répertoire, il nous faut donc comprendre à quoi ils servent. En voici la liste :

				app

				bin

				src

				tests

				var

				vendor

				web

			Le répertoire /app

			Ce répertoire contient tout ce qui concerne votre site Internet… sauf son code source. Assez étrange, me direz-vous. En fait, c'est simplement pour séparer le code source, qui fait la logique de votre site, de sa configuration. Ce sont des fichiers qui concernent l'entièreté de votre site, contrairement aux fichiers de code source qui seront découpés par fonctionnalité de votre site. Dans Symfony, un projet de site Internet est une application, simple question de vocabulaire. Le répertoire /app est donc le raccourci pour « application ».
			
			Le répertoire /bin

			Ce répertoire contient tous les exécutable dont nous allons nous servir pendant le développement. Par exécutable, j'entends des commandes PHP, comme on l'a fait avec l'installateur Symfony au chapitre précédent. Je vous le montrerai pas à pas.
			
			Le répertoire /src

			Voici enfin le répertoire dans lequel on mettra le code source ! C'est ici que l'on passera le plus clair de notre temps. Dans ce répertoire, nous organiserons notre code en bundles, des briques de notre application, dont nous verrons la définition plus loin.

			Vous pouvez voir que ce répertoire n'est pas vide : il contient en effet quelques fichiers exemples, fournis par Symfony. Nous les supprimerons plus tard dans ce cours.
			
			Le répertoire /tests

			Ce paragraphe contient tous les tests de votre application. Les tests étant un pan entier du développement et indépendant de Symfony, nous n'en parlerons pas dans ce cours. Sachez cependant qu'ils sont important pour bien développer, je vous inviterai à vous renseigner dessus.
			
			Le répertoire /var

			Nous avons déjà parlé de ce répertoire. Il contient tout ce que Symfony va écrire durant son process : les logs, le cache, et d'autres fichiers nécessaires à son bon fonctionnement. Nous n'écrirons jamais dedans nous même.
			
			Le répertoire /vendor

			Ce répertoire contient toutes les bibliothèques externes à notre application. Dans ces bibliothèques externes, j'inclus Symfony ! Vous pouvez parcourir ce répertoire ; vous y trouverez des bibliothèques comme Doctrine, Twig, SwiftMailer, etc.
			
			

			Et une bibliothèque, c'est quoi exactement ?

			Une bibliothèque est une sorte de boîte noire qui remplit une fonction bien précise, et dont on peut se servir dans notre code. Par exemple, la bibliothèque SwiftMailer permet d'envoyer des e-mails. On ne sait pas comment elle fonctionne (principe de la boîte noire), mais on sait comment s'en servir : on pourra donc envoyer des e-mails très facilement, juste en apprenant rapidement à utiliser la bibliothèque.
			
			
			Le répertoire /web

			Ce répertoire contient tous les fichiers destinés à vos visiteurs : images, fichiers CSS et JavaScript, etc. Il contient également le contrôleur frontal (app.php), dont nous parlerons juste après.

			En fait, c'est le seul répertoire qui devrait être accessible à vos visiteurs. Les autres répertoires ne sont pas censés être accessibles (ce sont vos fichiers de code source, ils vous regardent vous, pas vos visiteurs), c'est pourquoi vous y trouverez des fichiers .htaccess interdisant l'accès depuis l'extérieur. On utilisera donc toujours des URL du type http://localhost/Symfony/web/… au lieu de simplement http://localhost/Symfony/… .

			Si vous le souhaitez, vous pouvez configurer votre Apache pour que l'URL http://localhost/Symfony pointe directement sur le répertoire /web. Pour cela, vous pouvez lire ce tutoriel qui explique comment configurer Apache. Cependant, ce n'est pas très important pour le développement, on en reparlera plus loin.
			
			
			À retenir

			Retenez donc que nous passerons la plupart de notre temps dans le répertoire /src, à travailler sur nos bundles. On touchera également pas mal au répertoire /app pour configurer notre application. Et lorsque nous installerons des bundles téléchargés, nous le ferons dans le répertoire /vendor.
			
			
			
			
			Le contrôleur frontal
			
			Définition

			Le contrôleur frontal (front controller, en anglais) est le point d'entrée de votre application. C'est le fichier par lequel passent toutes vos pages. Vous devez surement connaître le principe d'index.php et des pseudo-frames (avec des URL du type index.php?page=blog) ; eh bien, cet index.php est un contrôleur frontal. Dans Symfony, le contrôleur frontal se situe dans le répertoire /web, il s'agit de app.php ou app_dev.php.

			Pourquoi y a-t-il deux contrôleurs frontaux ? Normalement, c'est un fichier unique qui gère toutes les pages, non ?

			Vous avez parfaitement raison… pour un code classique ! Mais nous travaillons maintenant avec Symfony, et son objectif est de nous faciliter le développement. C'est pourquoi Symfony propose un contrôleur frontal pour nos visiteurs, app.php, et un contrôleur frontal lorsque nous développons, app_dev.php. Ces deux contrôleurs frontaux, fournis par Symfony et prêts à l'emploi, définissent en fait deux environnements de travail.
			
			Deux environnements de travail

			L'objectif est de répondre au mieux suivant la personne qui visite le site :

			Un développeur a besoin d'informations sur la page afin de l'aider à développer. En cas d'erreur, il veut tous les détails pour pouvoir déboguer facilement. Il n'a pas besoin de rapidité.

			Un visiteur normal n'a pas besoin d'informations particulières sur la page. En cas d'erreur, l'origine de celle-ci ne l'intéresse pas du tout, il veut juste retourner d'où il vient. Par contre, il veut que le site soit le plus rapide possible à charger.

			Vous voyez la différence ? À chacun ses besoins, et Symfony compte bien tous les remplir. C'est pourquoi il offre plusieurs environnements de travail :

				L'environnement de développement, appelé « dev », accessible en utilisant le contrôleur frontal app_dev.php. C'est l'environnement que l'on utilisera toujours pour développer.

				L'environnement de production, appelé « prod », accessible en utilisant le contrôleur frontal app.php.

			Essayez-les ! Allez sur http://localhost/Symfony/web/app_dev.php/_profiler et vous accéderez à l'outil Profiler (dont nous reparlerons plus tard). Allez sur http://localhost/Symfony/web/app.php/_profiler et vous obtiendrez... une erreur 404. :p En effet, aucune page n'est définie pour l'URL /_profiler  pour le mode « prod ». Nous les définirons plus tard, mais notez que c'est une « belle » erreur 404, aucun terme barbare n'est employé pour la justifier. ^^
			
			
		La structure d'un bundle

			/Controller          	| Contient vos contrôleurs
			/DataFixtures
				/ORM				| 
			/DependencyInjection 	| Contient des informations sur votre bundle
			/DoctrineLisenter		|
			/Entity              	| Contient vos modèles
			/Events
				/Type_				|
			/EventDispatcher
				/Type_				|
			/EventListener
				/Type_				|
			/Form                	| Contient vos éventuels formulaires
			/Resources
				/config             | Contient les fichiers de configuration de votre bundle
				/public             | Contient les fichiers publics de votre bundle : CSS,JS, images, etc.
				/views
					/Type_			| Contient les vues de notre bundle, les templates Twig
			/Services
				/Type_				|
			/Tests				 	| Contient les tests
		
		Créons notre bundle

			> php bin/console generate:bundle
			- suivre les instructions (Les bundles en sous-dossiers peuvent poser problème)
			
				1. Choisir le namespace
				<NamespaceRacine>/<NomduBundle><Bundle> ex. : OC/PlatformBundle

				2. Choisir le nom du Bundle
				Valider ce qui est proposé : OCPlatformBundle

				3. Choisir la destination
				Valider ce qui est proposé : Symfony/src

				4. Choisir le format de configuration (yml, xml, php, or annotation)
				yml car bien adapté pour un buldle

				5. Choisir quelle structure générer
				choisir non pour le début

				6. Confirmez, et c'est joué !
		
		
		Test du bundle	
			
			- ajout du corps à src/OC/PlatformBundle/Resources/views/Default/index.html.twig
			- Que s'est il passé ?
				- Symfony a généré la structure du bundle
				- Symfony a enregistré notre bundle auprès du Kernel
				- Symfony a enregistré nos routes auprès du Routeur
				
			- Notes
				- Si
					The command was not able to configure everything automatically.  
					You'll need to make the following changes manually.
			
						- Edit the composer.json file and register the bundle
						namespace in the "autoload" section:
						
				- Editer le composer.json en ajoutant le bundle dans PSR4 (Les bundles en sous-dossiers peuvent poser problème)
					"autoload": {
						"psr-4": {
							"AppBundle\\": "src/AppBundle",
							"OcPlatformBundle\\": "src/OcPlatformBundle"
						}
				- composer update
				- php bin/symfony_requirements
				
				- Vider le cache
					- en production un cache
						- si modification apporté
							- php bin/console cache:clear --no-warmup --env=prod
					- en développement caches
						- si modification apporté
							- php bin/console cache:clear --no-warmup
							
			
				 - /*
					 * Noter les chemins :
					 *  - des fichiers à ouvrire pour supprimer un Bundle :
					 *      - /home/marc/public_html/symfony/composer.json
					 *      - /home/marc/public_html/symfony/app/AppKernel.php
					 *      - /home/marc/public_html/symfony/app/config/routing.yml
					 *      - /home/marc/public_html/symfony/app/config/parameters.yml
					 *      - /home/marc/public_html/symfony/app/config/config.yml
					 *  - des fichiers à ouvrire pour les développements :
					 *      - niveau global
					 *          - /home/marc/public_html/symfony/app/config/routing.yml (pour préfixes de rootes de bundle)
					 *      - niveau Bundle (implémenter aussi la structure du Bundle)
					 *          - rooting du bundle
					 *          - services du bundle
					 *          - controller du bundle
					 *          - view du bundle
					 *      - au niveau des services
					 *          - 
					 *      - au niveau des routes
					 *          - authentification
					 *          - 
					 */
					/*
		 
							
		À retenir

			Ce qu'il faut retenir de tout cela, c'est que pour qu'un bundle soit opérationnel, il faut :

				Son code source, situé dans src/Application/Bundle, et dont le seul fichier obligatoire est la classe à la racine OCPlatformBundle.php ;

				Enregistrer le bundle dans le noyau pour qu'il soit chargé, en modifiant le fichier app/AppKernel.php ;

				Enregistrer les routes (si le bundle en contient) dans le Routeur pour qu'elles soient chargées, en modifiant le fichier app/config/routing.yml.

			Ces trois points sont bien sûr effectués automatiquement lorsqu'on utilise le générateur. Mais vous pouvez tout à fait créer un bundle sans l'utiliser, et il faudra alors remplir cette petite checklist manuellement.

			Par la suite, tout notre code source sera situé dans des bundles. Un moyen très propre de bien structurer son application.
			
			
		En résumé

			Les commandes Symfony disponibles en ligne de commande ont pour objectif de nous faciliter la vie en automatisant certaines tâches.

			Les commandes sont faites, comme tout Symfony, en PHP uniquement. La console n'est qu'un moyen différent du navigateur pour exécuter du code PHP. 

			La commande pour générer un nouveau bundle est php bin/console generate:bundle.

			Le code du cours tel qu'il doit être à ce stade est disponible sur la branche iteration-1 du dépot Github.



Partie 2 - Les bases de Symfony
   
	1. Mon premier « Hello World ! » avec Symfony
	
	
	Créons notre route
	
		> éditer Resources/config/routing.yml dans le répertoire du bundle
	
			# src/OC/PlatformBundle/Resources/config/routing.yml

			hello_the_world:
				path:     /hello-world
				defaults: { _controller: OCPlatformBundle:Advert:index }
	
	
	Créons notre contrôleur
	
		> créer le fichier src/OC/PlatformBundle/Controller/AdvertController.php
	
			<?php

				// src/OC/PlatformBundle/Controller/AdvertController.php

				namespace OC\PlatformBundle\Controller;

				use Symfony\Component\HttpFoundation\Response;

				class AdvertController
				{
					public function indexAction()
					{
						return new Response("Notre propre Hello World !");
					}
				}
	
	
	Créons notre template Twig
	
		> éditer le fichier src/OC/PlatformBundle/Resources/views/Advert/index.html.twig
		
			{# src/OC/PlatformBundle/Resources/views/Advert/index.html.twig #}

			<!DOCTYPE html>
			<html>
			  <head>
				<title>Bienvenue sur ma première page avec OpenClassrooms !</title>
			  </head>
			  <body>
				<h1>Hello {{ nom }} !</h1>

				<p>
				  Le Hello World est un grand classique en programmation.
				  Il signifie énormément, car cela veut dire que vous avez
				  réussi à exécuter le programme pour accomplir une tâche simple :
				  afficher ce hello world !
				</p>
			  </body>
			</html>

	
		> modifier le controller
	
			<?php

				// src/OC/PlatformBundle/Controller/AdvertController.php

				namespace OC\PlatformBundle\Controller;

				// N'oubliez pas ce use :
				use Symfony\Bundle\FrameworkBundle\Controller\Controller;
				use Symfony\Component\HttpFoundation\Response;

				class AdvertController extends Controller
				{
				  public function indexAction()
				  {
					$content = $this->get('templating')->render('OCPlatformBundle:Advert:index.html.twig', array('nom' => 'winzou'));
					
					return new Response($content);
				  }
				}
	
	
	Notre objectif : créer une plateforme d'annonces
	
	
		Le fil conducteur

			Comme je vous l'ai déjà annoncé, nous construirons une plateforme d'annonces tout au long de ce cours. 
			Cela me permet d'utiliser des exemples cohérents entre eux et de vous montrer comment construire un tel site de toutes pièces. 
			Bien sûr, libre à vous d'adapter les exemples au projet que vous souhaitez mener, je vous y encourage, même !

			Le choix de ce site permet que l'on se comprenne bien : vous savez déjà ce qu'est une plateforme d'annonces (leboncoin, eBay, etc.), 
			vous comprendrez donc tous les exemples.
	
	
		Notre plateforme
	
			La plateforme que nous allons créer est très simple. En voici les grandes lignes :

				Nous aurons des annonces (advert en anglais) de mission : développement d'un site internet, création d'une maquette, intégration HTML, etc. ;
				Nous pourrons consulter, créer, modifier et rechercher des annonces ;
				À chaque annonce, nous pourrons lier une image d'illustration ;
				À chaque annonce, nous pourrons lier plusieurs candidatures (application en anglais) ;
				Nous aurons plusieurs catégories (Développement, Graphisme, etc.) qui seront liées aux annonces. Nous pourrons créer, modifier et supprimer ces catégories ;
				À chaque annonce, nous pourrons enfin lier des niveaux de compétence requis (Expert en PHP, maîtrise de Photoshop, etc.).
				Au début, nous n'aurons pas de système de gestion des utilisateurs : nous devrons saisir notre nom lorsque nous rédigerons une annonce. 
				Puis, nous rajouterons la couche utilisateur.
			
			
		Un peu de nettoyage
	
			Avec tous les éléments générés par Symfony lors de la création du bundle et les nôtres, 
			il y a un peu de redondance. Vous pouvez donc supprimer joyeusement :
			
				Le contrôleur Controller/DefaultController.php ;
				Le répertoire de vues Resources/views/Default ;
				La route oc_platform_homepage dans Resources/config/routing.yml.

			Supprimez également tout ce qui concerne le bundle AppBundle, un bundle de démonstration intégré dans la 
			distribution standard de Symfony2 et dont nous ne nous servirons pas :

				Le répertoire src/AppBundle  ;
				La lignes 19 du fichier app/AppKernel.php, celle qui active le bundle : new AppBundle\AppBundle() ; 
				Les lignes 7 à 9 du fichier app/config/routing.yml, celles qui importent le fichier de route 
				du bundle AppBundle (app: resource: "@AppBundle/Controller/" type: annotation" ).
	
	
	Schéma de développement sous Symfony
	
	Si vous rafraîchissez la page pour vérifier que tout est bon, il est possible que vous obteniez une erreur ! En effet, il faut prendre dès maintenant un réflexe Symfony : vider le cache. Car Symfony, pour nous offrir autant de fonctionnalités et être si rapide, utilise beaucoup son cache.
	Le cache est constitué de fichiers PHP prêts à être exécutés, contenant tout le nécessaire pour faire tourner Symfony sous une forme plus rapide. Pensez par exemple à la configuration dans les fichiers YAML : quand Symfony génère une page, il va compiler cette configuration dans un tableau PHP (un array ), ce qui sera bien plus rapide à charger la fois suivante.
	Or après certaines modifications, le cache peut ne plus être à jour, ce qui peut entrainer des erreurs. Deux cas de figure :
	- En mode « prod », c'est simple, Symfony ne regénère jamais le cache. Cela lui permet de ne faire aucune vérification sur la validité du cache (ce qui prend du temps), et de servir les pages très rapidement à vos visiteurs. La solution : vider le cache à la main à chaque fois que vous faites des changements. Cela se fait grâce à la commande php bin/console cache:clear --env=prod.
    - En mode « dev », c'est plus simple. Lorsque vous modifiez votre code, Symfony reconstruit une bonne partie du cache à la prochaine page que vous chargez. Donc pas forcément besoin de vider le cache. Seulement, comme il ne reconstruit pas tout, il peut parfois apparaître des bugs un peu étranges. Dans ce cas, un petit php bin/console cache:clear résout le problème en trois secondes !

	Parfois, il se peut que la commande cache:clear génère des erreurs lors de son exécution. Dans ce cas, essayez de relancer la commande, parfois une deuxième passe peut résoudre les problèmes. Dans le cas contraire, supprimez le cache à la main en supprimant simplement le répertoire var/cache/dev (ou var/cache/prod suivant l’environnement).
	Typiquement, un schéma classique de développement est le suivant :

		Je fais des changements, je teste ;
		Je fais des changements, je teste ;
		Je fais des changements, je teste : ça ne marche pas, je vide le cache : ça marche ;
		Je fais des changements, je teste ;
		Je fais des changements, je teste ;
		Je fais des changements, je teste : ça ne marche pas, je vide le cache : ça marche ;
		...
		En fin de journée, j'envoie tout sur le serveur de production, je vide obligatoirement le cache pour le mode prod, je teste : ça marche.

	Évidemment, quand je dis « je teste : ça ne marche pas », j'entends « ça devrait marcher et l'erreur rencontrée est étrange ». Si vous faites une erreur dans votre propre code, ce n'est pas un cache:clear qui va la résoudre ! :p
	
	
	Pour conclure

		Et voilà, nous avons créé une page de A à Z ! Voici plusieurs remarques sur ce chapitre.
		D'abord, ne vous affolez pas si vous n'avez pas tout compris. 
		Le but de ce chapitre était de vous donner une vision globale d'une page Symfony. 
		Vous avez des notions de bundles, de routes, de contrôleurs et de templates : vous savez presque tout ! 
		Il ne reste plus qu'à approfondir chacune de ces notions, ce que nous ferons dès le prochain chapitre.
		Ensuite, sachez que tout n'est pas à refaire lorsque vous créez une deuxième page. 
		Je vous invite là, maintenant, à créer une page /byebye-world et voyez si vous y arrivez. 
		Dans le cas contraire, relisez ce chapitre, puis si vous ne trouvez pas votre erreur, n'hésitez pas à poser 
		votre question sur le forum PHP, d'autres personnes qui sont passés par là seront ravis de vous aider. :)
		Sur le forum, pensez à mettre le tag [Symfony] dans le titre de votre sujet, afin de s'y retrouver. 
		Allez, préparez-vous pour la suite, les choses sérieuses commencent !

		
	En résumé

		Le rôle du routeur est de déterminer quel route utiliser pour la requête courante.
		Le rôle d'une route est d'associer une URL à une action du contrôleur.
		Le rôle du contrôleur est de retourner au noyau un objet Response, qui contient la réponse HTTP à envoyer à l'internaute (page HTML ou redirection).
		Le rôle des vues est de mettre en forme les données que le contrôleur lui donne, afin de construire une page HTML, un flux RSS, un e-mail, etc.
		Le code du cours tel qu'il doit être à ce stade est disponible sur la branche iteration-2 du dépot Github.
	
	
Le routeur de Symfony	
	
	
	Le fonctionnement
	
		> éditer votreBundle/Resources/config/routing.yml
	
			# src/OC/PlatformBundle/Resources/config/routing.yml

				oc_platform_home:
					path:      /platform
					defaults: { _controller: OCPlatformBundle:Advert:index }
					
				oc_platform_view:
					path:      /platform/advert/{id}
					defaults: { _controller: OCPlatformBundle:Advert:view }
					
				oc_platform_add:
					path:      /platform/add
					defaults: { _controller: OCPlatformBundle:Advert:add }
	
	
	Les routes avancées
	
		> dans le router du bundle
		
			# src/OC/PlatformBundle/Resources/config/routing.yml

			oc_platform_view_slug:
				path:      /platform/{year}/{slug}.{format}
				defaults:
					_controller: OCPlatformBundle:Advert:viewSlug
					format:      html
				requirements:
					year:   \d{4}
					format: html|xml
			
		> dans le controller
	
			<?php

			// src/OC/PlatformBundle/Controller/AdvertController.php

			namespace OC\PlatformBundle\Controller;

			use Symfony\Bundle\FrameworkBundle\Controller\Controller;
			use Symfony\Component\HttpFoundation\Response;

			class AdvertController extends Controller
			{
				// On récupère tous les paramètres en arguments de la méthode
				public function viewSlugAction($slug, $year, $format)
				{
					return new Response(
						"On pourrait afficher l'annonce correspondant au
						slug '".$slug."', créée en ".$year." et au format ".$format."."
					);
				}
			}	
	
	
		- Ajouter un préfixe lors de l'import de nos routes
	
			> éditer le fichier app/config/routing.yml
	
				# app/config/routing.yml

				oc_platform:
					resource: "@OCPlatformBundle/Resources/config/routing.yml"
					prefix:   /platform
	
	
	Générer des URL
	
	
		Depuis le contrôleur
	
			<?php

			// src/OC/PlatformBundle/Controller/AdvertController.php

			namespace OC\PlatformBundle\Controller;

			use Symfony\Bundle\FrameworkBundle\Controller\Controller;
			use Symfony\Component\HttpFoundation\Response;

			class AdvertController extends Controller
			{
				public function indexAction()
				{
					// On veut avoir l'URL de l'annonce d'id 5.
					$url = $this->get('router')->generate(
						'oc_platform_view', // 1er argument : le nom de la route
						array('id' => 5)    // 2e argument : les valeurs des paramètres
					);
					// $url vaut « /platform/advert/5 »
					
					return new Response("L'URL de l'annonce d'id 5 est : ".$url);
				}
			}
	
			- deux méthodes :
			
				<?php
				// Depuis un contrôleur

					// Méthode longue
					$url = $this->get('router')->generate('oc_platform_home');

					// Méthode courte
					$url = $this->generateUrl('oc_platform_home');
			
		
				//Depuis une vue Twig (notre moteur de template)
		
				{# Dans une vue Twig, en considérant bien sûr
				   que la variable advert_id est disponible #}

				<a href="{{ path('oc_platform_view', { 'id': advert_id }) }}">
					Lien vers l'annonce d'id {{ advert_id }}
				</a>
	
	
	Application : les routes de notre plateforme
	
		# src/OC/PlatformBundle/Resources/config/routing.yml

		oc_platform_home:
			path:      /{page}
			defaults:
				_controller: OCPlatformBundle:Advert:index
				page:        1
			requirements:
				page: \d*
			
		oc_platform_view:
			path:      /advert/{id}
			defaults:
				_controller: OCPlatformBundle:Advert:view
			requirements:
				id: \d+

		oc_platform_add:
			path:      /add
			defaults:
				_controller: OCPlatformBundle:Advert:add

		oc_platform_edit:
			path:      /edit/{id}
			defaults:
				_controller: OCPlatformBundle:Advert:edit
			requirements:
				id: \d+

		oc_platform_delete:
			path:      /delete/{id}
			defaults:
				_controller: OCPlatformBundle:Advert:delete
			requirements:
				id: \d+

				
				
	# app/config/routing.yml

	oc_platform:
		resource: "@OCPlatformBundle/Resources/config/routing.yml"
		prefix:   /platform
	
	
	Pour conclure

		Ce chapitre est terminé, et vous savez maintenant tout ce qu'il faut savoir sur le routeur et les routes.
		Retenez que ce système de routes vous permet premièrement d'avoir des belles URL, et deuxièmement de découpler le nom de vos URL du nom de vos contrôleurs. 
		Ajoutez à cela la génération d'URL, et vous avez un système extrêmement flexible et maintenable. Le tout sans trop d'efforts !
		Pour plus d'informations sur le système de routes, n'hésitez pas à lire la documentation officielle.

		
	En résumé

		Une route est composée au minimum de deux éléments : l'URL à faire correspondre (sonpath), et le contrôleur à exécuter (paramètre _controller).
		Le routeur essaie de faire correspondre chaque route à l'URL appelée par l'internaute, et ce dans l'ordre d'apparition des routes : la première route qui correspond est sélectionnée.
		Une route peut contenir des paramètres, facultatifs ou non, représentés par les accolades {paramètre}, et dont la valeur peut être soumise à des contraintes via la section requirements.
		Le routeur est également capable de générer des URL à partir du nom d'une route, et de ses paramètres éventuels.
		Le code du cours tel qu'il doit être à ce stade est disponible sur la branche iteration-3 du dépot Github.
	
	
	
Les contrôleurs avec Symfony	
	
	Le rôle du contrôleur
	
		Retourner une réponse
	
			 Il existe dans Symfony les classes Request et Response. 
			 Retourner une réponse signifie donc tout simplement : instancier un objet Response, disons $response, et faire un return $response.
	
				<?php

				// src/OC/PlatformBundle/Controller/AdvertController.php

				namespace OC\PlatformBundle\Controller;

				use Symfony\Bundle\FrameworkBundle\Controller\Controller;
				use Symfony\Component\HttpFoundation\Response;

				class AdvertController extends Controller
				{
				  public function indexAction()
				  {
					return new Response("Hello World !");
				  }
				}
	
	
	Manipuler l'objet Request
	
		Lien
			- http://api.symfony.com/2.7/Symfony/Component/HttpFoundation/Request.html
	
		Nous avons utilisé$request->querypour récupérer les paramètres de l'URL passés en GET, mais vous savez qu'il existe d'autres types de paramètres :

			Type de paramètres
				Méthode Symfony
					Méthode traditionnelle
						Exemple
						
			Variables d'URL
				$request->query
					$_GET
						$request->query->get('tag')

			Variables de formulaire
				$request->request
					$_POST
						$request->request->get('tag')

			Variables de cookie
				$request->cookies
					$_COOKIE
						$request->cookies->get('tag')

			Variables de serveur
				$request->server
					$_SERVER
						$request->server->get('REQUEST_URI')

			Variables d'entête
				$request->headers
					$_SERVER['HTTP_*']
						$request->headers->get('USER_AGENT')

			Paramètres de route
				$request->attributes
					n/a
						On utilise $id dans les arguments de la méthode, mais vous pourriez également faire $request->attributes->get('id')
	
	
		<?php

			// src/OC/PlatformBundle/Controller/AdvertController.php

			namespace OC\PlatformBundle\Controller;

			use Symfony\Bundle\FrameworkBundle\Controller\Controller;
			use Symfony\Component\HttpFoundation\Request;
			use Symfony\Component\HttpFoundation\Response;

			class AdvertController extends Controller
			{
			  // …

			  // On injecte la requête dans les arguments de la méthode
			  public function viewAction($id, Request $request)
			  {
				// On récupère notre paramètre tag
				$tag = $request->query->get('tag');

				return new Response(
				  "Affichage de l'annonce d'id : ".$id.", avec le tag : ".$tag
				);
			  }
			}
	
		
		Récupérer la méthode de la requête HTTP
		
			<?php
			if ($request->isMethod('POST'))
			{
			  // Un formulaire a été envoyé, on peut le traiter ici
			}
		
		
		Savoir si la requête est une requête AJAX
	
			<?php
			if ($request->isXmlHttpRequest())
			{
			  // C'est une requête AJAX, retournons du JSON, par exemple
			}
	
	
	Manipuler l'objet Response
	
		<?php

		// src/OC/PlatformBundle/Controller/AdvertController.php

		namespace OC\PlatformBundle\Controller;

		use Symfony\Bundle\FrameworkBundle\Controller\Controller;
		use Symfony\Component\HttpFoundation\Request;
		use Symfony\Component\HttpFoundation\Response;

		class AdvertController extends Controller
		{
		  // On modifie viewAction, car elle existe déjà
		  public function viewAction($id)
		  {
			// On crée la réponse sans lui donner de contenu pour le moment
			$response = new Response();

			// On définit le contenu
			$response->setContent("Ceci est une page d'erreur 404");

			// On définit le code HTTP à « Not Found » (erreur 404)
			$response->setStatusCode(Response::HTTP_NOT_FOUND);

			// On retourne la réponse
			return $response;
		  }
		}
	
	
		Réponses et vues
	
			<?php

			// src/OC/PlatformBundle/Controller/AdvertController.php

			namespace OC\PlatformBundle\Controller;

			use Symfony\Bundle\FrameworkBundle\Controller\Controller;
			use Symfony\Component\HttpFoundation\Request;
			use Symfony\Component\HttpFoundation\Response;

			class AdvertController extends Controller
			{
			  public function viewAction($id, Request $request)
			  {
				// On récupère notre paramètre tag
				$tag = $request->query->get('tag');
				
				// On utilise le raccourci : il crée un objet Response
				// Et lui donne comme contenu le contenu du template
				return $this->get('templating')->renderResponse(
				  'OCPlatformBundle:Advert:view.html.twig',
				  array('id'  => $id, 'tag' => $tag)
				);
			  }
			}
	
	
	
			<?php

			public function viewAction($id, Request $request)
			{
				// On récupère notre paramètre tag
				$tag = $request->query->get('tag');

				return $this->render('OCPlatformBundle:Advert:view.html.twig', array(
				  'id'  => $id,
				  'tag' => $tag,
				));
			}
	
	
			{# src/OC/PlatformBundle/Resources/view/Advert/view.html.twig #}

			<!DOCTYPE html>
			<html>
			  <head>
				<title>Affichage de l'annonce {{ id }}</title>
			  </head>
			  <body>
				<h1>Hello Annonce n°{{ id }} !</h1>
				<p>Tag éventuel : {{ tag }}</p>
			  </body>
			</html>

	
		Réponse et redirection
	
			<?php

			// src/OC/PlatformBundle/Controller/AdvertController.php

			namespace OC\PlatformBundle\Controller;

			use Symfony\Bundle\FrameworkBundle\Controller\Controller;
			use Symfony\Component\HttpFoundation\RedirectResponse; // N'oubliez pas ce use
			use Symfony\Component\HttpFoundation\Response;

			class AdvertController extends Controller
			{
			  public function viewAction($id)
			  {
				$url = $this->get('router')->generate('oc_platform_home');
				
				return new RedirectResponse($url);
			  }
			}
			
	
			<?php

			public function viewAction($id)
			{
			  $url = $this->get('router')->generate('oc_platform_home');
			  
			  return $this->redirect($url);
			}
	
	
			<?php

			public function viewAction($id)
			{
			  return $this->redirectToRoute('oc_platform_home');
			}
	
	
		Changer le Content-type de la réponse
	
			<?php

			// src/OC/PlatformBundle/Controller/AdvertController.php

			namespace OC\PlatformBundle\Controller;

			use Symfony\Bundle\FrameworkBundle\Controller\Controller;
			use Symfony\Component\HttpFoundation\Response;

			class AdvertController extends Controller
			{
			  public function viewAction($id)
			  {
				// Créons nous-mêmes la réponse en JSON, grâce à la fonction json_encode()
				$response = new Response(json_encode(array('id' => $id)));

				// Ici, nous définissons le Content-type pour dire au navigateur
				// que l'on renvoie du JSON et non du HTML
				$response->headers->set('Content-Type', 'application/json');

				return $response;
			  }
	


			<?php

			use Symfony\Component\HttpFoundation\JsonResponse;

			// ...

			public function viewAction($id)
			{
			  return new JsonResponse(array('id' => $id));
			}

		
	Manipuler la session	
		
		<?php
		// src/OC/PlatformBundle/Controller/AdvertController.php

		namespace OC\PlatformBundle\Controller;

		use Symfony\Component\HttpFoundation\Request;
		use Symfony\Component\HttpFoundation\Response;
		use Symfony\Bundle\FrameworkBundle\Controller\Controller;

		class AdvertController extends Controller
		{
		  public function viewAction($id, Request $request)
		  {
			// Récupération de la session
			$session = $request->getSession();
			
			// On récupère le contenu de la variable user_id
			$userId = $session->get('user_id');

			// On définit une nouvelle valeur pour cette variable user_id
			$session->set('user_id', 91);

			// On n'oublie pas de renvoyer une réponse
			return new Response("<body>Je suis une page de test, je n'ai rien à dire</body>");
		  }
		}
		
		
		<?php

		// src/OC/PlatformBundle/Controller/AdvertController.php

		namespace OC\PlatformBundle\Controller;

		use Symfony\Component\HttpFoundation\Response;
		use Symfony\Component\HttpFoundation\Request;
		use Symfony\Bundle\FrameworkBundle\Controller\Controller;

		class AdvertController extends Controller
		{
		  public function viewAction($id)
		  {
			return $this->render('OCPlatformBundle:Advert:view.html.twig', array(
			  'id' => $id
			));
		  }
			
		  // Ajoutez cette méthode :
		  public function addAction(Request $request)
		  {
			$session = $request->getSession();
			
			// Bien sûr, cette méthode devra réellement ajouter l'annonce
			
			// Mais faisons comme si c'était le cas
			$session->getFlashBag()->add('info', 'Annonce bien enregistrée');

			// Le « flashBag » est ce qui contient les messages flash dans la session
			// Il peut bien sûr contenir plusieurs messages :
			$session->getFlashBag()->add('info', 'Oui oui, elle est bien enregistrée !');

			// Puis on redirige vers la page de visualisation de cette annonce
			return $this->redirectToRoute('oc_platform_view', array('id' => 5));
		  }
		}
		
		
		{# src/OC/PlatformBundle/Resources/view/Advert/view.html.twig #}

		<!DOCTYPE html>
		<html>
		  <head>
			<title>Affichage de l'annonce {{ id }}</title>
		  </head>
		  <body>
			<h1>Affichage de l'annonce n°{{ id }} !</h1>

			<div>
			  {# On affiche tous les messages flash dont le nom est « info » #}
			  {% for message in app.session.flashbag.get('info') %}
				<p>Message flash : {{ message }}</p>
			  {% endfor %}
			</div>

			<p>
			  Ici nous pourrons lire l'annonce ayant comme id : {{ id }}<br />
			  Mais pour l'instant, nous ne savons pas encore le faire, cela viendra !
			</p>
		  </body>
		</html>

		
		
	Application : le contrôleur de notre plateforme	
		
		Construction du contrôleur
		
			# src/OC/PlatformBundle/Resources/config/routing.yml

			oc_platform_home:
				path:      		 /{page}
				defaults:
					_controller: OCPlatformBundle:Advert:index
					page:        1
				requirements:
					page: 		 \d*
				
			oc_platform_view:
				path:      		 /advert/{id}
				defaults:
					_controller: OCPlatformBundle:Advert:view
				requirements:
					id: 		 \d+

			oc_platform_add:
				path:      		 /add
				defaults:
					_controller: OCPlatformBundle:Advert:add

			oc_platform_edit:
				path:      		 /edit/{id}
				defaults:
					_controller: OCPlatformBundle:Advert:edit
				requirements:
					id: 		 \d+

			oc_platform_delete:
				path:      		 /delete/{id}
				defaults:
					_controller: OCPlatformBundle:Advert:delete
				requirements:
					id: 		 \d+

		
			<?php

			// src/OC/PlatformBundle/Controller/AdvertController.php

			namespace OC\PlatformBundle\Controller;

			use Symfony\Bundle\FrameworkBundle\Controller\Controller;
			use Symfony\Component\HttpFoundation\Request;
			use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;

			class AdvertController extends Controller
			{
			  public function indexAction($page)
			  {
				// On ne sait pas combien de pages il y a
				// Mais on sait qu'une page doit être supérieure ou égale à 1
				if ($page < 1) {
				  // On déclenche une exception NotFoundHttpException, cela va afficher
				  // une page d'erreur 404 (qu'on pourra personnaliser plus tard d'ailleurs)
				  throw new NotFoundHttpException('Page "'.$page.'" inexistante.');
				}

				// Ici, on récupérera la liste des annonces, puis on la passera au template

				// Mais pour l'instant, on ne fait qu'appeler le template
				return $this->render('OCPlatformBundle:Advert:index.html.twig');
			  }

			  public function viewAction($id)
			  {
				// Ici, on récupérera l'annonce correspondante à l'id $id

				return $this->render('OCPlatformBundle:Advert:view.html.twig', array(
				  'id' => $id
				));
			  }

			  public function addAction(Request $request)
			  {
				// La gestion d'un formulaire est particulière, mais l'idée est la suivante :

				// Si la requête est en POST, c'est que le visiteur a soumis le formulaire
				if ($request->isMethod('POST')) {
				  // Ici, on s'occupera de la création et de la gestion du formulaire

				  $request->getSession()->getFlashBag()->add('notice', 'Annonce bien enregistrée.');

				  // Puis on redirige vers la page de visualisation de cettte annonce
				  return $this->redirectToRoute('oc_platform_view', array('id' => 5));
				}

				// Si on n'est pas en POST, alors on affiche le formulaire
				return $this->render('OCPlatformBundle:Advert:add.html.twig');
			  }

			  public function editAction($id, Request $request)
			  {
				// Ici, on récupérera l'annonce correspondante à $id

				// Même mécanisme que pour l'ajout
				if ($request->isMethod('POST')) {
				  $request->getSession()->getFlashBag()->add('notice', 'Annonce bien modifiée.');

				  return $this->redirectToRoute('oc_platform_view', array('id' => 5));
				}

				return $this->render('OCPlatformBundle:Advert:edit.html.twig');
			  }

			  public function deleteAction($id)
			  {
				// Ici, on récupérera l'annonce correspondant à $id

				// Ici, on gérera la suppression de l'annonce en question

				return $this->render('OCPlatformBundle:Advert:delete.html.twig');
			  }
			}
		
		
	Pour conclure

		Créer un contrôleur à ce stade du cours n'est pas évident, car vous ne connaissez et ne maîtrisez pas encore tous les services nécessaires. 
		Seulement, vous avez pu comprendre son rôle et voir un exemple concret.
		Rassurez-vous, dans la partie 4 du cours, on apprendra tout le nécessaire pour construire l'intérieur de nos contrôleurs. ;) 
		En attendant, rendez-vous au prochain chapitre pour en apprendre plus sur les templates.
		Pour plus d'informations concernant les contrôleurs, n'hésitez pas à lire la documentation officielle.

		
	En résumé

		Le rôle du contrôleur est de retourner un objetResponse: ceci est obligatoire !
		Le contrôleur construit la réponse en fonction des données qu'il a en entrée : paramètre de route et objetRequest.
		Le contrôleur se sert de tout ce dont il a besoin pour construire la réponse : la base de données, les vues, les différents services, etc.
		Le code du cours tel qu'il doit être à ce stade est disponible sur la branche iteration-4 du dépot Github.	
		
		
		
Le moteur de templates Twig		
		
	Les templates Twig	
		
		
	Afficher des variables	
		
		https://openclassrooms.com/courses/developpez-votre-site-web-avec-le-framework-symfony/le-moteur-de-templates-twig-1
		
		
		enregistrer nos propres variables globales	
			
			# app/config/parameters.yml

			parameters:
				# …
				app_webmaster: moi-même
			
			# app/config/config.yml

			twig:
				globals:
					webmaster: %app_webmaster%
		
		
		
		Structures de contrôle et expressions
		
			Condition : {% if %}
			
				{% if membre.age < 12 %}
				  Il faut avoir au moins 12 ans pour ce film.
				{% elseif membre.age < 18 %}
				  OK bon film.
				{% else %}
				  Un peu vieux pour voir ce film non ?
				{% endif %}
		
			Boucle : {% for %}
		
				<ul>
				  {% for membre in liste_membres %}
					<li>{{ membre.pseudo }}</li>
				  {% else %}
					<li>Pas d'utilisateur trouvé.</li>
				  {% endfor %}
				</ul>
		
			Définition : {% set %}
			
				{% set foo = 'bar' %}
		
			Les tests utiles
			
				Defined
				
					{% if var is defined %} … {% endif %}
		
				Even / Odd
		
					{% for valeur in liste %}
					  <span class="{% if loop.index is even %}pair{% else %}
						impair{% endif %}">
						{{ valeur }}
					  </span>
					{% endfor %}


					
	Hériter et inclure des templates				
					
			
		Voici à quoi peut ressembler un template père (appelé plus communément layout). 
		Mettons-le dans src/OC/PlatformBundle/Resources/views/layout.html.twig		
					
			{# src/OC/PlatformBundle/Resources/views/layout.html.twig #}

			<!DOCTYPE HTML>
			<html>
			  <head>
				<meta charset="utf-8">
				<title>{% block title %}OC Plateforme{% endblock %}</title>
			  </head>
			  <body>

				{% block body %}
				{% endblock %}

			  </body>
			</html>		
					
					
		Et voici un de nos templates fils. 
		Mettons-le dans src/OC/PlatformBundle/Resources/views/Advert/index.html.twig		
					
			{# src/OC/PlatformBundle/Resources/views/Advert/index.html.twig #}

			{% extends "OCPlatformBundle::layout.html.twig" %}

			{% block title %}{{ parent() }} - Index{% endblock %}

			{% block body %}
			  Notre plateforme est un peu vide pour le moment, mais cela viendra !
			{% endblock %}		
					
					
					
		L'inclusion de templates		
					
			{# src/OC/PlatformBundle/Resources/views/Advert/add.html.twig #}

			{% extends "OCPlatformBundle::layout.html.twig" %}

			{% block body %}

			  <h2>Ajouter une annonce</h2>

			  {{ include("OCPlatformBundle:Advert:form.html.twig") }}

			  <p>
				Attention : cette annonce sera ajoutée directement
				sur la page d'accueil après validation du formulaire.
			  </p>

			{% endblock %}		
					
					
			{# src/OC/PlatformBundle/Resources/views/Advert/form.html.twig #}

			{# Cette vue n'hérite de personne, elle sera incluse par d'autres vues qui,
			   elles, hériteront probablement du layout. Je dis « probablement » car,
			   ici pour cette vue, on n'en sait rien et c'est une info qui ne nous concerne pas. #}

			<h3>Formulaire d'annonce</h3>

			{# On laisse vide la vue pour l'instant, on la comblera plus tard
			   lorsqu'on saura afficher un formulaire. #}
			<div class="well">
			  Ici se trouvera le formulaire.
			</div>		
					
					
		L'inclusion de contrôleurs

			{# src/OC/PlatformBundle/Resources/views/layout.html.twig #}

			<!DOCTYPE HTML>
			<html>
			  <head>
				<meta charset="utf-8">
				<title>{% block title %}OC Plateforme{% endblock %}</title>
			  </head>
			  <body>

				<div id="menu">
				  {{ render(controller("OCPlatformBundle:Advert:menu")) }}
				</div>

				{% block body %}
				{% endblock %}

			  </body>
			</html>
			
			
			<?php

				// src/OC/PlatformBundle/Controller/AdvertController.php

				namespace OC\PlatformBundle\Controller;

				use Symfony\Bundle\FrameworkBundle\Controller\Controller;
				use Symfony\Component\HttpFoundation\Request;
				use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;

				class AdvertController extends Controller
				{
				  // ...

				  public function menuAction()
				  {
					// On fixe en dur une liste ici, bien entendu par la suite
					// on la récupérera depuis la BDD !
					$listAdverts = array(
					  array('id' => 2, 'title' => 'Recherche développeur Symfony'),
					  array('id' => 5, 'title' => 'Mission de webmaster'),
					  array('id' => 9, 'title' => 'Offre de stage webdesigner')
					);

					return $this->render('OCPlatformBundle:Advert:menu.html.twig', array(
					  // Tout l'intérêt est ici : le contrôleur passe
					  // les variables nécessaires au template !
					  'listAdverts' => $listAdverts
					));
				  }
				}
			
			
			{# src/OC/PlatformBundle/Resources/views/Advert/menu.html.twig #}

			{# Ce template n'hérite de personne,
			   tout comme le template inclus avec {{ include() }}. #}

			<ul class="nav nav-pills nav-stacked">
			  {% for advert in listAdverts %}
				<li>
				  <a href="{{ path('oc_platform_view', {'id': advert.id}) }}">
					{{ advert.title }}
				  </a>
				</li>
			  {% endfor %}
			</ul>
			
			
			
	Application : les templates de notre plateforme		
	
	
		Layout général
			
			
			{# app/Resources/views/layout.html.twig #}

			<!DOCTYPE html>
			<html>
			<head>
			  <meta charset="utf-8">
			  <meta name="viewport" content="width=device-width, initial-scale=1">

			  <title>{% block title %}OC Plateforme{% endblock %}</title>

			  {% block stylesheets %}
				{# On charge le CSS de bootstrap depuis le site directement #}
				<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">
			  {% endblock %}
			</head>

			<body>
			  <div class="container">
				<div id="header" class="jumbotron">
				  <h1>Ma plateforme d'annonces</h1>
				  <p>
					Ce projet est propulsé par Symfony,
					et construit grâce au MOOC OpenClassrooms et SensioLabs.
				  </p>
				  <p>
					<a class="btn btn-primary btn-lg" href="https://openclassrooms.com/courses/developpez-votre-site-web-avec-le-framework-symfony2">
					  Participer au MOOC »
					</a>
				  </p>
				</div>

				<div class="row">
				  <div id="menu" class="col-md-3">
					<h3>Les annonces</h3>
					<ul class="nav nav-pills nav-stacked">
					  <li><a href="{{ path('oc_platform_home') }}">Accueil</a></li>
					  <li><a href="{{ path('oc_platform_add') }}">Ajouter une annonce</a></li>
					</ul>

					<h4>Dernières annonces</h4>
					{{ render(controller("OCPlatformBundle:Advert:menu", {'limit': 3})) }}
				  </div>
				  <div id="content" class="col-md-9">
					{% block body %}
					{% endblock %}
				  </div>
				</div>

				<hr>

				<footer>
				  <p>The sky's the limit © {{ 'now'|date('Y') }} and beyond.</p>
				</footer>
			  </div>

			  {% block javascripts %}
				{# Ajoutez ces lignes JavaScript si vous comptez vous servir des fonctionnalités du bootstrap Twitter #}
				<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
				<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
			  {% endblock %}

			</body>
			</html>	
			
			
		Layout du bundle
		
		
			{# src/OC/PlatformBundle/Resources/views/layout.html.twig #}

			{% extends "::layout.html.twig" %}

			{% block title %}
			  Annonces - {{ parent() }}
			{% endblock %}

			{% block body %}

			  {# On définit un sous-titre commun à toutes les pages du bundle, par exemple #}
			  <h1>Annonces</h1>

			  <hr>

			  {# On définit un nouveau bloc, que les vues du bundle pourront remplir #}
			  {% block ocplatform_body %}
			  {% endblock %}

			{% endblock %}
		
		
		
		Les templates finaux
		
		
			{# src/OC/PlatformBundle/Resources/views/Advert/index.html.twig #}

			{% extends "OCPlatformBundle::layout.html.twig" %}

			{% block title %}
			  Accueil - {{ parent() }}
			{% endblock %}

			{% block ocplatform_body %}

			  <h2>Liste des annonces</h2>

			  <ul>
				{% for advert in listAdverts %}
				  <li>
					<a href="{{ path('oc_platform_view', {'id': advert.id}) }}">
					  {{ advert.title }}
					</a>
					par {{ advert.author }},
					le {{ advert.date|date('d/m/Y') }}
				  </li>
				{% else %}
				  <li>Pas (encore !) d'annonces</li>
				{% endfor %}
			  </ul>

			{% endblock %}
		
		
			
			<?php
			// src/OC/PlatformBundle/Controller/AdvertController.php

			// Dans l'action indexAction() :
			return $this->render('OCPlatformBundle:Advert:index.html.twig', array(
			  'listAdverts' => array()
			));
		
		
		
			<?php
			// src/OC/PlatformBundle/Controller/AdvertController.php

			  public function menuAction($limit)
			  {
				// On fixe en dur une liste ici, bien entendu par la suite
				// on la récupérera depuis la BDD !
				$listAdverts = array(
				  array('id' => 2, 'title' => 'Recherche développeur Symfony'),
				  array('id' => 5, 'title' => 'Mission de webmaster'),
				  array('id' => 9, 'title' => 'Offre de stage webdesigner')
				);

				return $this->render('OCPlatformBundle:Advert:menu.html.twig', array(
				  // Tout l'intérêt est ici : le contrôleur passe
				  // les variables nécessaires au template !
				  'listAdverts' => $listAdverts
				));
			  }
		
		
		
			{# src/OC/PlatformBundle/Resources/views/Advert/menu.html.twig #}

			<ul class="nav nav-pills nav-stacked">
			  {% for advert in listAdverts %}
				<li>
				  <a href="{{ path('oc_platform_view', {'id': advert.id}) }}">
					{{ advert.title }}
				  </a>
				</li>
			  {% endfor %}
			</ul>
		
			
			
			Voici un tableau d'annonces à ajouter temporairement dans la méthode indexAction(), 
			que vous pouvez passer en paramètre à la méthode render(). C'est un tableau pour l'exemple, 
			par la suite il faudra bien sûr récupérer les annonces depuis la base de données !
			
			
			<?php
			// src/OC/PlatformBundle/Controller/AdvertController.php

			// …

			public function indexAction($page)
			  {
				// ...

				// Notre liste d'annonce en dur
				$listAdverts = array(
				  array(
					'title'   => 'Recherche développpeur Symfony',
					'id'      => 1,
					'author'  => 'Alexandre',
					'content' => 'Nous recherchons un développeur Symfony débutant sur Lyon. Blabla…',
					'date'    => new \Datetime()),
				  array(
					'title'   => 'Mission de webmaster',
					'id'      => 2,
					'author'  => 'Hugo',
					'content' => 'Nous recherchons un webmaster capable de maintenir notre site internet. Blabla…',
					'date'    => new \Datetime()),
				  array(
					'title'   => 'Offre de stage webdesigner',
					'id'      => 3,
					'author'  => 'Mathieu',
					'content' => 'Nous proposons un poste pour webdesigner. Blabla…',
					'date'    => new \Datetime())
				);

				// Et modifiez le 2nd argument pour injecter notre liste
				return $this->render('OCPlatformBundle:Advert:index.html.twig', array(
				  'listAdverts' => $listAdverts
				));
			  }
			
		
		
			Advert/view.html.twig
		
				{# src/OC/PlatformBundle/Resources/view/Advert/view.html.twig #}

				{% extends "OCPlatformBundle::layout.html.twig" %}

				{% block title %}
				  Lecture d'une annonce - {{ parent() }}
				{% endblock %}

				{% block ocplatform_body %}

				  <h2>{{ advert.title }}</h2>
				  <i>Par {{ advert.author }}, le {{ advert.date|date('d/m/Y') }}</i>

				  <div class="well">
					{{ advert.content }}
				  </div>

				  <p>
					<a href="{{ path('oc_platform_home') }}" class="btn btn-default">
					  <i class="glyphicon glyphicon-chevron-left"></i>
					  Retour à la liste
					</a>
					<a href="{{ path('oc_platform_edit', {'id': advert.id}) }}" class="btn btn-default">
					  <i class="glyphicon glyphicon-edit"></i>
					  Modifier l'annonce
					</a>
					<a href="{{ path('oc_platform_delete', {'id': advert.id}) }}" class="btn btn-danger">
					  <i class="glyphicon glyphicon-trash"></i>
					  Supprimer l'annonce
					</a>
				  </p>

				{% endblock %}
		
		
		
		
				<?php
				// src/OC/PlatformBundle/Controller/AdvertController.php

				// …

				public function viewAction($id)
				  {
					$advert = array(
					  'title'   => 'Recherche développpeur Symfony2',
					  'id'      => $id,
					  'author'  => 'Alexandre',
					  'content' => 'Nous recherchons un développeur Symfony2 débutant sur Lyon. Blabla…',
					  'date'    => new \Datetime()
					);

					return $this->render('OCPlatformBundle:Advert:view.html.twig', array(
					  'advert' => $advert
					));
				  }
		
		
		
			Advert/edit.html.twig et add.html.twig
		
			
				{# src/OC/PlatformBundle/Resources/views/Advert/edit.html.twig #}

				{% extends "OCPlatformBundle::layout.html.twig" %}

				{% block title %}
				  Modifier une annonce - {{ parent() }}
				{% endblock %}

				{% block ocplatform_body %}

				  <h2>Modifier une annonce</h2>

				  {{ include("OCPlatformBundle:Advert:form.html.twig") }}

				  <p>
					Vous éditez une annonce déjà existante, merci de ne pas changer
					l'esprit général de l'annonce déjà publiée.
				  </p>

				  <p>
					<a href="{{ path('oc_platform_view', {'id': advert.id}) }}" class="btn btn-default">
					  <i class="glyphicon glyphicon-chevron-left"></i>
					  Retour à l'annonce
					</a>
				  </p>

				{% endblock %}
			
			
			
			
				{# src/OC/PlatformBundle/Resources/views/Advert/form.html.twig #}

				<h3>Formulaire d'annonce</h3>

				{# On laisse vide la vue pour l'instant, on la comblera plus tard
				   lorsqu'on saura afficher un formulaire. #}
				<div class="well">
				  Ici se trouvera le formulaire.
				</div>
			
			
			
				
				<?php
				// src/OC/PlatformBundle/Controller/AdvertController.php

				  public function editAction($id, Request $request)
				  {
					// ...
					
					$advert = array(
					  'title'   => 'Recherche développpeur Symfony',
					  'id'      => $id,
					  'author'  => 'Alexandre',
					  'content' => 'Nous recherchons un développeur Symfony débutant sur Lyon. Blabla…',
					  'date'    => new \Datetime()
					);

					return $this->render('OCPlatformBundle:Advert:edit.html.twig', array(
					  'advert' => $advert
					));
				  }
			
			
			
	Installer un bundle grâce à Composer		
			
		Composer, qu'est-ce que c'est ?	
			
			Composer a donc pour objectif de vous aider à gérer toutes vos dépendances. 
			
			
		Concrètement, comment ça marche ?
		
			On définit dans un fichier la liste des bibliothèques dont le projet dépend, ainsi que leur version ;

			On exécute une commande pour installer ou mettre à jour ces bibliothèques (et leurs propres dépendances donc) ;

			On inclut alors le fichier d'autoload généré par Composer dans notre projet.
		
		
		Installer Composer et Git
		
			Installation de Composer sur Win
				
				C:\wamp\www> php -r "eval('?>'.file_get_contents('http://getcomposer.org/installer'));"
		
				php composer.phar --version
		
				php composer.phar self-update
		
		
			Installer Git sur Win
		
				Sous Windows, il faut utiliser msysgit. Cela installe msys (un système d'émulation des commandes Unix sous Windows) et Git lui-même
			
				git version
			
			
			Installer Git sous Linux
			
				sudo apt-get install git-core
			
		
		Installer un bundle grâce à Composer		
		
			Mettre à jour les dépendances
			
				php ../composer.phar update
		
		
			Mettons à jour Symfony
		
				php ../composer.phar update
		
		
			Installer un bundle avec Composer
		
				1. Trouver le nom du bundle
					
					http://packagist.org/
		
				2. Déterminer la version du bundle
		
					Une fois que vous avez trouvé votre bundle, il faut en sélectionner une version. Il se peut que celui-ci n'ait pas vraiment de version fixe, et que seul "dev-master" soit disponible. Dans ce cas, assurez vous (auprès du développeur, ou en regardant le code) qu'il est compatible avec votre projet.
				
				3. Déclarer le bundle à Composer
		
					// composer.json

					// …

					"require": {
					  "php": ">=5.5.9",
					  // …
					  "incenteev/composer-parameter-handler": "~2.0",
					  "doctrine/doctrine-fixtures-bundle": "~2.3"
					},

					// …
		
		
					N'oubliez pas d'ajouter une virgule à la fin de l'avant-dernière dépendance, dans mon cas "incenteev/composer-parameter-handler", sinon ce n'est plus du Json valide !
		
		
		
				4. Mettre à jour les dépendances
		
					php ../composer.phar update
					
		
		
				5. Enregistrer le bundle dans le Kernel
		
					<?php
					// app/AppKernel.php

					// …

					  if (in_array($this->getEnvironment(), array('dev', 'test'))) {
						  // ...
						  $bundles[] = new Doctrine\Bundle\FixturesBundle\DoctrineFixturesBundle();
						}

					// …
			
			
			Gérer l'autoload d'une bibliothèque manuellement
		
				// composer.json

				{
				  // …

				  "autoload": {
					"psr-4": {
					  "": "src/",
					  "VotreNamespace": "chemin/vers/la/bibliotheque"
					},
					"files": [ "app/AppKernel.php" ]
				  },

				  // …
				}
				
				
	Les services, théorie et création			
				
		Pourquoi utiliser des services ?		
				
			Qu'est-ce qu'un service ?	
				
				Un service est donc un objet PHP qui a pour vocation d'être accessible depuis n'importe où dans votre code.
				Il faut vraiment bien comprendre cela : un service est avant tout une simple classe.
				
				Pour ceux qui connaissent, le concept de service est un bon moyen d'éviter d'utiliser trop souvent à mauvais escient le pattern singleton (utiliser une méthode statique pour récupérer l'objet depuis n'importe où).
				
				
			L'avantage de la programmation orientée services	
				
				Chaque service ne remplit qu'une seule et unique fonction, ils sont facilement réutilisables. Et vous pouvez surtout facilement les développer, les tester et les configurer puisqu'ils sont assez indépendants. Cette façon de programmer est connue sous le nom d'architecture orientée services
				(https://fr.wikipedia.org/wiki/Architecture_orient%C3%A9e_services).
				
				
			Le conteneur de services	
				
				Pour accéder à un service, il faut passer par le conteneur.
				
				
			Comment définir les dépendances entre services ?	
				
				Comment dire au conteneur que le Service2 doit être instancié avant le Service1 ? Cela se fait grâce à la configuration dans Symfony.
				
				L'idée est de définir pour chaque service :

					Son nom, qui permettra de l'identifier au sein du conteneur ;

					Sa classe, qui permettra au conteneur d'instancier le service ;

					Les arguments dont il a besoin. Un argument peut être un autre service, mais aussi un paramètre (défini dans le fichier parameters.yml par exemple).
				
				
			Le partage des services	
				
				Chaque service est « partagé ». Cela signifie simplement que la classe du service est instanciée une seule fois (à la première récupération du service) par le conteneur.
				
				
		Utiliser un service en pratique		
				
			Récupérer un service	
				
				Depuis un contrôleur
				
					<?php
					$this->container->get('mailer');				
				
				
					<?php
					// src/OC/PlatformBundle/Controller/AdvertController.php

					namespace OC\PlatformBundle\Controller;

					use Symfony\Bundle\FrameworkBundle\Controller\Controller;

					class AdvertController extends Controller
					{
					  public function indexAction()
					  {
						// On a donc accès au conteneur :
						$mailer = $this->container->get('mailer'); 

						// On peut envoyer des e-mails, etc.
					  }
					}
				
				
			Créer un service simple	
				
				Création de la classe du service
				
					Notre besoin : détecter les spams à partir d'un simple texte. Comme c'est une fonction à part entière, et qu'on aura besoin d'elle à plusieurs endroits (pour les annonces et pour les futurs commentaires), faisons en un service. Ce service devra être réutilisable simplement dans d'autres projets Symfony : il ne devra pas être dépendant d'un élément de notre plateforme.
				
					Vous l'aurez compris, ce service étant indépendant de notre plateforme d'annonces, il devrait se trouver dans un bundle séparé ! Un bundle AntiSpamBundle qui offrirait des outils de lutte contre le spam. Toutefois pour rester simple dans notre exemple, plaçons-le quand même dans notre OCPlatformBundle.
				
					Vous pouvez le nommer comme vous le souhaitez. Il n'y a pas de règle précise à ce niveau, mis à part que l'utilisation des underscores (« _ ») est déconseillée.
				
					Créons donc le fichier src/OC/PlatformBundle/Antispam/OCAntispam.php :
					
						<?php
						// src/OC/PlatformBundle/Antispam/OCAntispam.php

						namespace OC\PlatformBundle\Antispam;

						class OCAntispam
						{
						}
				
					
					C'est tout ce qu'il faut pour avoir un service.
					Ajoutons :
					
						<?php
						// src/OC/PlatformBundle/Antispam/OCAntispam.php

						namespace OC\PlatformBundle\Antispam;

						class OCAntispam
						{
						  /**
						   * Vérifie si le texte est un spam ou non
						   *
						   * @param string $text
						   * @return bool
						   */
						  public function isSpam($text)
						  {
							return strlen($text) < 50;
						  }
						}
				
				
				Création de la configuration du service
				
					Un service se définit par sa classe ainsi que sa configuration. Pour cela, nous pouvons utiliser le fichier src/OC/PlatformBundle/Ressources/config/services.yml.
				
					Si vous avez généré votre bundle avec le generator en répondant « oui » pour créer toute la structure du bundle, alors ce fichier services.yml est chargé automatiquement. Vérifiez-le en confirmant que le répertoire DependencyInjection de votre bundle existe, il devrait contenir le fichier OCPlatformExtension.php (nom du bundle suivi de Extension).
				
					Si ce n'est pas le cas, vous devez créer le fichier DependencyInjection/OCPlatformExtension.php (adaptez à votre bundle évidemment). Mettez-y le contenu suivant, qui permet de charger automatiquement le fichier services.yml que nous allons modifier :
				
						<?php

						namespace OC\PlatformBundle\DependencyInjection;

						use Symfony\Component\DependencyInjection\ContainerBuilder;
						use Symfony\Component\Config\FileLocator;
						use Symfony\Component\HttpKernel\DependencyInjection\Extension;
						use Symfony\Component\DependencyInjection\Loader;

						class OCPlatformExtension extends Extension
						{
							public function load(array $configs, ContainerBuilder $container)
							{
								$configuration = new Configuration();
								$config = $this->processConfiguration($configuration, $configs);

								$loader = new Loader\YamlFileLoader($container, new FileLocator(__DIR__.'/../Resources/config'));
								$loader->load('services.yml');
							}
						}

					La méthode load() de cet objet est automatiquement exécutée par Symfony lorsque le bundle est chargé. Et dans cette méthode, on charge le fichier de configuration services.yml, ce qui permet d'enregistrer la définition des services qu'il contient dans le conteneur de services. Fin de la parenthèse.
				
					Ouvrez ou créez le fichier Ressources/config/services.yml de votre bundle
				
						# src/OC/PlatformBundle/Resources/config/services.yml

						services:
							oc_platform.antispam:
								class: OC\PlatformBundle\Antispam\OCAntispam
				
					Dans cette configuration :

					oc_platform.antispam est le nom de notre service fraîchement créé. De cette manière, le service sera accessible via $container->get('oc_platform.antispam');. Essayez de respecter la convention en préfixant le nom de vos services par le nom du bundle, ici « oc_platform ».

					class est un attribut obligatoire de notre configuration, il définit simplement le namespace complet de la classe du service. Cela indique au conteneur de services quelle classe instancier lorsqu'on lui demandera le service.
					
					
					Pour définir un paramètre, la technique est la même que pour un service, dans le fichier services.yml:
					
					
						parameters:
						mon_parametre: ma_valeur

						services:
							# ...
					
					
				Utilisation du service	
					
					<?php

					// src/OC/PlatformBundle/Controller/AdvertController.php

					namespace OC\PlatformBundle\Controller;

					use Symfony\Bundle\FrameworkBundle\Controller\Controller;
					use Symfony\Component\HttpFoundation\Request;

					class AdvertController extends Controller
					{
					  public function addAction(Request $request)
					  {
						// On récupère le service
						$antispam = $this->container->get('oc_platform.antispam');

						// Je pars du principe que $text contient le texte d'un message quelconque
						$text = '...';
						if ($antispam->isSpam($text)) {
						  throw new \Exception('Votre message a été détecté comme spam !');
						}
						
						// Ici le message n'est pas un spam
					  }
					}
					
					
			Créer un service avec des arguments		
					
				Injecter des arguments dans nos services	
					
					Pour passer des arguments à votre service, il faut utiliser sa configuration :
					
						# src/OC/PlatformBundle/Resources/config/services.yml

						services:
							oc_platform.antispam:
								class: OC\PlatformBundle\Antispam\OCAntispam
								arguments: [] # Tableau d'arguments
					
					Les arguments peuvent être :

						Des valeurs normales en YAML (des booléens, des chaînes de caractères, des nombres, etc.) ;

						Des paramètres (définis dans le parameters.yml par exemple) : l'identifiant du paramètre est encadré de signes « % » :%nomDuParametre%;

						Des services : l'identifiant du service est précédé d'une arobase :@nomDuService.
					
					
					Pour tester l'utilisation de ces trois types d'arguments, je vous propose d'injecter différentes valeurs dans notre service d'antispam, comme ceci par exemple :
					
						# src/OC/PlatformBundle/Resources/config/services.yml

						services:
							oc_platform.antispam:
								class: OC\PlatformBundle\Antispam\OCAntispam
								arguments:
									- "@mailer"
									- "%locale%"
									- 50
					
					Dans cet exemple, notre service utilise :

						@mailer: le service Mailer (pour envoyer des e-mails) ;

						%locale%: le paramètre locale (pour récupérer la langue, définit dans le fichier app/config/parameters.yml) ;

						50: et le nombre 50 (qu'importe son utilité !).

					Une fois vos arguments définis dans la configuration, il vous suffit de les récupérer avec le constructeur du service. Les arguments de la configuration et ceux du constructeur vont donc de paire. Si vous modifiez l'un, n'oubliez pas d'adapter l'autre. Voici donc le constructeur adapté à notre nouvelle configuration :
					
					
						<?php
						// src/OC/PlatformBundle/Antispam/OCAntispam.php

						namespace OC\PlatformBundle\Antispam;

						class OCAntispam
						{
						  private $mailer;
						  private $locale;
						  private $minLength;

						  public function __construct(\Swift_Mailer $mailer, $locale, $minLength)
						  {
							$this->mailer    = $mailer;
							$this->locale    = $locale;
							$this->minLength = (int) $minLength;
						  }

						  /**
						   * Vérifie si le texte est un spam ou non
						   *
						   * @param string $text
						   * @return bool
						   */
						  public function isSpam($text)
						  {
							return strlen($text) < $this->minLength;
						  }
						}
					
					L'idée du constructeur est de récupérer les arguments pour les stocker dans les attributs de la classe afin de pouvoir les réutiliser plus tard. L'ordre des arguments du constructeur est le même que l'ordre des arguments définis dans la configuration du service.

					Vous pouvez voir que j'ai également modifié la méthode isSpam() pour vous montrer comment utiliser un argument. Ici, j'ai remplacé le « 50 » que j'avais mis en dur précédemment par la valeur de l'argument minLength. Ainsi, si vous décidez de passer cette valeur à 100 au lieu de 50, vous ne modifiez que la configuration du service, sans toucher à son code !
					
					
				L'injection de dépendances	
				
					Au même titre que vous avez mis @mailer  en argument, vous pourrez mettre @oc_platform.antispam  !
					
					
				Aperçu du code	
					
					Actualisez bien la page pour que Symfony mette à jour son cache, rouvrez le fichier var/cache/dev/appDevDebugProjectContainer.php  et cherchez la méthode getOcPlatform_AntispamService :
					
						<?php
						protected function getOcPlatform_AntispamService()
						{
						  return $this->services['oc_platform.antispam'] = new \OC\PlatformBundle\Antispam\OCAntispam(
							$this->get('swiftmailer.mailer.default'),
							'en',
							50
						  );
						}
					
					
				Vous constatez que Symfony a généré le code nécessaire pour récupérer notre service et ses 3 dépendances. Notez ces deux petits points :

				Nous avons défini la dépendance mailer mais le conteneur de service crée le service swiftmailer.mailer.default. En réalité, mailer est un alias, c'est-à-dire que c'est un pointeur vers un autre service. L'idée est que si un jour vous changez de bibliothèques pour envoyer des e-mails, vous utiliserez toujours le service mailer dans vos contrôleurs, mais celui-ci pointera vers un autre service ;

				Le paramètre %locale% que nous avons utilisé a été transformé en en pour english, qui est la valeur que j'ai dans mon fichier parameters.yml. En effet lors de la génération du conteneur de services, Symfony connaît déjà la valeur de ce paramètre, il gagne donc du temps en écrivant directement la valeur et non $this->getParameter('locale').	
					
					
					
					
	 Activité : Créez votre CoreBundle pour les gouverner tous
		
		Prenons l’exemple de notre application, nous avons déjà un bundle de plateforme d’annonce ; imaginons qu’on y ajoute un bundle de forum, lieu d’échange entre les utilisateurs. Dans ce cas, où pouvons-nous mettre la page profil d’un utilisateur affichant à la fois le nombre de candidatures effectuées et le nombre de messages postés sur le forum ? Cette page ne peut pas être dans notre PlatformBundle car notre bundle ne connait rien du forum, impossible pour lui d’accéder au nombre de messages postés. La situation est la même depuis le ForumBundle, qui ne connait rien de nos annonces.

		La solution est donc d’utiliser un CoreBundle qui vient faire la glue entre tous les autres bundles utilisés. Vous l’aurez compris, ce bundle n’est nullement réutilisable entre vos projets : c’est le seul qui est vraiment spécifique à votre application.

		Vous l’aurez compris, notre CoreBundle étant la glue de notre site, il est assez logique d’y placer notre layout général. Je vous invite donc à déplacer notre layout (app/Resources/views/layout.html.twig) dans le nouveau CoreBundle.

		Bien entendu, n’oubliez pas d’adapter le code des autres vues afin de mettre à jour le nom de la vue qu’elles héritent. Notre vue layout a changé de place, elle a donc changé de nom.
		
		Créer la page d’accueil
		Créer une page de contact
		
		
	 
	Partie 3 - Gérer la base de données avec Doctrine2
	
		https://openclassrooms.com/courses/developpez-votre-site-web-avec-le-framework-symfony/la-couche-metier-les-entites-1
		
	
		1. La couche métier : les entités
		
			Lien :
				- Symfony 
					- https://symfony.com/doc/master/doctrine.html
				- Doctrine Mapping
					- http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/basic-mapping.html
					
		
			Exemple d'entité :
			
				<?php
				// src/OC/PlatformBundle/Entity/Advert.php

				namespace OC\PlatformBundle\Entity;

				// On définit le namespace des annotations utilisées par Doctrine2
				// En effet, il existe d'autres annotations, on le verra par la suite,
				// qui utiliseront un autre namespace
				use Doctrine\ORM\Mapping as ORM;

				/**
				 * @ORM\Entity
				 */
				class Advert
				{
				  /**
				   * @ORM\Column(name="id", type="integer")
				   * @ORM\Id
				   * @ORM\GeneratedValue(strategy="AUTO")
				   */
				  protected $id;

				  /**
				   * @ORM\Column(name="date", type="date")
				   */
				  protected $date;

				  /**
				   * @ORM\Column(name="title", type="string", length=255)
				   */
				  protected $title;

				  /**
				   * @ORM\Column(name="author", type="string", length=255)
				   */
				  protected $author;

				  /**
				   * @ORM\Column(name="content", type="text")
				   */
				  protected $content;

				  // Les getters
				  // Les setters
				}
			
					
			Générer une entité : le générateur à la rescousse !
				
				1. Configurer les paramètres de la base de données " app/config/parameters.yml ", si la base de données n'est pas créée sur le server, lancer la commande :
				
					C:\wamp\www\Symfony>php bin/console doctrine:database:create
				
				2. Génération de notre entité
				
					C:\wamp\www\Symfony>php bin/console doctrine:generate:entity
				
						- définir le nom de l'entité : OCPlatformBundle:Advert (utiliser les flèches, tab et espace pour la sugestion)
						- définir le format de configuration : annotation
						- définir un champ (le champ id est automatiquement créé) : date
						- définir un type (liste des types est donnée) : datetime
						- définir si facultatif ou nullable : false
						- définir si unique : false
						
				3. Répétez les 4 derniers points pour les propriétés  title ,  author  et  content .  
				title  et  author sont de type  string  de 255 caractères (pourquoi pas).
				Content est en revanche de type  text .
				
				4. taper Entrée :
				
					 Entity generation  
						 
					  created ./src/OcPlatformBundle/Entity/
					  created ./src/OcPlatformBundle/Entity/Advert.php
					> Generating entity class src/OcPlatformBundle/Entity/Advert.php: OK!
					> Generating repository class src/OcPlatformBundle/Repository/AdvertRepository.php: OK!
					
					
				5. Affiner notre entité avec de la logique métier
				
					- Attributs calculés
				
					N'hésitez donc pas à créer des méthodes getQuelquechose() qui contiennent de la logique métier ou modèle dans l'entité. 
					L'avantage de mettre la logique dans l'entité même est que vous êtes sûrs de réutiliser cette même logique partout dans votre application. 
					Il est bien plus propre et pratique de faire$commande->getPrixTotal()que d'éparpiller à droite et à gauche différentes manières de calculer ce prix total.
					
					- Attributs par défaut
					
					Pour notre entitéAdvert, on pourrait définir le constructeur suivant :
					
					<?php
					// src/OC/PlatformBundle/Entity/Advert.php

					namespace OC\PlatformBundle\Entity;

					use Doctrine\ORM\Mapping as ORM;

					/**
					 * Advert
					 *
					 * @ORM\Table()
					 * @ORM\Entity(repositoryClass="OC\PlatformBundle\Entity\AdvertRepository")
					 */
					class Advert
					{
					  // ...

					  public function __construct()
					  {
						// Par défaut, la date de l'annonce est la date d'aujourd'hui
						$this->date = new \Datetime();
					  }
					  
					  // ...
					}

					Un repository sert à récupérer vos entités depuis la base de données, on en reparle dans un chapitre dédié plus loin dans le cours.
					
					
					
				Pour conclure

					Vous savez maintenant tout ce qu'il faut savoir sur la couche Modèle sous Symfony2 en utilisant les entités de l'ORM Doctrine2.

					Je vous redonne l'adresse de la documentation Doctrine2, que vous serez amenés à utiliser maintes fois dans vos développements : http://docs.doctrine-project.org/proje [...] st/index.html. J'insiste : enregistrez-la dans vos favoris, car Doctrine est une bibliothèque très large, et bien que je vous donne un maximum d'informations dans cette partie du cours, je ne pourrai pas tout couvrir.

					Attention, Doctrine étant une bibliothèque totalement indépendante de Symfony, sa documentation fait référence à ce type d'annotation :/** @Entity **/.
					Il faut impérativement l'adapter à votre projet Symfony, en préfixant toutes les annotations par « ORM\ » comme nous l'avons vu dans ce chapitre :/** @ORM\Entity **/.
					Car dans nos entités, c'est le namespace ORM que nous chargeons. Ainsi, l'annotation@Entityn'existe pas pour nous, c'est@ORMqui existe (et tous ses enfants :@ORM\Entity,@ORM\Table, etc.).
					Dans le prochain chapitre, nous apprendrons à manipuler les entités que nous savons maintenant construire.

					En résumé

					Le rôle d'un ORM est de se charger de la persistance de vos données : vous manipulez des objets, et lui s'occupe de les enregistrer en base de données.
					L'ORM par défaut livré avec Symfony est Doctrine2.
					L'utilisation d'un ORM implique un changement de raisonnement : on utilise des objets, et on raisonne en POO. C'est au développeur de s'adapter à Doctrine2, et non l'inverse !
					Une entité est, du point de vue PHP, un simple objet. Du point de vue de Doctrine, c'est un objet complété avec des informations de mapping qui lui permettent d'enregistrer correctement l'objet en base de données.
					Une entité est, du point de vue de votre code, un objet PHP qui correspond à un besoin, et indépendant du reste de votre application.
					Le code du cours tel qu'il doit être à ce stade est disponible sur la branche iteration-8 du dépot Github.	
					
					
		
		2. Manipuler ses entités avec Doctrine2
		
			Matérialiser les tables en base de données
			
				Créer la table correspondante dans la base de données
		
					D'abord, si vous ne l'avez pas déjà fait, il faut créer la base de données. Pour cela, exécutez la commande (vous n'avez à le faire qu'une seule fois évidemment) :

					C:\wamp\www\Symfony>php bin/console doctrine:database:create
					Created database `symfony` for connection named default

					C:\wamp\www\Symfony>_
					
					Ensuite, il faut générer les tables à l'intérieur de cette base de données. Exécutez donc la commande suivante :

					php bin/console doctrine:schema:update --dump-sql
					
					Cette dernière commande est vraiment performante. 
					Elle compare l'état actuel de la base de données avec ce qu'elle devrait être en tenant compte de toutes nos entités. 
					Puis, elle affiche les requêtes SQL à exécuter pour passer de l'état actuel au nouvel état.

					En l'occurrence, nous avons créé seulement une entité, donc la différence entre l'état actuel (base de données vide) et le nouvel état (base de données avec une tableAdvert) n'est que d'une seule requête SQL : la requête de création de la table. Doctrine vous affiche donc cette requête :

					CREATE TABLE Advert (
						id INT AUTO_INCREMENT NOT NULL,
						date DATETIME NOT NULL,
						title VARCHAR(255) NOT NULL,
						author VARCHAR(255) NOT NULL,
						content LONGTEXT NOT NULL,
						PRIMARY KEY(id)
					) ENGINE = InnoDB;
					
					Pour l'instant, rien n'a été fait en base de données, Doctrine nous a seulement affiché la ou les requêtes qu'il s'apprête à exécuter. 
					
					>>> Pensez à toujours valider rapidement ces requêtes, pour être sûrs de ne pas avoir fait d'erreur dans le mapping des entités. 
					
					Mais maintenant, il est temps de passer aux choses sérieuses, et d'exécuter concrètement cette requête ! Lancez la commande suivante :

					C:\wamp\www\Symfony>php bin/console doctrine:schema:update --force
					
					Updating database schema...
					Database schema updated successfully! "1" query were executed

					C:\wamp\www\Symfony>_
					
					
				Modifier une entité
				
					Pour modifier une entité, il suffit de lui créer un attribut et de lui attacher l'annotation correspondante. 
					En ajoutant un attribut$published, un booléen qui indique si l'annonce est publiée (truepour l'afficher sur la page d'accueil,falsesinon).
					
						<?php
						// src/OC/PlatformBundle/Entity/Advert.php

						namespace OC\PlatformBundle\Entity;

						use Doctrine\ORM\Mapping as ORM;

						/**
						 * Advert
						 *
						 * @ORM\Table()
						 * @ORM\Entity(repositoryClass="OC\PlatformBundle\Entity\AdvertRepository")
						 */
						class Advert
						{
						  // ... les autres attributs

						  /**
						   * @ORM\Column(name="published", type="boolean")
						   */
						  private $published = true;
						  
						  // ...
						}
					
					
					Puis exécuter la commande doctrine:generate:entities :
					
						C:\wamp\www\Symfony>php bin/console doctrine:generate:entities OCPlatformBundle:Advert
						
						Generating entity "OC\PlatformBundle\Entity\Advert"
						  > backing up Advert.php to Advert.php~
						  > generating OC\PlatformBundle\Entity\Advert
					
					  
					Maintenant, il ne reste plus qu'à enregistrer ce schéma en base de données. Exécutez donc :
					
						php bin/console doctrine:schema:update --dump-sql
					
					
					C'est le cas, cet outil de Doctrine est vraiment pratique ! Puis exécutez la commande pour modifier effectivement la table correspondante :

						php bin/console doctrine:schema:update --force
						
						
					Et voilà ! Votre entité a un nouvel attribut qui sera persisté en base de données lorsque vous l'utiliserez.




				Enregistrer ses entités avec l'EntityManager
					
					
					Les services Doctrine2
					
						Le service Doctrine gère la persistance de nos objets. Il est accessible depuis le contrôleur comme n'importe quel service :
					
							<?php
							
							$doctrine = $this->get('doctrine');
					
						La classeController de Symfony intègre un raccourci. Il fait exactement la même chose, mais est plus joli et permet l'autocomplétion :
						
							<?php
							
							$doctrine = $this->getDoctrine();
					
						C'est donc ce service Doctrine qui gère la base de données. Il s'occupe de deux choses :

							- Les différentes connexions à des bases de données. C'est la partie DBAL de Doctrine2. En effet, vous pouvez tout à fait utiliser plusieurs connexions à plusieurs bases de données différentes. Cela n'arrive que dans des cas particuliers, mais c'est toujours bon à savoir que Doctrine le gère bien. Le service Doctrine dispose donc, entre autres, de la méthode$doctrine->getConnection($name)qui récupère une connexion à partir de son nom. Cette partie DBAL permet à Doctrine2 de fonctionner sur plusieurs types de SGBDR, tels que MySQL, PostgreSQL, etc.
							
							- Les différents gestionnaires d'entités, ou EntityManager. C'est la partie ORM de Doctrine2. Encore une fois, c'est logique, vous pouvez bien sûr utiliser plusieurs gestionnaires d'entités, ne serait-ce qu'un par connexion ! Le service dispose donc, entre autres, de la méthode dont nous nous servirons beaucoup :$doctrine->getManager($name)qui récupère un ORM à partir de son nom.
							
							Dans la suite du cours, je considère que vous n'avez qu'un seul EntityManager, ce qui est le cas par défaut. La méthodegetManager()permet de récupérer l'EntityManager par défaut en omettant l'argument$name. J'utiliserai donc toujours$doctrine->getManager()sans argument, mais pensez à adapter si ce n'est pas votre cas !
							
							Si vous souhaitez utiliser plusieurs EntityManager, vous pouvez vous référer à la documentation officielle qui l'explique.
							
								https://symfony.com/doc/current/doctrine/multiple_entity_managers.html
								
						
						Le service EntityManager
						
							On vient de le voir, le service qui va nous intéresser vraiment n'est pas doctrine, mais l'EntityManager de Doctrine. Vous savez déjà le récupérer depuis le contrôleur via :

							<?php
							
							$em = $this->getDoctrine()->getManager();
							Mais sachez que, comme tout service qui se respecte, vous pouvez y accéder directement via :

							<?php
							
							$em = $this->get('doctrine.orm.entity_manager');
							
							Mais attention, la première méthode vous assure l'autocomplétion, c'est celle que nous utiliserons, alors que la deuxième pas forcément (cela dépend en fait de votre IDE) ;).

							C'est avec l'EntityManager que l'on va passer le plus clair de notre temps. C'est lui qui permet de dire à Doctrine « Persiste cet objet », c'est lui qui va exécuter les requêtes SQL (que l'on ne verra jamais), bref, c'est lui qui fera tout.

							La seule chose qu'il ne sait pas faire facilement, c'est récupérer les entités depuis la base de données. Pour faciliter l'accès aux objets, on va utiliser des Repository.
							
							
							Les repositories	
							
								Les repositories sont des objets, qui utilisent un EntityManager en coulisses, mais qui sont bien plus faciles et pratiques à utiliser de notre point de vue. Je parle des repositories au pluriel car il en existe un par entité. Quand on parle d'un repository en particulier, il faut donc toujours préciser le repository de quelle entité, afin de bien savoir de quoi on parle.

								On accède à ces repositories de la manière suivante :

								<?php
								$em = $this->getDoctrine()->getManager();
								$advertRepository = $em->getRepository('OCPlatformBundle:Advert');
								
								L'argument de la méthodegetRepositoryest l'entité pour laquelle récupérer le repository. Il y a deux manières de spécifier l'entité voulue :

									- Soit en utilisant le namespace complet de l'entité. 
									Pour notre exemple, cela donnerait :'OC\PlatformBundle\Entity\Advert'.
								
									- Soit en utilisant le raccourciNom_du_bundle:Nom_de_l'entité. 
									Pour notre exemple, c'est donc'OCPlatformBundle:Advert'. 
									C'est un raccourci qui fonctionne partout dans Doctrine.
								
								Attention, ce raccourci ne fonctionne que si vous avez mis vos entités dans le namespaceEntitydans votre bundle.
								Ce sont donc ces repositories qui nous permettront de récupérer nos entités. Ainsi, pour charger deux entités différentes, il faut d'abord récupérer leur repository respectif. Un simple pli à prendre, mais très logique.
								
							
								Schéma à retenir :
								
									$doctrine = $this->getDoctrine();
									
									$em = $doctrine->getManager();
									
										$em->getRepository('OcPlatformBundle:Advert');
											
											Advert[1]
											Advert[2]
											...
										
										$em->getRepository('AutreBundle:Image');
								
											Image[1]
											Image[2]
											...
							
							
						Enregistrer ses entités en base de données
							
							Rappelez-vous, on a déjà vu comment créer une entité. Maintenant que l'on a cette magnifique entité entre les mains, il faut la donner à Doctrine pour qu'il l'enregistre en base de données. L'enregistrement effectif en base de données se fait en deux étapes très simples depuis un contrôleur. Modifiez la méthodeaddAction()de notre contrôleur pour faire les tests :
							
								<?php
								// src/OC/PlatformBundle/Controller/AdvertController.php

								namespace OC\PlatformBundle\Controller;

								use OC\PlatformBundle\Entity\Advert;
								use Symfony\Bundle\FrameworkBundle\Controller\Controller;
								use Symfony\Component\HttpFoundation\Request;

								class AdvertController extends Controller
								{
								  public function addAction(Request $request)
								  {
									// Création de l'entité
									$advert = new Advert();
									$advert->setTitle('Recherche développeur Symfony.');
									$advert->setAuthor('Alexandre');
									$advert->setContent("Nous recherchons un développeur Symfony débutant sur Lyon. Blabla…");
									// On peut ne pas définir ni la date ni la publication,
									// car ces attributs sont définis automatiquement dans le constructeur

									// On récupère l'EntityManager
									$em = $this->getDoctrine()->getManager();

									// Étape 1 : On « persiste » l'entité
									$em->persist($advert);

									// Étape 2 : On « flush » tout ce qui a été persisté avant
									$em->flush();

									// Reste de la méthode qu'on avait déjà écrit
									if ($request->isMethod('POST')) {
									  $request->getSession()->getFlashBag()->add('notice', 'Annonce bien enregistrée.');

									  // Puis on redirige vers la page de visualisation de cettte annonce
									  return $this->redirectToRoute('oc_platform_view', array('id' => $advert->getId()));
									}

									// Si on n'est pas en POST, alors on affiche le formulaire
									return $this->render('OCPlatformBundle:Advert:add.html.twig', array('advert' => $advert));
								  }
								}
							
								On peut tout à fait faire plusieurs persists sur différentes entités avant d'exécuter un seul flush. 
								Le flush permet d'exécuter les requêtes les plus optimisées pour enregistrer tous nos persists.
								
								Allez sur la page /platform/add, et voilà, vous venez d'ajouter une annonce dans la base de données !

								Si la requête SQL effectuée vous intéresse, je vous invite à cliquer sur l'icône tout à droite dans la barre d'outil Symfony en bas de la page.
								
								
								
							Modification d'entités enregistrées en base de données
							
								
								<?php
								// Depuis un contrôleur

								$em = $this->getDoctrine()->getManager();

								// On crée une nouvelle annonce
								$advert1 = new Advert;
								$advert1->setTitle('Recherche développeur.');
								$advert1->setContent("Pour mission courte");
								// Et on le persiste
								$em->persist($advert1);

								// On récupère l'annonce d'id 5. On n'a pas encore vu cette méthode find(),
								// mais elle est simple à comprendre. Pas de panique, on la voit en détail
								// dans un prochain chapitre dédié aux repositories
								$advert2 = $em->getRepository('OCPlatformBundle:Advert')->find(5);

								// On modifie cette annonce, en changeant la date à la date d'aujourd'hui
								$advert2->setDate(new \Datetime());

								// Ici, pas besoin de faire un persist() sur $advert2. En effet, comme on a
								// récupéré cette annonce via Doctrine, il sait déjà qu'il doit gérer cette
								// entité. Rappelez-vous, un persist ne sert qu'à donner la responsabilité
								// de l'objet à Doctrine.

								// Enfin, on applique les deux changements à la base de données :
								// Un INSERT INTO pour ajouter $advert1
								// Et un UPDATE pour mettre à jour la date de $advert2
								$em->flush();
								
								
								
							Les autres méthodes utiles de l'EntityManager
							
								
								http://www.doctrine-project.org/api/orm/2.5/class-Doctrine.ORM.EntityManager.html
								
								
								detach($entite)  annule lepersist() effectué sur l'entité en argument. Au prochainflush(), aucun changement ne sera donc appliqué à l'entité. Voici un exemple :

									<?php
									$em->persist($advert);
									$em->persist($comment);
									$em->detach($advert);
									$em->flush(); // Enregistre $comment mais pas $advert
									
								clear($nomEntite) annule tous lespersist()effectués. Si le nom d'une entité est précisé (son namespace complet ou son raccourci), seuls lespersist()sur des entités de ce type seront annulés. Siclear() est appelé sans argument, cela revient à faire undetach() sur toutes les entités d'un coup. Voici un exemple :

									<?php
									$em->persist($advert);
									$em->persist($comment);
									$em->clear();
									$em->flush(); // N'exécutera rien, car les deux persists sont annulés par le clear
								
								contains($entite) retourne true si l'entité donnée en argument est gérée par l'EntityManager (s'il y a eu un persist() sur l'entité donc). Voici un exemple :

									<?php
									$em->persist($advert);
									var_dump($em->contains($advert)); // Affiche true
									var_dump($em->contains($comment)); // Affiche false
									
								refresh($entite) met à jour l'entité donnée en argument dans l'état où elle est en base de données. Cela écrase et donc annule tous les changements qu'il a pu y avoir sur l'entité concernée. Voici un exemple :

									<?php
									$advert->setTitle('Un nouveau titre');
									$em->refresh($advert);
									var_dump($advert->getTitle()); // Affiche « Un ancien titre »
									
								remove($entite) supprime l'entité donnée en argument de la base de données. Effectif au prochain flush(). Voici un exemple :

									<?php
									$em->remove($advert);
									$em->flush(); // Exécute un DELETE sur $advert
									
							
							Récupérer ses entités avec un Repository
							
								Récupérer une unique entité en fonction de son id.

								Il faut d'abord pour cela récupérer le repository de l'entité que vous voulez. 
								On l'a vu précédemment, voici un rappel :
								
									<?php
									// Depuis un contrôleur

									$repository = $this->getDoctrine()
									  ->getManager()
									  ->getRepository('OCPlatformBundle:Advert')
									;
								
								Puis, depuis ce repository, il faut utiliser la méthode find($id)qui retourne l'entité correspondant à l'id$id. 
								Je vous invite à essayer ce code directement dans la méthode viewAction()de notre contrôleur Advert, là où on avait défini en dur un tableau $advert. 
								On pourra ainsi voir l'effet immédiatement :
								
									<?php
									// src/OC/PlatformBundle/Controller/AdvertController.php

									namespace OC\PlatformBundle\Controller;

									use Symfony\Bundle\FrameworkBundle\Controller\Controller;
									use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;

									class AdvertController extends Controller
									{
									  public function viewAction($id)
									  {
										// On récupère le repository
										$repository = $this->getDoctrine()
										  ->getManager()
										  ->getRepository('OCPlatformBundle:Advert')
										;

										// On récupère l'entité correspondante à l'id $id
										$advert = $repository->find($id);

										// $advert est donc une instance de OC\PlatformBundle\Entity\Advert
										// ou null si l'id $id  n'existe pas, d'où ce if :
										if (null === $advert) {
										  throw new NotFoundHttpException("L'annonce d'id ".$id." n'existe pas.");
										}

										// Le render ne change pas, on passait avant un tableau, maintenant un objet
										return $this->render('OCPlatformBundle:Advert:view.html.twig', array(
										  'advert' => $advert
										));
									  }
									}
								
								Allez voir le résultat sur la page /platform/advert/1 ! 
								Vous pouvez changer l'id de l'annonce à récupérer dans l'URL, en fonction des annonces que vous avez ajoutés plus haut depuis la méthodeaddAction().
								
								Sachez aussi qu'il existe une autre syntaxe pour faire la même chose directement depuis l'EntityManager, je vous la présente afin que vous ne soyez pas surpris si vous la croisez. Il s'agit de la méthode find de l'EntityManager, et non du Repository :

									<?php

									// Depuis un contrôleur

									$advert = $this->getDoctrine()
									  ->getManager()
									  ->find('OCPlatformBundle:Advert', $id)
									;
									
								Son premier argument est le nom de l'entité. 
								J'ai utilisé ici le raccourci mais vous pouvez utiliser le namespace complet bien entendu. 
								Son deuxième argument est l'id de l'instance à récupérer.

								Je n'en dis pas plus pour le moment, patientez jusqu'au chapitre consacré aux repositories !


							En résumé

								Il faut exécuter la commande doctrine:schema:update pour mettre à jour la base de données et la faire correspondre à l'état actuel de vos entités.
								
								Avec Symfony, on récupère l'EntityManager de Doctrine2 via le service doctrine.orm.entity_manager ou, plus simplement depuis un contrôleur, via $this->getDoctrine()->getManager().
								
								L'EntityManager sert à manipuler les entités, tandis que les repositories servent à récupérer les entités.
								
								Le code du cours tel qu'il doit être à ce stade est disponible sur la branche iteration-9 du dépot Github.
								
								
								
								
								
								
		3. Les relations entre entités avec Doctrine2
			
			
			Présentation
				
				Les différents types de relations

					Il y a plusieurs façons de lier des entités entre elles. 
					En effet, il n'est pas pareil de lier une multitude de commentaires à un seul article et de lier un membre à un seul groupe. 
					Il existe donc plusieurs types de relations, pour répondre à plusieurs besoins concrets. 
					Ce sont les relationsOneToOne,OneToManyetManyToMany. 
					On les étudie juste après ces quelques notions de base à avoir.
					

				Notions techniques d'ORM à savoir
				
					Avant de voir en détail les relations, il faut comprendre comment elles fonctionnent. N'ayez pas peur, il y a juste deux notions à savoir avant d'attaquer.


					Notion de propriétaire et d'inverse
					
						La notion de propriétaire et d'inverse est abstraite mais importante à comprendre.
						L'entité propriétaire est celle qui contient la référence à l'autre entité.
						
						Pour créer une relation entre ces deux tables, vous allez mettre naturellement une colonneadvert_iddans la tablecomment. 
						La tablecomment est donc propriétaire de la relation, car c'est elle qui contient la colonne de liaisonadvert_id. 
						
						Attention : ne pas créer des clés étrangères dans les tables, laisser Doctrine s'en charger !
						
					
					Notion d'unidirectionnalité et de bidirectionnalité
					
						Cette notion est également simple à comprendre : une relation peut être à sens unique ou à double sens. 
						On ne va traiter dans ce chapitre que les relations à sens unique, dites unidirectionnelles. 
						Cela signifie que vous pourrez écrire $entiteProprietaire->getEntiteInverse()(dans notre exemple $comment->getAdvert()), mais pas entiteInverse->getEntiteProprietaire()(pour nous, $advert->getComments()). 
						Attention, cela ne nous empêchera pas de récupérer les commentaires d'une annonce, on utilisera juste une autre méthode, via le repository.

						Cette limitation nous simplifie la façon de définir les relations. 
						Pour bien travailler avec, il suffit juste de se rappeler qu'on ne peut pas faire$entiteInverse->getEntiteProprietaire().

						Pour des cas spécifiques, ou des préférences dans votre code, cette limitation peut être contournée en utilisant les relations à double sens, dites bidirectionnelles. 
						Je les expliquerai rapidement à la fin de ce chapitre.
						
						
				
				Rien n'est magique
				
					Imaginez qu'on veuille juste récupérer une annonce pour avoir son titre, et Doctrine nous récupère la liste des 54 commentaires, qui en plus sont liés à leurs 54 auteurs respectifs, etc. !

					Doctrine utilise ce qu'on appelle le Lazy Loading, « chargement fainéant » en français. 
					C'est-à-dire qu'il ne charge les entités à l'autre bout de la relation que si vous voulez réellement accéder à ces entités. 
					C'est donc uniquement au moment où vous faites$advert->getComments()que Doctrine charge les commentaires (avec une nouvelle requête SQL donc) puis vous les transmet.
					
					Il faudra simplement utiliser nos propres méthodes pour charger les entités, dans lesquelles nous ferons des jointures toutes simples. 
					L'idée est de dire à Doctrine : « Charge l'entitéAdvert, mais également tous ses commentaires ». 
					Avoir nos propres méthodes pour cela permet de ne les exécuter que si nous voulons vraiment avoir les commentaires en plus de l'annonce. 
					En somme, on se garde le choix de charger ou non la relation.

					Mais nous verrons tout cela dans le prochain chapitre sur les repositories. Pour l'instant, revenons à nos relations !
				
				
				
			Relation One-To-One
				
				Présentation
				
					Si à chaque annonce on ne peut afficher qu'une seule image, et que chaque image ne peut être liée qu'à une seule annonce, alors on est bien dans le cadre d'une relation One-To-One.
					
					Tout d'abord, histoire qu'on parle bien de la même chose, créez cette entité Image avec au moins les attributs url et alt pour qu'on puisse l'afficher correctement. 
					Voici la mienne :
					
						<?php
						// src/OC/PlatformBundle/Entity/Image

						namespace OC\PlatformBundle\Entity;

						use Doctrine\ORM\Mapping as ORM;

						/**
						 * @ORM\Table(name="oc_image")
						 * @ORM\Entity(repositoryClass="OC\PlatformBundle\Entity\ImageRepository")
						 */
						class Image
						{
						  /**
						   * @ORM\Column(name="id", type="integer")
						   * @ORM\Id
						   * @ORM\GeneratedValue(strategy="AUTO")
						   */
						  private $id;

						  /**
						   * @ORM\Column(name="url", type="string", length=255)
						   */
						  private $url;

						  /**
						   * @ORM\Column(name="alt", type="string", length=255)
						   */
						  private $alt;
						}
						
					Exécuter la commandephp bin/console doctrine:generate:entities OCPlatformBundle:Image pour générer les getters et setters sur cette nouvelle entité.
				
				
				
				Définition de la relation dans les entités
					
					Annotation
					
						Entité propriétaire,Advert :
							
							<?php
							// src/OC/PlatformBundle/Entity/Advert.php

							/**
							 * @ORM\Entity
							 */
							class Advert
							{
							  /**
							   * @ORM\OneToOne(targetEntity="OC\PlatformBundle\Entity\Image", cascade={"persist"})
							   */
							  private $image;

							  // …
							}
							
							
						Entité inverse,Image:
							
							<?php
							// src/OC/PlatformBundle/Entity/Image

							/**
							 * @ORM\Entity
							 */
							class Image
							{
							  // Nul besoin d'ajouter une propriété ici

							  // …
							}
						
						Dans une relation unidirectionnelle, l'entité inverse, iciImage, ne sait en fait même pas qu'elle est liée à une autre entité, ce n'est pas son rôle.

						Enfin, concernant l'annotation en elle-même :

						@ORM\OneToOne(targetEntity="OC\PlatformBundle\Entity\Image", cascade={"persist"})
						
						Il y a plusieurs choses à savoir sur cette annotation :

						Elle est incompatible avec l'annotation @ORM\Column qu'on a vue dans un chapitre précédent. 
						En effet, l'annotation Column définit une valeur (un nombre, une chaîne de caractères, etc.), alors que OneToOne définit une relation vers une autre entité. 
						Lorsque vous utilisez l'un, vous ne pouvez pas utiliser l'autre sur le même attribut.
						Elle possède au moins l'option targetEntity, qui vaut simplement le namespace complet vers l'entité liée.
						Elle possède d'autres options facultatives, dont l'option cascaded ont on parlera un peu plus loin.
						
						>>> N'oubliez pas de mettre à jour la base de données avec la commande doctrine:schema:update !


							
				Rendre une relation non-facultative
				
					Par défaut, une relation est facultative, c'est-à-dire que vous pouvez avoir un Advert qui n'a pas d'Image liée. C'est le comportement que nous voulons pour l'exemple : on se donne le droit d'ajouter une annonce sans forcément trouver une image d'illustration. Si vous souhaitez forcer la relation, il faut ajouter l'annotation JoinColumn et définir son option nullable à false, comme ceci :

					/**
					  * @ORM\OneToOne(targetEntity="OC\PlatformBundle\Entity\Image", cascade={"persist"})
					  * @ORM\JoinColumn(nullable=false)
					  */
					private $image;
					
					
					
					Les opérations de cascade
						
						On peut cascader des opérations de suppression, mais également de persistance. En effet, on a vu qu'il fallait persister une entité avant d'exécuter le flush(), afin de dire à Doctrine qu'il doit enregistrer l'entité en base de données. 
						Cependant, dans le cas d'entités liées, si on fait un $em->persist($advert), qu'est-ce que Doctrine doit faire pour l'entité Image contenue dans l'entité Advert ? 
						Il ne le sait pas et c'est pourquoi il faut le lui dire : soit en faisant manuellement un persist()sur l'annonce et l'image, soit en définissant dans l'annotation de la relation qu'un persist() sur Advert doit se « propager » sur l'Image liée.

						C'est ce que nous avons fait dans l'annotation : on a défini lecascadesur l'opération persist(), mais pas sur l'opération remove()(car on se réserve la possibilité d'utiliser les images pour autre chose que des annonces).
						
						
						
					Getter et setter
						
						D'abord, n'oubliez pas de définir un getter et un setter dans l'entité propriétaire, ici Advert.
						 
						Vous pouvez utiliser la commande php bin/console doctrine:generate:entities OCPlatformBundle:Advert (mieux), ou alors recopier ce code :
						
							<?php
							// src/OC/PlatformBundle/Entity/Advert.php

							namespace OC\PlatformBundle\Entity;

							use Doctrine\ORM\Mapping as ORM;

							/**
							 * @ORM\Entity(repositoryClass="OC\PlatformBundle\Entity\AdvertRepository")
							 */
							class Advert
							{
							  /**
							   * @ORM\OneToOne(targetEntity="OC\PlatformBundle\Entity\Image", cascade={"persist"})
							   */
							  private $image;

							  // Vos autres attributs…
								
							  public function setImage(Image $image = null)
							  {
								$this->image = $image;
							  }

							  public function getImage()
							  {
								return $this->image;
							  }

							  // Vos autres getters/setters…
							}

						Vous voyez qu'on a forcé le type de l'argument pour le setter setImage(): cela permet de déclencher une erreur si vous essayez de passer un autre objet que Imageà la méthode. Très utile pour éviter de chercher des heures l'origine d'un problème parce que vous avez passé un mauvais argument. Notez également le «= null» qui permet d'accepter les valeurs null: rappelez-vous, la relation est facultative !

						Prenez bien conscience d'une chose également : le getter getImage()retourne une instance de la classe Image directement. Lorsque vous avez une annonce, disons $advert, et que vous voulez récupérer l'URL de l'Image associée, il faut donc écrire :

							<?php
							$image = $advert->getImage();
							$url = $image->getUrl();

							// Ou bien sûr en une seule ligne :
							$url = $advert->getImage()->getUrl();
							
						Pour les curieux qui auront été voir ce qui a été modifié en base de données : une colonne image_id a bien été ajouté à la table advert. 
						Cependant, ne confondez surtout par cette colonne image_idavec notre attribut image, et gardez bien ces deux points en tête :
						1/ L'objet Advert ne contient pas d'attributimage_id.
						2/ L'attributimage de l'objet Advert ne contient pas l'id de l'Image liée, il contient une instance de la classe OC\PlatformBundle\Entity\Image qui, elle, contient un attribut id.

						N'allez donc jamais m'écrire $advert->getImageId(), pour récupérer l'id de l'image liée, il faut d'abord récupérer l'Image elle-même puis son id, comme ceci :$advert->getImage()->getId(). 
						Et ne faites surtout pas la confusion : une entité n'est pas une table.


						
				Exemple d'utilisation	
					
					Pour utiliser cette relation, c'est très simple. 
					Voici un exemple pour ajouter une nouvelle annonce Advert et son Image depuis un contrôleur. 
					Modifions l'action addAction(), qui était déjà bien complète :

						<?php
						// src/OC/PlatformBundle/Controller/AdvertController.php

						namespace OC\PlatformBundle\Controller;

						// N'oubliez pas ces use
						use OC\PlatformBundle\Entity\Advert;
						use OC\PlatformBundle\Entity\Image;
						use Symfony\Bundle\FrameworkBundle\Controller\Controller;
						use Symfony\Component\HttpFoundation\Request;

						class AdvertController extends Controller
						{
						  public function addAction(Request $request)
						  {
							// Création de l'entité Advert
							$advert = new Advert();
							$advert->setTitle('Recherche développeur Symfony.');
							$advert->setAuthor('Alexandre');
							$advert->setContent("Nous recherchons un développeur Symfony débutant sur Lyon. Blabla…");

							// Création de l'entité Image
							$image = new Image();
							$image->setUrl('http://sdz-upload.s3.amazonaws.com/prod/upload/job-de-reve.jpg');
							$image->setAlt('Job de rêve');

							// On lie l'image à l'annonce
							$advert->setImage($image);

							// On récupère l'EntityManager
							$em = $this->getDoctrine()->getManager();

							// Étape 1 : On « persiste » l'entité
							$em->persist($advert);

							// Étape 1 bis : si on n'avait pas défini le cascade={"persist"},
							// on devrait persister à la main l'entité $image
							// $em->persist($image);

							// Étape 2 : On déclenche l'enregistrement
							$em->flush();

							// … reste de la méthode
							}
					
					
					Je vous laisse adapter la vue pour afficher l'image, si elle est présente, lors de l'affichage d'une annonce. Voici un exemple de ce que vous pouvez ajouter :

						{# src/OC/PlatformBundle/Resources/view/Advert/view.html.twig #}

						{# On vérifie qu'une image soit bien associée à l'annonce #}
						{% if advert.image is not null %}
						  <img src="{{ advert.image.url }}" alt="{{ advert.image.alt }}">
						{% endif %}
						
					
					Et voici un autre exemple, qui modifierait l'Image d'une annonce déjà existante. Ici je vais prendre une méthode de contrôleur arbitraire, mais vous savez tout ce qu'il faut pour l'implémenter réellement :

						<?php
						// Dans un contrôleur, celui que vous voulez

						public function editImageAction($advertId)
						{
						  $em = $this->getDoctrine()->getManager();

						  // On récupère l'annonce
						  $advert = $em->getRepository('OCPlatformBundle:Advert')->find($advertId);

						  // On modifie l'URL de l'image par exemple
						  $advert->getImage()->setUrl('test.png');

						  // On n'a pas besoin de persister l'annonce ni l'image.
						  // Rappelez-vous, ces entités sont automatiquement persistées car
						  // on les a récupérées depuis Doctrine lui-même
						  
						  // On déclenche la modification
						  $em->flush();

						  return new Response('OK');
						}
						
					Le code parle de lui-même : gérer une relation est vraiment aisé avec Doctrine !


					
			Relation Many-To-One
				
				
				Présentation
					
					Comme précédemment, pour être sûrs qu'on parle bien de la même chose, créez cette entité Application avec au moins les attributs author,content et date. 
					Voici la mienne, j'ai ajouté un constructeur pour définir une date par défaut, comme on l'a déjà fait pour l'entité Advert :

						<?php
						// src/OC/PlatformBundle/Entity/Application.php

						namespace OC\PlatformBundle\Entity;

						use Doctrine\ORM\Mapping as ORM;

						/**
						 * @ORM\Table(name="oc_application")
						 * @ORM\Entity(repositoryClass="OC\PlatformBundle\Entity\ApplicationRepository")
						 */
						class Application
						{
						  /**
						   * @ORM\Column(name="id", type="integer")
						   * @ORM\Id
						   * @ORM\GeneratedValue(strategy="AUTO")
						   */
						  private $id;

						  /**
						   * @ORM\Column(name="author", type="string", length=255)
						   */
						  private $author;

						  /**
						   * @ORM\Column(name="content", type="text")
						   */
						  private $content;

						  /**
						   * @ORM\Column(name="date", type="datetime")
						   */
						  private $date;
						  
						  public function __construct()
						  {
							$this->date = new \Datetime();
						  }

						  public function getId()
						  {
							return $this->id;
						  }

						  public function setAuthor($author)
						  {
							$this->author = $author;

							return $this;
						  }

						  public function getAuthor()
						  {
							return $this->author;
						  }

						  public function setContent($content)
						  {
							$this->content = $content;

							return $this;
						  }

						  public function getContent()
						  {
							return $this->content;
						  }

						  public function setDate(\Datetime $date)
						  {
							$this->date = $date;

							return $this;
						  }

						  public function getDate()
						  {
							return $this->date;
						  }
						}
						
						
						
				Définition de la relation dans les entités
					
					Annotation
						
						Pour établir cette relation dans votre entité, la syntaxe est la suivante :
						
						Entité propriétaire, Application :

							<?php
							// src/OC/PlatformBundle/Entity/Application.php

							/**
							 * @ORM\Entity
							 */
							class Application
							{
							  /**
							   * @ORM\ManyToOne(targetEntity="OC\PlatformBundle\Entity\Advert")
							   * @ORM\JoinColumn(nullable=false)
							   */
							  private $advert;

							  // …
							}
						
						Entité inverse, Advert :

							<?php
							// src/OC/PlatformBundle/Entity/Advert.php

							/**
							 * @ORM\Entity
							 */
							class Advert
							{
							  // Nul besoin de rajouter de propriété, ici

							  // …
							}
						
						L'annotation à utiliser est tout simplement ManyToOne.

						Première remarque : l'entité propriétaire pour cette relation est Application, et non Advert. Pourquoi ? Parce que, rappelez-vous, le propriétaire est celui qui contient la colonne référence. Ici, on aura bien une colonne advert_iddans la table application. En fait, de façon systématique, c'est le côté Many d'une relation Many-To-One qui est le propriétaire, vous n'avez pas le choix. Ici, on a plusieurs candidatures pour une seule annonce, le Many correspond aux candidatures (application en anglais), donc l'entité Application est la propriétaire.

						Deuxième remarque : j'ai volontairement ajouté l'annotation JoinColumnavec son attribut nullable à false, pour interdire la création d'une candidature sans annonce. En effet, dans notre cas, une candidature qui n'est rattachée à aucune annonce n'a pas de sens (on n'autorise pas les candidatures spontanées). Après, attention, il se peut très bien que dans votre cas vous deviez laisser la possibilité au côté Many de la relation d'exister sans forcément être attaché à un côté One.

						>>> N'oubliez pas de mettre à jour la base de données avec la commande doctrine:schema:update !
						
						
				Getter et setter
					
					Ajoutons maintenant le getter et le setter correspondants dans l'entité propriétaire. 
					Comme tout à l'heure, vous pouvez utiliser la méthode php bin/console doctrine:generate:entities OCPlatformBundle:Application, ou alors mettez ceux-là :

						<?php
						// src/OC/PlatformBundle/Entity/Application.php

						namespace OC\PlatformBundle\Entity;

						use Doctrine\ORM\Mapping as ORM;

						/**
						 * @ORM\Entity(repositoryClass="OC\PlatformBundle\Entity\ApplicationRepository")
						 */
						class Application
						{
						  /**
						   * @ORM\ManyToOne(targetEntity="OC\PlatformBundle\Entity\Advert")
						   * @ORM\JoinColumn(nullable=false)
						   */
						  private $advert;

						  // … reste des attributs

						  public function setAdvert(Advert $advert)
						  {
							$this->advert = $advert;

							return $this;
						  }

						  public function getAdvert()
						  {
							return $this->advert;
						  }

						  // … reste des getters et setters
						}
						
						Vous pouvez remarquer que, comme notre relation est obligatoire, il n'y a pas le «= null» dans le setAdvert().
					
					
				Exemple d'utilisation	
					
					La méthode pour gérer une relation Many-To-One n'est pas très différente de celle pour une relation One-To-One, voyez par vous-mêmes dans ces exemples.

					Tout d'abord, pour ajouter un nouvel Advert et ses Application, modifions la méthode addAction() de notre contrôleur :

						<?php
						// src/OC/PlatformBundle/Controller/AdvertController.php

						namespace OC\PlatformBundle\Controller;

						use OC\PlatformBundle\Entity\Advert;
						use OC\PlatformBundle\Entity\Application;
						use Symfony\Bundle\FrameworkBundle\Controller\Controller;
						use Symfony\Component\HttpFoundation\Request;

						class AdvertController extends Controller
						{
						  public function addAction(Request $request)
						  {
							// Création de l'entité Advert
							$advert = new Advert();
							$advert->setTitle('Recherche développeur Symfony.');
							$advert->setAuthor('Alexandre');
							$advert->setContent("Nous recherchons un développeur Symfony débutant sur Lyon. Blabla…");

							// Création d'une première candidature
							$application1 = new Application();
							$application1->setAuthor('Marine');
							$application1->setContent("J'ai toutes les qualités requises.");

							// Création d'une deuxième candidature par exemple
							$application2 = new Application();
							$application2->setAuthor('Pierre');
							$application2->setContent("Je suis très motivé.");

							// On lie les candidatures à l'annonce
							$application1->setAdvert($advert);
							$application2->setAdvert($advert);

							// On récupère l'EntityManager
							$em = $this->getDoctrine()->getManager();

							// Étape 1 : On « persiste » l'entité
							$em->persist($advert);

							// Étape 1 ter : pour cette relation pas de cascade lorsqu'on persiste Advert, car la relation est
							// définie dans l'entité Application et non Advert. On doit donc tout persister à la main ici.
							$em->persist($application1);
							$em->persist($application2);

							// Étape 2 : On « flush » tout ce qui a été persisté avant
							$em->flush();

							// … reste de la méthode
						  }
						}
						
					Pour information, voici comment on pourrait modifier l'action viewAction() du contrôleur pour passer non seulement l'annonce à la vue, mais également toutes ses candidatures :

						<?php
						// src/OC/PlatformBundle/Controller/AdvertController.php

						  public function viewAction($id)
						  {
							$em = $this->getDoctrine()->getManager();

							// On récupère l'annonce $id
							$advert = $em->getRepository('OCPlatformBundle:Advert')->find($id);

							if (null === $advert) {
							  throw new NotFoundHttpException("L'annonce d'id ".$id." n'existe pas.");
							}

							// On récupère la liste des candidatures de cette annonce
							$listApplications = $em
							  ->getRepository('OCPlatformBundle:Application')
							  ->findBy(array('advert' => $advert))
							;

							return $this->render('OCPlatformBundle:Advert:view.html.twig', array(
							  'advert'           => $advert,
							  'listApplications' => $listApplications
							));
						  }
					  
					Ici vous constatez qu'on a utilisé la méthode findBy(), qui récupère toutes les candidatures selon un tableau de critères. En l'occurrence, le tableau de critères signifie qu'il ne faut récupérer que les candidatures qui sont liées à l'annonce donnée, on en reparlera bien sûr dans le prochain chapitre.

					Et bien entendu, il faudrait adapter la vue si vous voulez afficher la liste des candidatures que nous venons de lui passer. Je vous laisse le faire à titre d'entraînement.
					
					
				
			Relation Many-To-Many
				
				Présentation
				
					La relation Many-To-Many, ou n..n, correspond à une relation qui permet à plein d'objets d'être en relation avec plein d'autres !

					Prenons l'exemple cette fois-ci des annonces de notre plateforme, réparties dans des catégories. 
					Une annonce peut appartenir à plusieurs catégories. 
					À l'inverse, une catégorie peut contenir plusieurs annonces. 
					On a donc une relation Many-To-Many entre Advert et Category.
				
					Cette relation est particulière dans le sens où Doctrine va devoir créer une table intermédiaire. 
					En effet, avec la méthode traditionnelle en base de données, comment définiriez-vous ce genre de relation ? 
					Vous avez une table advert, une autre table category, mais vous avez surtout besoin d'une table advert_category qui fait la liaison entre les deux ! 
					Cette table de liaison ne contient que deux colonnes :advert_id et category_id. Cette table intermédiaire, vous ne la connaîtrez pas : elle n’apparaît pas dans nos entités, et c'est Doctrine qui la crée et qui la gère tout seul !
					
					Encore une fois, pour être sûrs que l'on parle bien de la même chose, créez cette entité Category avec au moins un attribut name. Voici la mienne :

						<?php
						// src/OC/PlatformBundle/Entity/Category.php

						namespace OC\PlatformBundle\Entity;

						use Doctrine\ORM\Mapping as ORM;

						/**
						 * @ORM\Entity
						 */
						class Category
						{
						  /**
						   * @ORM\Column(name="id", type="integer")
						   * @ORM\Id
						   * @ORM\GeneratedValue(strategy="AUTO")
						   */
						  private $id;

						  /**
						   * @ORM\Column(name="name", type="string", length=255)
						   */
						  private $name;

						  public function getId()
						  {
							return $this->id;
						  }

						  public function setName($name)
						  {
							$this->name = $name;
						  }

						  public function getName()
						  {
							return $this->name;
						  }
						}
						
						
				Définition de la relation dans les entités

					Annotation
					
						Pour établir cette relation dans vos entités, la syntaxe est la suivante.
					
					
					Entité propriétaire, Advert :
					
						<?php
						// src/OC/PlatformBundle/Entity/Advert.php

						/**
						 * @ORM\Entity
						 */
						class Advert
						{
						  /**
						   * @ORM\ManyToMany(targetEntity="OC\PlatformBundle\Entity\Category", cascade={"persist"})
						   */
						  private $categories;

						  // …
						}
						
						
					Entité inverse,Category :
					
						<?php
						// src/OC/PlatformBundle/Entity/Category.php

						/**
						 * @ORM\Entity
						 */
						class Category
						{
						  // Nul besoin d'ajouter une propriété ici

						  // …
						}
						
						
					J'ai mis Advert comme propriétaire de la relation. 
					C'est un choix que vous pouvez faire comme bon vous semble ici. 
					Mais récupérer les catégories d'une annonce se fera assez souvent, alors que récupérer les annonces d'une catégorie moins. 
					Et puis, pour récupérer les annonces d'une catégorie, on aura surement besoin de personnaliser la requête, donc on le fera de toute façon depuis le CategoryRepository, on en reparlera.
					
				
				Getter et setters
				
					Dans ce type de relation, il faut soigner un peu plus l'entité propriétaire. Tout d'abord, on a pour la première fois un attribut (ici $categories) qui contient une liste d'objets, et non pas un seul objet. C'est parce qu'il contient une liste d'objets qu'on a mis le nom de cet attribut au pluriel (notez le 's'). Les listes d'objets avec Doctrine2 ne sont pas de simples tableaux, mais des ArrayCollection, il faudra donc définir l'attribut comme tel dans le constructeur. Un ArrayCollection est un objet utilisé par Doctrine2, qui a toutes les propriétés d'un tableau normal. Vous pouvez faire un foreach dessus, et le traiter comme n'importe quel tableau. Il dispose juste de quelques méthodes supplémentaires très pratiques, que nous verrons.

					Ensuite, le getter est classique et s'appelle getCategories(). Par contre, c'est les setters qui vont différer un peu. En effet, $categories est une liste de catégories, mais au quotidien ce qu'on va faire c'est ajouter une à une des catégories à cette liste. Il nous faut donc une méthode addCategory() (sans « s », on n'ajoute qu'une seule catégorie à la fois) et non setCategories(). Du coup, il nous faut également une méthode pour supprimer une catégorie de la liste, que l'on appelle removeCategory().

					Ajoutons maintenant le getter et les setters correspondants dans l'entité propriétaire, Advert. Comme tout à l'heure, vous pouvez utiliser la méthode php bin/console doctrine:generate:entities OCPlatformBundle:Advert, ou alors reprendre ce code :

						<?php
						// src/OC/PlatformBundle/Entity/Advert.php

						namespace OC\PlatformBundle\Entity;

						// N'oubliez pas ce use
						use Doctrine\Common\Collections\ArrayCollection;
						use Doctrine\ORM\Mapping as ORM;

						/**
						 * @ORM\Entity(repositoryClass="OC\PlatformBundle\Entity\AdvertRepository")
						 */
						class Advert
						{
						  /**
						   * @ORM\ManyToMany(targetEntity="OC\PlatformBundle\Entity\Category", cascade={"persist"})
						   */
						  private $categories;

						  // … vos autres attributs

						  // Comme la propriété $categories doit être un ArrayCollection,
						  // On doit la définir dans un constructeur :
						  public function __construct()
						  {
							$this->date       = new \Datetime();
							$this->categories = new ArrayCollection();
						  }

						  // Notez le singulier, on ajoute une seule catégorie à la fois
						  public function addCategory(Category $category)
						  {
							// Ici, on utilise l'ArrayCollection vraiment comme un tableau
							$this->categories[] = $category;
						  }

						  public function removeCategory(Category $category)
						  {
							// Ici on utilise une méthode de l'ArrayCollection, pour supprimer la catégorie en argument
							$this->categories->removeElement($category);
						  }

						  // Notez le pluriel, on récupère une liste de catégories ici !
						  public function getCategories()
						  {
							return $this->categories;
						  }


						  // … vos autres getters/setters
						}
						
					N'oubliez pas de mettre à jour la base de données avec la commande doctrine:schema:update.
					Si vous êtes allés vérifier dans PhpMyAdmin, vous aurez noté que la table créée s'appelle advert_category, or depuis le début nous préfixons nos noms de table avec "oc". Comment le faire également pour la table de jointure ? Il faut pour cela rajouter l'annotation JoinTable, qui permet de personnaliser un peu cette table, voici comment changer son nom par exemple :

					<?php

					/**
					 * @ORM\ManyToMany(targetEntity="OC\PlatformBundle\Entity\Category", cascade={"persist"})
					 * @ORM\JoinTable(name="oc_advert_category")
					 */
					private $categories;
					
				
				Remplissons la base de données avec les fixtures
					
					
					Avant de voir un exemple, j'aimerais vous faire ajouter quelques catégories en base de données, histoire d'avoir de quoi jouer avec. Pour cela, petit aparté, nous allons faire une fixture Doctrine ! Cela va nous permettre d'utiliser le bundle qu'on a installé lors du chapitre sur Composer.

					Les fixtures Doctrine permettent de remplir la base de données avec un jeu de données que nous allons définir. Cela permet de pouvoir tester avec des vraies données, sans devoir les retaper à chaque fois : on les inscrit une fois pour toutes, et ensuite elles sont toutes insérées en base de données en une seule commande.

					Tout d'abord, créons notre fichier de fixture pour l'entité Category. Les fixtures d'un bundle se trouvent dans le répertoire DataFixtures/ORM (ou ODM pour des documents). Voici à quoi ressemble notre fixture LoadCategory :

						<?php
						// src/OC/PlatformBundle/DataFixtures/ORM/LoadCategory.php

						namespace OC\PlatformBundle\DataFixtures\ORM;

						use Doctrine\Common\DataFixtures\FixtureInterface;
						use Doctrine\Common\Persistence\ObjectManager;
						use OC\PlatformBundle\Entity\Category;

						class LoadCategory implements FixtureInterface
						{
						  // Dans l'argument de la méthode load, l'objet $manager est l'EntityManager
						  public function load(ObjectManager $manager)
						  {
							// Liste des noms de catégorie à ajouter
							$names = array(
							  'Développement web',
							  'Développement mobile',
							  'Graphisme',
							  'Intégration',
							  'Réseau'
							);

							foreach ($names as $name) {
							  // On crée la catégorie
							  $category = new Category();
							  $category->setName($name);

							  // On la persiste
							  $manager->persist($category);
							}

							// On déclenche l'enregistrement de toutes les catégories
							$manager->flush();
						  }
						}
					
					C'est tout ! On peut dès à présent insérer ces données dans la base de données. Voici donc la commande à exécuter :

					C:\wamp\www\Symfony>php bin/console doctrine:fixtures:load
					
					Careful, database will be purged. Do you want to continue Y/N ?y
					  > purging database
					  > loading OC\PlatformBundle\DataFixtures\ORM\LoadCategory
					  
					Et voilà ! Les cinq catégories définies dans le fichier de fixture sont maintenant enregistrées en base de données, on va pouvoir s'en servir dans nos exemples. 
					Par la suite, on rajoutera d'autres fichiers de fixture pour insérer d'autres entités en base de données : la commande les traitera tous l'un après l'autre.

					Attention, comme vous avez pu le voir, l'exécution de la commande Doctrine pour insérer les fixtures vide totalement la base de données avant d'insérer les nouvelles données.
					
					>>> Si vous voulez ajouter les fixtures en plus des données déjà présentes, il faut ajouter l'option --append à la commande précédente.
					
					Cependant, c'est rarement ce que vous voulez, car à la prochaine exécution des fixtures, vous allez insérer une nouvelle fois les mêmes catégories…
					Du coup, en vidant votre base de données Doctrine vient de supprimer vos annonces. 
					Vous devriez en recréer en allant sur la page /platform/add ;)
					
				
				Exemples d'utilisation
					
					Voici un exemple pour ajouter une annonce existante à plusieurs catégories existantes. 
					Je vous propose de mettre ce code dans notre méthode editAction() par exemple :

					<?php
					// src/OC/PlatformBundle/Controller/AdvertController.php

					namespace OC\PlatformBundle\Controller;

					use Symfony\Bundle\FrameworkBundle\Controller\Controller;
					use Symfony\Component\HttpFoundation\Request;
					use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;

					class AdvertController extends Controller
					{
					  // …

					  public function editAction($id, Request $request)
					  {
						$em = $this->getDoctrine()->getManager();

						// On récupère l'annonce $id
						$advert = $em->getRepository('OCPlatformBundle:Advert')->find($id);

						if (null === $advert) {
						  throw new NotFoundHttpException("L'annonce d'id ".$id." n'existe pas.");
						}

						// La méthode findAll retourne toutes les catégories de la base de données
						$listCategories = $em->getRepository('OCPlatformBundle:Category')->findAll();

						// On boucle sur les catégories pour les lier à l'annonce
						foreach ($listCategories as $category) {
						  $advert->addCategory($category);
						}

						// Pour persister le changement dans la relation, il faut persister l'entité propriétaire
						// Ici, Advert est le propriétaire, donc inutile de la persister car on l'a récupérée depuis Doctrine

						// Étape 2 : On déclenche l'enregistrement
						$em->flush();

						// … reste de la méthode
					  }
					}


					Je vous ai mis un exemple concret d'application pour que vous puissiez vous représenter l'utilisation de la relation dans un vrai cas d'utilisation. 
					Les seules lignes qui concernent vraiment l'utilisation de notre relation Many-To-Many sont les lignes 29 à 31 : la boucle sur les catégories pour ajouter chaque catégorie une à une à l'annonce en question.


					Voici un autre exemple pour enlever toutes les catégories d'une annonce. Modifions la méthode deleteAction() pour l'occasion :

						<?php
						// src/OC/PlatformBundle/Controller/AdvertController.php

						namespace OC\PlatformBundle\Controller;

						use Symfony\Bundle\FrameworkBundle\Controller\Controller;
						use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;

						class AdvertController extends Controller
						{
						  // …

						  public function deleteAction($id)
						  {
							$em = $this->getDoctrine()->getManager();

							// On récupère l'annonce $id
							$advert = $em->getRepository('OCPlatformBundle:Advert')->find($id);

							if (null === $advert) {
							  throw new NotFoundHttpException("L'annonce d'id ".$id." n'existe pas.");
							}

							// On boucle sur les catégories de l'annonce pour les supprimer
							foreach ($advert->getCategories() as $category) {
							  $advert->removeCategory($category);
							}

							// Pour persister le changement dans la relation, il faut persister l'entité propriétaire
							// Ici, Advert est le propriétaire, donc inutile de la persister car on l'a récupérée depuis Doctrine

							// On déclenche la modification
							$em->flush();
							
							// ...
						  }
						}
						
					Notez comment on a récupéré toutes les catégories de notre annonce, un simple $advert->getCategories(), c'est ce que je vous avais promis au début de cette partie sur Doctrine !

					Sauf si vous l'avez fait de votre côté, nous n'avons pas encore créé la vue pour cette action delete. Ce n'est pas grave, même si Symfony vous affiche une erreur comme quoi la vue n'existe pas, les requêtes Doctrine, elles, se sont déjà exécutées à ce moment. Vous pouvez les voir dans le profiler comme d'habitude, et ce même si la page contient une erreur. Bon à savoir !
						
					Enfin, voici un dernier exemple pour afficher les catégories d'une annonce dans la vue :

						{# src/OC/PlatformBundle/Resources/view/Advert/view.html.twig #}

						{% if not advert.categories.empty %}
						  <p>
							Cette annonce est parue dans les catégories suivantes :
							{% for category in advert.categories %}
							  {{ category.name }}{% if not loop.last %}, {% endif %}
							{% endfor %}
						  </p>
						{% endif %}
						
						
					Notez principalement :

						L'utilisation duempty de l'ArrayCollection, pour savoir si la liste des catégories est vide ou non ;
						Le {{ advert.categories }} pour récupérer les catégories de l'annonce. 
						C'est exactement la même chose que notre $advert->getCategories() côté PHP ;
						L'utilisation de la variable {{ loop.last }} dans la boucle for pour ne pas mettre de virgule après la dernière catégorie‌ affichée.
						
					
					Remarquez également les quatre requêtes générées par Doctrine, présentes sur la figure suivante :

						Récupération de l'annonce
						Récupération de toutes les candidatures liées à cette annonce (nous faisons cette requête dans le contrôleur)
						Récupération de l'image liée à l'annonce (nous déclenchons cette requête depuis la vue !)
						Récupération de toutes les catégories liées à cette annonce (déclenchée depuis la vue également)
					
					
				
				
			Relation Many-To-Many avec attributs
				
				
				Une commande contient plusieurs produits, et bien entendu un même produit peut être dans différentes commandes. On a donc bien une relation Many-To-Many. Voyez-vous le manque ? Lorsqu'un utilisateur ajoute un produit à une commande, où met-on la quantité de ce produit ? Si je veux 3 exemplaires de Harry Potter, où mettre cette quantité ? Dans l'entité Commande? Non cela n'a pas de sens. Dans l'entité Produit? Non, cela n'a pas de sens non plus. Cette quantité est un attribut de la relation qui existe entre Produit et Commande, et non un attribut de Produit ni de Commande.

				Il n'y a pas de moyen simple de gérer les attributs d'une relation avec Doctrine. Pour cela, il faut esquiver en créant simplement une entité intermédiaire qui va représenter la relation, appelons-la CommandeProduit. Et c'est dans cette entité que l'on mettra les attributs de relation, comme notre quantité. Ensuite, il faut bien entendu mettre en relation cette entité intermédiaire avec les deux autres entités d'origine, Commande et Produit. Pour cela, il faut logiquement faire : Commande One-To-Many CommandeProduit Many-To-One Produit. En effet, une commande (One) peut avoir plusieurs relations avec des produits (Many), plusieurs CommandeProduit, donc ! La relation est symétrique pour les produits.

				Attention, dans le titre de cette section, j'ai parlé de la relation Many-To-Many avec attributs, mais il s'agit bien en fait de deux relations Many-To-One des plus normales, soyons d'accord. On ne va donc rien apprendre dans cette section, car on sait déjà faire une Many-To-One. Il s'agit juste de vous présenter une astuce qu'il faut bien connaître et savoir utiliser, donc prenons le temps de bien la comprendre.

				J'ai pris l'exemple de produits et de commandes, car c'est plus intuitif pour comprendre l'enjeu et l'utilité de cette relation. Cependant, pour rester dans le cadre de notre plateforme d'annonces, on va faire une relation entre des annonces et des compétences, soit entre les entités Advert et Skill, et l'attribut de la relation sera le niveau requis. L'idée est de pouvoir afficher sur chaque annonce la liste des compétences requises pour la mission (Symfony, C++, Photoshop, etc.) avec le niveau dans chaque compétence (Débutant, Avisé et Expert).
				
				
				Et donc : Advert One-To-Many  AdvertSkill Many-To-One  Skill.

				Pour cela, créez d'abord cette entité Skill, avec au moins un attribut name. Voici la mienne :

					<?php
					// src/OC/PlatformBundle/Entity/Skill.php

					namespace OC\PlatformBundle\Entity;

					use Doctrine\ORM\Mapping as ORM;

					/**
					 * @ORM\Entity
					 * @ORM\Table(name="oc_skill")
					 */
					class Skill
					{
					  /**
					   * @ORM\Column(name="id", type="integer")
					   * @ORM\Id
					   * @ORM\GeneratedValue(strategy="AUTO")
					   */
					  private $id;

					  /**
					   * @ORM\Column(name="name", type="string", length=255)
					   */
					  private $name;

					  public function getId()
					  {
						return $this->id;
					  }

					  public function setName($name)
					  {
						$this->name = $name;
					  }

					  public function getName()
					  {
						return $this->name;
					  }
					}

				
				Définition de la relation dans les entités
					
					
					Annotation
					
						Tout d'abord, on va créer notre entité de relation (notre AdvertSkill) comme ceci :
						
							<?php
							// src/OC/PlatformBundle/Entity/AdvertSkill.php

							namespace OC\PlatformBundle\Entity;

							use Doctrine\ORM\Mapping as ORM;

							/**
							 * @ORM\Entity
							 * @ORM\Table(name="oc_advert_skill")
							 */
							class AdvertSkill
							{
							  /**
							   * @ORM\Column(name="id", type="integer")
							   * @ORM\Id
							   * @ORM\GeneratedValue(strategy="AUTO")
							   */
							  private $id;

							  /**
							   * @ORM\Column(name="level", type="string", length=255)
							   */
							  private $level;

							  /**
							   * @ORM\ManyToOne(targetEntity="OC\PlatformBundle\Entity\Advert")
							   * @ORM\JoinColumn(nullable=false)
							   */
							  private $advert;

							  /**
							   * @ORM\ManyToOne(targetEntity="OC\PlatformBundle\Entity\Skill")
							   * @ORM\JoinColumn(nullable=false)
							   */
							  private $skill;
							  
							  // ... vous pouvez ajouter d'autres attributs bien sûr
							}
						
					
						Comme les côtés Many des deux relations Many-To-One sont dans AdvertSkill, cette entité est l'entité propriétaire des deux relations.

						Mais, avec une relation unidirectionnelle, on ne pourra pas faire $advert->getAdvertSkills() pour récupérer les AdvertSkill et donc les compétences ? 
						Ni l'inverse depuis $skill ?
						En effet, et c'est pourquoi la prochaine section de ce chapitre traite des relations bidirectionnelles ! 
						En attendant, pour notre relation One-To-Many-To-One, continuons simplement sur une relation unidirectionnelle.

						Sachez quand même que vous pouvez tout de même récupérer les AdvertSkills d'une annonce sans forcément passer par une relation bidirectionnelle. Il suffit d'utiliser la méthode findBy du repository, comme on l'a déjà fait auparavant :
				
							<?php
							// $advert est une instance de Advert

							// $advert->getAdvertSkills() n'est pas possible

							$listAdvertSkills = $em
							  ->getRepository('OCPlatformBundle:AdvertSkill')
							  ->findBy(array('advert' => $advert))
							;
							
						L'intérêt de la bidirectionnelle ici est lorsque vous voulez afficher une liste des annonces avec leurs compétences. Dans la boucle sur les annonces, vous n'allez pas faire appel à une méthode du repository qui va générer une requête par itération dans la boucle, ça ferait beaucoup de requêtes ! Une relation bidirectionnelle permet de régler ce problème d'optimisation, nous le verrons plus loin dans ce chapitre et dans le prochain.

						>>> N'oubliez pas de mettre à jour votre base de données en exécutant la commande doctrine:schema:update.
						
						
					Getters et setters	
						
						
						Comme d'habitude les getters et setters doivent se définir dans l'entité propriétaire. Ici, rappelez-vous, nous sommes en présence de deux relations Many-To-One dont la propriétaire est l'entité AdvertSkill. Nous avons donc deux getters et deux setters classiques à écrire. Vous pouvez les générer avec la commande doctrine:generate:entities OCPlatformBundle:AdvertSkill, ou utiliser le code suivant :

							<?php
							// src/OC/PlatformBundle/Entity/AdvertSkill.php

							namespace OC\PlatformBundle\Entity;

							use Doctrine\ORM\Mapping as ORM;

							/**
							 * @ORM\Entity
							 * @ORM\Table(name="oc_advert_skill")
							 */
							class AdvertSkill
							{
							  /**
							   * @ORM\Column(name="id", type="integer")
							   * @ORM\Id
							   * @ORM\GeneratedValue(strategy="AUTO")
							   */
							  private $id;

							  /**
							   * @ORM\Column(name="level", type="string", length=255)
							   */
							  private $level;

							  /**
							   * @ORM\ManyToOne(targetEntity="OC\PlatformBundle\Entity\Advert")
							   * @ORM\JoinColumn(nullable=false)
							   */
							  private $advert;

							  /**
							   * @ORM\ManyToOne(targetEntity="OC\PlatformBundle\Entity\Skill")
							   * @ORM\JoinColumn(nullable=false)
							   */
							  private $skill;

							  public function getId()
							  {
								return $this->id;
							  }

							  public function setLevel($level)
							  {
								$this->level = $level;
							  }

							  public function getLevel()
							  {
								return $this->level;
							  }

							  public function setAdvert(Advert $advert)
							  {
								$this->advert = $advert;
							  }

							  public function getAdvert()
							  {
								return $this->advert;
							  }

							  public function setSkill(Skill $skill)
							  {
								$this->skill = $skill;
							  }

							  public function getSkill()
							  {
								return $this->skill;
							  }
							}
				
				
				
				Remplissons la base de données		
					
					
					Comme précédemment, on va d'abord ajouter des compétences en base de données grâce aux fixtures. 
					Pour faire une nouvelle fixture, il suffit de créer un nouveau fichier dans le répertoire DataFixtures/ORM dans le bundle. 
					Je vous invite à créer le fichier LoadSkill.php:

						<?php
						// src/OC/PlatformBundle/DataFixtures/ORM/LoadSkill.php

						namespace OC\PlatformBundle\DataFixtures\ORM;

						use Doctrine\Common\DataFixtures\FixtureInterface;
						use Doctrine\Common\Persistence\ObjectManager;
						use OC\PlatformBundle\Entity\Skill;

						class LoadSkill implements FixtureInterface
						{
						  public function load(ObjectManager $manager)
						  {
							// Liste des noms de compétences à ajouter
							$names = array('PHP', 'Symfony', 'C++', 'Java', 'Photoshop', 'Blender', 'Bloc-note');

							foreach ($names as $name) {
							  // On crée la compétence
							  $skill = new Skill();
							  $skill->setName($name);

							  // On la persiste
							  $manager->persist($skill);
							}

							// On déclenche l'enregistrement de toutes les catégories
							$manager->flush();
						  }
						}
						
					Et maintenant, on peut exécuter la commande :

						C:\wamp\www\Symfony>php bin/console doctrine:fixtures:load
						Careful, database will be purged. Do you want to continue Y/N ?y
						 > purging database
						 > loading OC\PlatformBundle\DataFixtures\ORM\LoadCategory
						 > loading OC\PlatformBundle\DataFixtures\ORM\LoadSkill
						 
					Vous pouvez voir qu'après avoir tout vidé Doctrine a inséré les fixtures LoadCategory puis nos fixtures LoadSkill. Tout est prêt !
					
				
				Exemple d'utilisation
					
					
					La manipulation des entités dans une telle relation est un peu plus compliquée, surtout sans la bidirectionnalité. 
					Mais on peut tout de même s'en sortir. 
					Tout d'abord, voici un exemple pour créer une nouvelle annonce contenant plusieurs compétences ; mettons ce code dans la méthode addAction():

						<?php
						// src/OC/PlatformBundle/Controller/AdvertController.php

						namespace OC\PlatformBundle\Controller;

						use OC\PlatformBundle\Entity\AdvertSkill;
						use Symfony\Bundle\FrameworkBundle\Controller\Controller;
						use Symfony\Component\HttpFoundation\Request;
						use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;

						class AdvertController extends Controller
						{
						  // …

						  public function addAction(Request $request)
						  {
							// On récupère l'EntityManager
							$em = $this->getDoctrine()->getManager();

							// Création de l'entité Advert
							$advert = new Advert();
							$advert->setTitle('Recherche développeur Symfony.');
							$advert->setAuthor('Alexandre');
							$advert->setContent("Nous recherchons un développeur Symfony débutant sur Lyon. Blabla…");

							// On récupère toutes les compétences possibles
							$listSkills = $em->getRepository('OCPlatformBundle:Skill')->findAll();

							// Pour chaque compétence
							foreach ($listSkills as $skill) {
							  // On crée une nouvelle « relation entre 1 annonce et 1 compétence »
							  $advertSkill = new AdvertSkill();

							  // On la lie à l'annonce, qui est ici toujours la même
							  $advertSkill->setAdvert($advert);
							  // On la lie à la compétence, qui change ici dans la boucle foreach
							  $advertSkill->setSkill($skill);

							  // Arbitrairement, on dit que chaque compétence est requise au niveau 'Expert'
							  $advertSkill->setLevel('Expert');

							  // Et bien sûr, on persiste cette entité de relation, propriétaire des deux autres relations
							  $em->persist($advertSkill);
							}

							// Doctrine ne connait pas encore l'entité $advert. Si vous n'avez pas défini la relation AdvertSkill
							// avec un cascade persist (ce qui est le cas si vous avez utilisé mon code), alors on doit persister $advert
							$em->persist($advert);

							// On déclenche l'enregistrement
							$em->flush();

							// … reste de la méthode
						  }
						}
						
					L'idée est donc la suivante : lorsque vous voulez lier une annonce à une compétence, il faut d'abord créer cette entité de liaison qu'est AdvertSkill. Vous la liez à l'annonce, à la compétence, et vous définissez tous vos attributs de relations (ici on n'a que level). Ensuite il faut persister le tout, et le tour est joué !

					Et voici un autre exemple pour récupérer les compétences et leur niveau à partir d'une annonce, la version sans la relation bidirectionnelle donc. Je vous propose de modifier la méthode viewAction() pour cela :

						<?php
						// src/OC/PlatformBundle/Controller/AdvertController.php

						namespace OC\PlatformBundle\Controller;

						use Symfony\Bundle\FrameworkBundle\Controller\Controller;
						use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;

						class AdvertController extends Controller
						{
						  // …

						  public function viewAction($id)
						  {
							$em = $this->getDoctrine()->getManager();

							// On récupère l'annonce $id
							$advert = $em
							  ->getRepository('OCPlatformBundle:Advert')
							  ->find($id)
							;

							if (null === $advert) {
							  throw new NotFoundHttpException("L'annonce d'id ".$id." n'existe pas.");
							}

							// On avait déjà récupéré la liste des candidatures
							$listApplications = $em
							  ->getRepository('OCPlatformBundle:Application')
							  ->findBy(array('advert' => $advert))
							;

							// On récupère maintenant la liste des AdvertSkill
							$listAdvertSkills = $em
							  ->getRepository('OCPlatformBundle:AdvertSkill')
							  ->findBy(array('advert' => $advert))
							;

							return $this->render('OCPlatformBundle:Advert:view.html.twig', array(
							  'advert'           => $advert,
							  'listApplications' => $listApplications,
							  'listAdvertSkills' => $listAdvertSkills
							));
						  }
						}
						
					Et un exemple de ce que vous pouvez utiliser dans la vue pour afficher les compétences et leur niveau :

						{# src/OC/PlatformBundle/Resources/view/Advert/view.html.twig #}

						{% if listAdvertSkills|length > 0 %}
						  <div>
							Cette annonce requiert les compétences suivantes :
							<ul>
							  {% for advertSkill in listAdvertSkills %}
								<li>{{ advertSkill.skill.name }} : niveau {{ advertSkill.level }}</li>
							  {% endfor %}
							</ul>
						  </div>
						{% endif %}
						
					Faites bien la différence entre :

					{{ advertSkill }} qui contient les attributs de la relation, ici le niveau requis via {{ advertSkill.level }} ;
					Et  {{ advertSkill.skill }} qui est la compétence en elle-même (notre entitéSkill), qu'il vous faut utiliser pour afficher le nom de la compétence via{{ advertSkill.skill.name }}.
					Attention, dans cet exemple, la méthodefindBy()utilisée dans le contrôleur ne sélectionne que lesAdvertSkill. Donc, lorsque dans la boucle dans la vue on fait{{ advertSkill.skill }}, en réalité Doctrine va effectuer une requête pour récupérer la compétenceSkill associée à cetteAdvertSkill. C'est bien sûr une horreur, car il va faire une requête… par itération dans lefor! Si vous avez 20 compétences attachées à l'annonce, cela ferait 20 requêtes : inimaginable.
					
					Pour charger lesSkill en même temps que lesAdvertSkill dans le contrôleur, et ainsi ne plus faire de requête dans la boucle, il faut faire une méthode à nous dans le repository deAdvertSkill. On voit tout cela dans le chapitre suivant dédié aux repositories. 
					>>> N'utilisez donc jamais cette technique, attendez le prochain chapitre ! La seule différence dans le contrôleur sera d'utiliser une autre méthode quefindBy(), et la vue ne changera même pas ;) .
					
					
					
				
			Les relations bidirectionnelles
				
				
				Présentation
					
					Vous avez vu que jusqu'ici nous n'avons jamais modifié l'entité inverse d'une relation, mais seulement l'entité propriétaire. Toutes les relations que l'on vient de faire sont donc des relations unidirectionnelles.
					
					Leur avantage est de définir la relation d'une façon très simple. Mais l'inconvénient est de ne pas pouvoir récupérer l'entité propriétaire depuis l'entité inverse, le fameux $entiteInverse->getEntiteProprietaire()(pour nous, $advert->getApplications() par exemple).
					
					Liens
						- http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/association-mapping.html
						- http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/working-with-associations.html
					
					
				Définition de la relation dans les entités
					
					Pour étudier la définition d'une relation bidirectionnelle, nous allons étudier une relation Many-To-One. Souvenez-vous bien de cette relation, dans sa version unidirectionnelle, pour pouvoir attaquer sa version bidirectionnelle dans les meilleures conditions.

					Nous allons ici construire une relation bidirectionnelle de type Many-To-One, basée sur notre exemple Advert-Application. Mais la méthode est exactement la même pour les relations de type One-To-One ou Many-To-Many.
					
					
				Annotation	
					
					Alors, attaquons la gestion d'une relation bidirectionnelle. L'objectif de cette relation est de rendre possible l'accès à l'entité propriétaire depuis l'entité inverse. Avec une unidirectionnelle, cela n'est pas possible, car on n'ajoute pas d'attribut dans l'entité inverse, ce qui signifie que l'entité inverse ne sait même pas qu'elle fait partie d'une relation.

					La première étape consiste donc à rajouter un attribut, et son annotation, à notre entité inverse Advert :

						<?php
						// src/OC/PlatformBundle/Entity/Advert.php

						/**
						 * @ORM\Entity
						 */
						class Advert
						{
						  /**
						   * @ORM\OneToMany(targetEntity="OC\PlatformBundle\Entity\Application", mappedBy="advert")
						   */
						  private $applications; // Notez le « s », une annonce est liée à plusieurs candidatures

							// …
						}
						
					Bien entendu, je vous dois des explications sur ce que l'on vient de faire.

					Commençons par l'annotation. L'inverse d'un Many-To-One est… un One-To-Many, tout simplement ! Il faut donc utiliser l'annotation One-To-Many dans l'entité inverse. Je rappelle que le propriétaire d'une relation Many-To-One est toujours le côté Many, donc, lorsque vous voyez l'annotation Many-To-One, vous êtes forcément du côté propriétaire. Ici on a un One-To-Many, on est bien du côté inverse.

					Ensuite, les paramètres de cette annotation. Le targetEntity est évident, il s'agit toujours de l'entité à l'autre bout de la relation, ici notre entité Application. Le mappedBy correspond, lui, à l'attribut de l'entité propriétaire (Application) qui pointe vers l'entité inverse (Advert) : c'est le private $advert de l'entité Application. Il faut le renseigner pour que l'entité inverse soit au courant des caractéristiques de la relation : celles-ci sont définies dans l'annotation de l'entité propriétaire.

					Il faut également adapter l'entité propriétaire, pour lui dire que maintenant la relation est de type bidirectionnelle et non plus unidirectionnelle. Pour cela, il faut simplement rajouter le paramètre inversedBy dans l'annotation Many-To-One :

						<?php
						// src/OC/PlatformBundle/Entity/Application.php

						namespace OC\PlatformBundle\Entity;

						/**
						 * @ORM\Entity
						 */
						class Application
						{
						  /**
						   * @ORM\ManyToOne(targetEntity="OC\PlatformBundle\Entity\Advert", inversedBy="applications")
						   * @ORM\JoinColumn(nullable=false)
						   */
						  private $advert;

						  // …
						}
						
					Ici, nous avons seulement rajouté le paramètre inversedBy. Il correspond au symétrique du mappedBy, c'est-à-dire à l'attribut de l'entité inverse (Advert) qui pointe vers l'entité propriétaire (Application). C'est donc l'attribut applications.

					Tout est bon côté annotation, maintenant il faut également ajouter les getters et setters dans l'entité inverse bien entendu.
					
					
				Getters et setters
					
					On part d'une relation unidirectionnelle fonctionnelle, donc les getters et setters de l'entité propriétaire sont bien définis.

					Dans un premier temps, ajoutons assez logiquement le getter et le setter dans l'entité inverse. On vient de lui ajouter un attribut, il est normal que le getter et le setter aillent de paire. >>> Comme nous sommes du côté One d'un One-To-Many, l'attribut applications est un ArrayCollection. 
					C'est donc un addApplication / removeApplication / getApplications qu'il nous faut. Encore une fois, vous pouvez le générer avec doctrine:generate:entities OCPlatformBundle:Advert, ou alors vous pouvez utiliser ce code :

						<?php
						// src/OC/PlatformBundle/Entity/Advert.php

						namespace OC\PlatformBundle\Entity;

						use Doctrine\Common\Collections\ArrayCollection;
						use Doctrine\ORM\Mapping as ORM;

						/**
						 * @ORM\Table(name="oc_advert")
						 * @ORM\Entity(repositoryClass="OC\PlatformBundle\Repository\AdvertRepository")
						 */
						class Advert
						{
						  /**
						   * @ORM\OneToMany(targetEntity="OC\PlatformBundle\Entity\Application", mappedBy="advert")
						   */
						  private $applications; // Notez le « s », une annonce est liée à plusieurs candidatures

						  // … vos autres attributs

						  public function __construct()
						  {
							$this->applications = new ArrayCollection();
							// ...
						  }

						  public function addApplication(Application $application)
						  {
							$this->applications[] = $application;
						  }

						  public function removeApplication(Application $application)
						  {
							$this->applications->removeElement($application);
						  }

						  public function getApplications()
						  {
							return $this->applications;
						  }

						  // …
						}
						
						
					Maintenant, il faut nous rendre compte d'un petit détail. Voici une petite problématique, lisez bien ce code :

						<?php
						// Création des entités
						$advert = new Advert;
						$application = new Application;

						// On lie la candidature à l'annonce
						$advert->addApplication($application);
						
					Que retourne$application->getAdvert()?
					
					La réponse est : rien ! En effet, pour qu'un$application->getAdvert()retourne effectivement une annonce, il faut d'abord le lui définir en appelant$application->setAdvert($advert), c'est logique !

					Si vous ne voyez pas pourquoi Doctrine n'a pas rempli l'attributadvert de l'objet$application, il faut revenir aux fondamentaux. Vous êtes en train d'écrire du PHP,$advert et$application sont deux objets PHP, tels qu'ils existaient bien avant la naissance de Doctrine. Pour que l'attributadvert de l'objet  $application soit défini, il faut impérativement faire appel au settersetAdvert(), car c'est le seul qui accède à cet attribut (qui est enprivate). Dans le petit exemple que je vous ai mis, personne ne réalise cesetAdvert(), l'attributadvert est donc toujours à null (valeur par défaut à la création de l'objet). ;)
					C'est logique en soi, mais du coup dans notre code cela va être moins beau : il faut en effet lier la candidature à l'annonce et l'annonce à la candidature. Comme ceci :

						<?php
						// Création des entités
						$advert = new Advert;
						$application = new Application;

						// On lie la candidature à l'annonce
						$advert->addApplication($application);

						// On lie l'annonce à la candidature
						$application->setAdvert($advert);
						
					Mais ces deux méthodes étant intimement liées, on doit en fait les imbriquer. En effet, laisser le code en l'état est possible, mais imaginez qu'un jour vous oubliiez d'appeler l'une des deux méthodes ; votre code ne sera plus cohérent. Et un code non cohérent est un code qui a des risques de contenir des bugs. La bonne façon de faire est donc simplement de faire appel à l'une des méthodes depuis l'autre. Voici concrètement comme le faire en modifiant les setters dans l'une des deux entités :

						<?php
						// src/OC/PlatformBundle/Entity/Advert.php

						namespace OC\PlatformBundle\Entity;

						/**
						 * @ORM\Entity
						 */
						class Advert
						{
						  // …

						  public function addApplication(Application $application)
						  {
							$this->applications[] = $application;

							// On lie l'annonce à la candidature
							$application->setAdvert($this);

							return $this;
						  }

						  public function removeApplication(Application $application)
						  {
							$this->applications->removeElement($application);

							// Et si notre relation était facultative (nullable=true, ce qui n'est pas notre cas ici attention) :        
							// $application->setAdvert(null);
						  }

						  // …
						}
						
					Notez qu'ici j'ai modifié un côté de la relation (l'inverse en l'occurrence), mais surtout pas les deux ! En effet, siaddApplication()exécutesetAdvert(), qui exécute à son touraddApplication(), qui… etc. On se retrouve avec une boucle infinie.

					Bref, l'important est de se prendre un côté (propriétaire ou inverse, cela n'a pas d'importance), et de l'utiliser. Par utiliser, j'entends que dans le reste du code (contrôleur, service, etc.) il faudra exécuter$advert->addApplication()qui garde la cohérence entre les deux entités. Il ne faudra jamais exécuter$application->setAdvert(), car lui ne garde pas la cohérence ! Retenez : on modifie le setter d'un côté, et on utilise ensuite ce setter-là. C'est simple, mais important à respecter.


					
			Pour conclure
				
				Si vous voulez plus d'informations sur les fixtures que l'on a rapidement abordées lors de ce chapitre, je vous invite à lire la page de la documentation du bundle : 
				
					https://symfony.com/doc/current/bundles/DoctrineFixturesBundle/index.html

				Rendez-vous au prochain chapitre pour apprendre à récupérer les entités depuis la base de données à votre guise, grâce aux repositories !
				
				
			En résumé
				
				Les relations Doctrine révèlent toute la puissance de l'ORM.
				Dans une relation entre deux entités, l'une est propriétaire de la relation et l'autre est inverse. Cette notion est purement technique.
				Une relation est dite unidirectionnelle si l'entité inverse n'a pas d'attribut la liant à l'entité propriétaire. On met en place une relation bidirectionnelle lorsqu'on a besoin de cet attribut dans l'entité inverse (ce qui arrivera pour certains formulaires, etc.).
				Le code du cours tel qu'il doit être à ce stade est disponible sur la branche iteration-10 du dépôt Github.
				
				
					
		4. Récupérer ses entités avec Doctrine2
		
			L'une des principales fonctions de la couche Modèle dans une application MVC, c'est la récupération des données. Récupérer des données n'est pas toujours évident, surtout lorsqu'on veut récupérer seulement certaines données, les classer selon des critères, etc. Tout cela se fait grâce aux repositories, que nous étudions dans ce chapitre. Bonne lecture !

			Le rôle des repositories
			
				On s'est déjà rapidement servi de quelques repositories, donc vous devriez sentir leur utilité, mais il est temps de théoriser un peu.

				Définition

					Un repository centralise tout ce qui touche à la récupération de vos entités. Concrètement, cela veut dire que vous ne devez pas faire la moindre requête SQL ailleurs que dans un repository, c'est la règle. On va donc y construire des méthodes pour récupérer une entité par son id, pour récupérer une liste d'entités suivant un critère spécifique, etc. Bref, à chaque fois que vous devez récupérer des entités dans votre base de données, vous utiliserez le repository de l'entité correspondante.

					Rappelez-vous, il existe un repository par entité. Cela permet de bien organiser son code. Bien sûr, cela n'empêche pas qu'un repository utilise plusieurs entités, dans le cas d'une jointure par exemple.

					Les repositories ne fonctionnent pas par magie, ils utilisent en réalité directement l'EntityManager pour faire leur travail. Vous le verrez, parfois nous ferons directement appel à l'EntityManager depuis des méthodes du repository.

				Deux façons pour construire vos requêtes de récupération des entités

						Depuis un repository, il existe deux façons de récupérer les entités : en utilisant du DQL et en utilisant le QueryBuilder.

					Le Doctrine Query Language (DQL)

						Le DQL n'est rien d'autre que du SQL adapté à la vision par objets que Doctrine utilise. Il s'agit donc de faire ce qu'on a l'habitude de faire, des requêtes textuelles comme celle-ci par exemple :

						SELECT a FROM OCPlatformBundle:Advert a
						
						Vous venez de voir votre première requête DQL. Retenez le principe : avec une requête qui n'est rien d'autre que du texte, on effectue le traitement voulu.

					Le QueryBuilder

						Le QueryBuilder est un moyen plus puissant. Comme son nom l'indique, il sert à construire une requête, par étape. Si l'intérêt n'est pas évident au début, son utilisation se révèle vraiment pratique ! Voici la même requête que précédemment, mais en utilisant le QueryBuilder :

						<?php
						$queryBuilder
						  ->select('a')
						  ->from('OCPlatformBundle:Advert', 'a')
						;
						Un des avantages est qu'il est possible de construire la requête en plusieurs fois.

						Je m'explique. Imaginions que vous voulez construire une requête un peu complexe. A un moment donné, vous souhaitez filtrer les résultats sur un champ particulier à l'aide de la condition  published = 1  par exemple. Lorsque vous écrivez une requête SQL ou même DQL en texte, il y a plusieurs cas à gérer selon qu'unWHERE  existe déjà dans la requête ou non. Si c'est le cas, il faut écrireAND champ = 1 . Sinon,WHERE champ = 1 . Ce n'est pas si simple !

						Avec le QueryBuilder, en une ligne vous êtes certain du résultat :

						<?php

						$queryBuilder = ...;

						// Je rajoute ma condition, quel que soit ce que j'ai déjà dans mon QueryBuilder :
						$queryBuilder->andWhere('champ = 1');
						
						Bien sûr l'exemple est simplifié, mais pas de panique, on verra des exemples dans la suite du chapitre et vous verrez que ce QueryBuilder est vraiment pratique ;)

			Les méthodes de récupération de base
			
				Définition

					Vos repositories héritent de la classeDoctrine\ORM\EntityRepository, qui propose déjà quelques méthodes très utiles pour récupérer des entités. Ce sont ces méthodes là que nous allons voir ici.

				Les méthodes normales

					Il existe quatre méthodes, que voici (tous les exemples sont effectués depuis un contrôleur).

					find($id)

						La méthode find($id) récupère tout simplement l'entité correspondante à l'id $id. Dans le cas de notre AdvertRepository, elle retourne une instance d'Advert. Exemple :

						<?php
						$repository = $this
						  ->getDoctrine()
						  ->getManager()
						  ->getRepository('OCPlatformBundle:Advert')
						;

						$advert = $repository->find(5);
						// $advert est une instance de OC\PlatformBundle\Entity\Advert
						// Correspondant à l'id 5
						
						Si aucune entité ne correspond à cet id 5, alors la méthode find  retourne null.

					findAll() 

						La méthode findAll() retourne toutes les entités contenue dans la base de données. Le format du retour est un tableau PHP normal (un array), que vous pouvez parcourir (avec un foreach par exemple) pour utiliser les objets qu'il contient. Exemple :

							<?php
							$repository = $this
							  ->getDoctrine()
							  ->getManager()
							  ->getRepository('OCPlatformBundle:Advert')
							;

							$listAdverts = $repository->findAll();

							foreach ($listAdverts as $advert) {
							  // $advert est une instance de Advert
							  echo $advert->getContent();
							}
			
						Ou dans une vue Twig, si l'on a passé la variable$listAdverts au template :

							<ul>
							  {% for advert in listAdverts %}
								<li>{{ advert.content }}</li>
							  {% endfor %}
							</ul>
			
			
					findBy()

						La méthodefindBy()est un peu plus intéressante. CommefindAll(), elle permet de retourner une liste d'entités, sauf qu'elle est capable d'effectuer un filtre pour ne retourner que les entités correspondant à un ou plusieurs critère(s). Elle peut aussi trier les entités, et même n'en récupérer qu'un certain nombre (pour une pagination).

						La syntaxe est la suivante :

							<?php
							$repository->findBy(
							  array $criteria,
							  array $orderBy = null,
							  $limit  = null,
							  $offset = null
							);
							
						Voici un exemple d'utilisation :

							<?php

							$listAdverts = $repository->findBy(
							  array('author' => 'Alexandre'), // Critere
							  array('date' => 'desc'),        // Tri
							  5,                              // Limite
							  0                               // Offset
							);

							foreach ($listAdverts as $advert) {
							  // $advert est une instance de Advert
							 echo $advert->getContent();
							}
			
						et exemple va récupérer toutes les entités ayant comme auteur « Alexandre » en les classant par date décroissante et en en sélectionnant cinq(5)à partir du début(0). Elle retourne unarrayégalement. Vous pouvez mettre plusieurs entrées dans le tableau des critères, afin d'appliquer plusieurs filtres (qui seront associés avec unAND  et non unOR ).

					findOneBy()

						La méthodefindOneBy(array $criteria, array $orderBy = null)fonctionne sur le même principe que la méthodefindBy(), sauf qu'elle ne retourne qu'une seule entité. Les argumentslimitetoffsetn'existent donc pas. Exemple :

							<?php

							$advert = $repository->findOneBy(array('author' => 'Marine'));
							// $advert est une instance de Advert
			
						A l'instar de la méthodefind , la méthodefindOneBy  retourne null si aucune entité ne correspond aux critères demandés. Si plusieurs entités correspondent aux critères, alors c'est la première dans l'ordre que vous avez demandé (argument$orderBy ) qui sera retournée.

						Ces méthodes permettent de couvrir pas mal de besoins. Mais pour aller plus loin encore, Doctrine nous offre deux autres méthodes magiques.

				Les méthodes magiques

					Vous connaissez le principe des méthodes magiques, comme__call()qui émule des méthodes. Ces méthodes émulées n'existent pas dans la classe, elle sont prises en charge par__call()qui va exécuter du code en fonction du nom de la méthode appelée.

					Voici les deux méthodes gérées par__call()dans les repositories.

					findByX($valeur)

						Première méthode, en remplaçant « X » par le nom d'une propriété de votre entité. Dans notre cas, pour l'entitéAdvert, nous avons donc plusieurs méthodes :findByTitle(),findByDate(),findByAuthor(),findByContent(), etc.

						Cette méthode fonctionne comme si vous utilisiez findBy() avec un seul critère, celui du nom de la méthode.

							<?php

							$listAdverts = $repository->findByAuthor('Alexandre');
							// $listAdverts est un Array qui contient toutes les annonces
							// écrites par Alexandre
			
						On a doncfindBy(array('author' => 'Alexandre'))  qui est strictement égal à findByAuthor('Alexandre') .

					findOneByX($valeur) 

						Deuxième méthode, en remplaçant « X » par le nom d'une propriété de votre entité. Dans notre cas, pour l'entitéAdvert, nous avons donc plusieurs méthodes :findOneByTitle(),findOneByDate(),findOneByAuthor(),findOneByContent(), etc.

						Cette méthode fonctionne commefindOneBy(), sauf que vous ne pouvez mettre qu'un seul critère, celui du nom de la méthode.

							<?php

							$advert = $repository->findOneByTitle('Recherche développeur.');
							// $advert est une instance d'Advert dont le titre
							// est "Recherche développeur." ou null si elle n'existe pas.
			
						Toutes ces méthodes permettent de récupérer vos entités dans la plupart des cas. Simplement, elles montrent rapidement leurs limites lorsqu'on doit faire des jointures, ou effectuer des conditions plus complexes. Pour cela — et cela nous arrivera très souvent — il faudra faire nos propres méthodes de récupération.

				Les méthodes de récupération personnelles
				
					La théorie

						Pour développer nos propres méthodes, il faut bien comprendre comment fonctionne Doctrine2 pour construire ses requêtes. Il faut notamment distinguer trois types d'objets qui vont nous servir, et qu'il ne faut pas confondre : le QueryBuilder, la Query et les résultats.

					Le QueryBuilder

						On l'a déjà vu rapidement, le QueryBuilder permet de construire une Query, mais il n'est pas une Query lui-même !

						Pour récupérer un QueryBuilder, on peut utiliser simplement l'EntityManager. En effet, il dispose d'une méthodecreateQueryBuilder()qui nous retournera une instance de QueryBuilder. L'EntityManager est accessible depuis un repository en utilisant l'attribut_em, soit$this->_em. Le code complet pour récupérer un QueryBuilder neuf depuis une méthode d'un repository est donc$this->_em->createQueryBuilder().

						Cependant, cette méthode nous retourne un QueryBuilder vide, c'est-à-dire sans rien de prédéfini. C'est dommage, car lorsqu'on récupère un QueryBuilder depuis un repository, c'est que l'on veut faire une requête sur l'entité gérée par ce repository. Donc si l'on pouvait définir la partieSELECT advert FROM OCPlatformBundle:Advertsans trop d'effort, cela serait bien pratique, car ce qui est intéressant, c'est le reste de la requête. Heureusement, le repository contient également une méthodecreateQueryBuilder($alias)qui utilise la méthode de l'EntityManager, mais en définissant pour nous le SELECT et le FROM. Vous pouvez jeter un œil à cette méthodecreateQueryBuilder() pour comprendre.

						L'alias en argument de la méthode est le raccourci que l'on donne à l'entité du repository. On utilise souvent la première lettre du nom de l'entité, dans notre exemple de l'annonce cela serait donc un « a ».

						Beaucoup de théorie, passons donc à la pratique ! Pour bien comprendre la différence QueryBuilder / Query, ainsi que la récupération du QueryBuilder, rien de mieux qu'un exemple. Nous allons recréer la méthodefindAll()dans notre repositoryAdvert :

							<?php
							// src/OC/PlatformBundle/Entity/AdvertRepository.php

							namespace OC\PlatformBundle\Entity;

							use Doctrine\ORM\EntityRepository;

							class AdvertRepository extends EntityRepository
							{
							  public function myFindAll()
							  {
								// Méthode 1 : en passant par l'EntityManager
								$queryBuilder = $this->_em->createQueryBuilder()
								  ->select('a')
								  ->from($this->_entityName, 'a')
								;
								// Dans un repository, $this->_entityName est le namespace de l'entité gérée
								// Ici, il vaut donc OC\PlatformBundle\Entity\Advert

								// Méthode 2 : en passant par le raccourci (je recommande)
								$queryBuilder = $this->createQueryBuilder('a');

								// On n'ajoute pas de critère ou tri particulier, la construction
								// de notre requête est finie

								// On récupère la Query à partir du QueryBuilder
								$query = $queryBuilder->getQuery();

								// On récupère les résultats à partir de la Query
								$results = $query->getResult();

								// On retourne ces résultats
								return $results;
							  }
							}
			
						Cette méthodemyFindAll()retourne exactement le même résultat qu'unfindAll(), c'est-à-dire un tableau de toutes les entitésAdvert dans notre base de données.

						Les méthodes 1 et 2 pour récupérer le QueryBuilder sont strictement équivalentes, c'est juste pour illustrer ce que j'ai dit précédemment.

						Vous pouvez le voir, faire une simple requête est assez facile. Pour mieux le visualiser, je vous propose la même méthode sans les commentaires et en raccourci :

							<?php
							public function myFindAll()
							{
							  return $this
								->createQueryBuilder('a')
								->getQuery()
								->getResult()
							  ;
							}
			
						Simplissime, non ? 

						Et bien sûr, pour récupérer les résultats depuis un contrôleur il faut faire comme avec n'importe quelle autre méthode du repository, comme ceci :

							<?php
							// Depuis un contrôleur

							public function testAction()
							{
							  $repository = $this
								->getDoctrine()
								->getManager()
								->getRepository('OCPlatformBundle:Advert')
							  ;
							  
							  $listAdverts = $repository->myFindAll();

							  // ...
							}
							
						Bon pour l'instant c'est très simple car on a juste récupéré le QueryBuilder avec ses paramètres par défaut, mais on n'a pas encore joué avec lui.

						Le QueryBuilder dispose de plusieurs méthodes afin de construire notre requête. Il y a une ou plusieurs méthodes par partie de requête : le WHERE, le ORDER BY, le FROM, etc. Ces méthodes n'ont rien de compliqué, voyez-le dans les exemples suivants.

						Commençons par recréer une méthode équivalente aufind($id)de base, pour nous permettre de manipuler lewhere()et lesetParameter().

							<?php
							// Dans un repository

							public function myFindOne($id)
							{
							  $qb = $this->createQueryBuilder('a');

							  $qb
								->where('a.id = :id')
								->setParameter('id', $id)
							  ;

							  return $qb
								->getQuery()
								->getResult()
							  ;
							}
							
						Vous connaissez déjà le principe des paramètres, c'est le même qu'avec PDO. On définit un paramètre dans la requête avec:nom_du_parametre, puis on attribue une valeur à ce paramètre avec la méthodesetParameter('nom_du_parametre', $valeur). Le nom du paramètre est totalement libre, j'ai mis iciid  mais vous auriez pu utilisermon_super_id .

						Voici un autre exemple pour utiliser leandWhere()ainsi que leorderBy(). Créons une méthode pour récupérer toutes les annonces écrites par un auteur avant une année donnée :

							<?php
							// Depuis un repository 

							public function findByAuthorAndDate($author, $year)
							{
							  $qb = $this->createQueryBuilder('a');

							  $qb->where('a.author = :author')
								   ->setParameter('author', $author)
								 ->andWhere('a.date < :year')
								   ->setParameter('year', $year)
								 ->orderBy('a.date', 'DESC')
							  ;

							  return $qb
								->getQuery()
								->getResult()
							  ;
							}
							
							
						Maintenant, voyons un des avantages du QueryBuilder. Vous vous en souvenez, je vous avais dit qu'il était pratique pour créer des requêtes avec plein de conditions / jointures / etc. Voyons donc une application de ce principe, en considérant que la condition « annonces postées durant l'année en cours » est une condition dont on va se resservir souvent. Il faut donc en faire une méthode, que voici :

							<?php
							// src/OC/PlatformBundle/Entity/AdvertRepository.php

							namespace OC\PlatformBundle\Entity;

							use Doctrine\ORM\EntityRepository;
							// N'oubliez pas ce use
							use Doctrine\ORM\QueryBuilder;

							class AdvertRepository extends EntityRepository
							{
							  public function whereCurrentYear(QueryBuilder $qb)
							  {
								$qb
								  ->andWhere('a.date BETWEEN :start AND :end')
								  ->setParameter('start', new \Datetime(date('Y').'-01-01'))  // Date entre le 1er janvier de cette année
								  ->setParameter('end',   new \Datetime(date('Y').'-12-31'))  // Et le 31 décembre de cette année
								;
							  }
							}
			
						Vous notez donc que cette méthode ne traite pas une Query, mais bien uniquement le QueryBuilder. C'est en cela que ce dernier est très pratique, car faire cette méthode sur une requête en texte simple est possible, mais très compliqué. Il aurait fallu voir si le WHERE était déjà présent dans la requête, si oui mettre un AND au bon endroit, etc. Bref, pas simple.

						Pour utiliser cette méthode, voici la démarche :

							<?php
							// Depuis un repository

							public function myFind()
							{
							  $qb = $this->createQueryBuilder('a');

							  // On peut ajouter ce qu'on veut avant
							  $qb
								->where('a.author = :author')
								->setParameter('author', 'Marine')
							  ;

							  // On applique notre condition sur le QueryBuilder
							  $this->whereCurrentYear($qb);

							  // On peut ajouter ce qu'on veut après
							  $qb->orderBy('a.date', 'DESC');

							  return $qb
								->getQuery()
								->getResult()
							  ;
							}
			
						Voilà, vous pouvez dorénavant appliquer cette condition à n'importe laquelle de vos requêtes en construction.

						Je ne vous ai pas listé toutes les méthodes du QueryBuilder, il en existe bien d'autres. Pour cela, vous devez absolument mettre la page suivante dans vos favoris :
						
							http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/query-builder.html. 
						
						Ouvrez-la et gardez-la sous la main à chaque fois que vous voulez faire une requête à l'aide du QueryBuilder, c'est la référence !

					La Query

						Vous l'avez vu, la Query est l'objet à partir duquel on extrait les résultats. Il n'y a pas grand-chose à savoir sur cet objet en lui-même, car il ne permet pas grand-chose à part récupérer les résultats. 
						>>> Il sert en fait surtout à la gestion du cache des requêtes.

						Mais détaillons tout de même les différentes façons d'extraire les résultats de la requête. Ces différentes manières sont toutes à maîtriser, car elles concernent chacune un type de requête.

						getResult()

							Exécute la requête et retourne un tableau contenant les résultats sous forme d'objets. 
							Vous récupérez ainsi une liste des objets, sur lequels vous pouvez faire des opérations, des modifications, etc.
							Même si la requête ne retourne qu'un seul résultat, cette méthode retourne un tableau.

								<?php
								$listAdverts = $qb->getQuery()->getResult();

								foreach ($listAdverts as $advert) {
								  // $advert est une instance d'Advert dans notre exemple
								  $advert->getContent();
								}
								
						getArrayResult()
								
							Exécute la requête et retourne un tableau contenant les résultats sous forme de tableaux. Comme avecgetResult(), vous récupérez un tableau même s'il n'y a qu'un seul résultat. Mais dans ce tableau, vous n'avez pas vos objets d'origine, vous avez des simples tableaux. Cette méthode est utilisée lorsque vous ne voulez que lire vos résultats, sans y apporter de modification. Elle est dans ce cas plus rapide que son homologuegetResult().

								<?php
								$listAdverts = $qb->getQuery()->getArrayResult();

								foreach ($listAdverts as $advert) {
								  // $advert est un tableau
								  // Faire $advert->getContent() est impossible. Vous devez faire :
								  $advert['content'];
								}
								
							Heureusement, Twig est intelligent :{{ advert.content }}exécute$advert->getContent()si$advert est un objet, et exécute$advert['content']sinon. Du point de vue de Twig, vous pouvez utilisergetResult()ougetArrayResult()indifféremment.

							Par contre attention, cela veut dire que si vous faites une modification à votre tableau, par exemple $advert['content'] = 'Nouveau contenu', elle ne sera pas enregistrée dans la base de données lors du prochainflush ! À n'utiliser que si vous êtes certains de ne faire que de l'affichage avec vos résultats, et dans un soucis d'optimisation.

						getScalarResult()

							Exécute la requête et retourne un tableau contenant les résultats sous forme de valeurs. Comme avecgetResult(), vous récupérez un tableau même s'il n'y a qu'un seul résultat.

							Mais dans ce tableau, un résultat est une valeur, non un tableau de valeurs (getArrayResult) ou un objet de valeurs (getResult). Cette méthode est donc utilisée lorsque vous ne sélectionnez qu'une seule valeur dans la requête, par exemple :SELECT COUNT(*) FROM …. Ici, la valeur est la valeur du COUNT.

								<?php
								$values = $qb->getQuery()->getScalarResult();

								foreach ($values as $value) {
								  // $value est la valeur de ce qui a été sélectionné : un nombre, un texte, etc.
								  $value;

								  // Faire $value->getAttribute() ou $value['attribute'] est impossible
								}
								
						getOneOrNullResult()

							Exécute la requête et retourne un seul résultat, ounullsi pas de résultat. Cette méthode retourne donc une instance de l'entité (ounull) et non un tableau d'entités commegetResult().

							Cette méthode déclenche une exceptionDoctrine\ORM\NonUniqueResultExceptionsi la requête retourne plus d'un seul résultat. Il faut donc l'utiliser si l'une de vos requêtes n'est pas censée retourner plus d'un résultat : déclencher une erreur plutôt que de laisser courir permet d'anticiper des futurs bugs !

								<?php
								$advert = $qb->getQuery()->getOneOrNullResult();

								// $advert est une instance d'Advert dans notre exemple
								// Ou null si la requête ne contient pas de résultat

								// Et une exception a été déclenchée si plus d'un résultat
			
						getSingleResult()

							Exécute la requête et retourne un seul résultat. Cette méthode est exactement la même quegetOneOrNullResult(), sauf qu'elle déclenche une exceptionDoctrine\ORM\NoResultExceptionsi aucun résultat.

							C'est une méthode très utilisée, car faire des requêtes qui ne retournent qu'un unique résultat est très fréquent. 

								<?php
								$advert = $qb->getQuery()->getSingleResult();

								// $advert est une instance d'Advert dans notre exemple

								// Une exception a été déclenchée si plus d'un résultat
								// Une exception a été déclenchée si pas de résultat
			
						getSingleScalarResult()

							Exécute la requête et retourne une seule valeur, et déclenche des exceptions si pas de résultat ou plus d'un résultat.

							Cette méthode est très utilisée également pour des requêtes du typeSELECT COUNT(*) FROM Advert, qui ne retournent qu'une seule ligne de résutlat, et une seule valeur dans cette ligne.

							<?php
							$value = $qb->getQuery()->getSingleScalarResult();

							// $value est directement la valeur du COUNT dans la requête exemple

							// Une exception a été déclenchée si plus d'un résultat
							// Une exception a été déclenchée si pas de résultat
			
						execute()

							Exécute la requête. Cette méthode est utilisée principalement pour exécuter des requêtes qui ne retournent pas de résultats (desUPDATE,INSERT INTO, etc.) :

								<?php
								// Exécute un UPDATE par exemple :
								$qb->getQuery()->execute();
			
							Cependant, toutes les autres méthodes que nous venons de voir ne sont en fait que des raccourcis vers cette méthodeexecute(), en changeant juste le mode d'hydratation des résultats (objet, tableau, etc.).

								<?php
								// Voici deux méthodes strictement équivalentes :
								$results = $query->getArrayResult();
								// Et :
								$results = $query->execute(array(), Query::HYDRATE_ARRAY);

								// Le premier argument de execute() est un tableau de paramètres
								// Vous pouvez aussi passer par la méthode setParameter(), au choix

								// Le deuxième argument de execute() est ladite méthode d'hydratation
								
							Pensez donc à bien choisir votre façon de récupérer les résultats à chacune de vos requêtes.

					Utilisation du Doctrine Query Language (DQL)

						Le DQL est une sorte de SQL adapté à l'ORM Doctrine2. Il permet de faire des requêtes un peu à l'ancienne, en écrivant une requête en chaîne de caractères (en opposition au QueryBuilder).

						Pour écrire une requête en DQL, il faut donc oublier le QueryBuilder, on utilisera seulement l'objet Query. Et la méthode pour récupérer les résultats sera la même. Le DQL n'a rien de compliqué, et il est très bien documenté.

						La théorie

							Pour créer une requête en utilisant du DQL, il faut utiliser la méthodecreateQuery()de l'EntityManager :

								<?php
								// Depuis un repository
								public function myFindAllDQL()
								{
								  $query = $this->_em->createQuery('SELECT a FROM OCPlatformBundle:Advert a');
								  $results = $query->getResult();

								  return $results;
								}
								
							Regardons de plus près la requête DQL en elle-même :

								SELECT a FROM OCPlatformBundle:Advert a
			
							Tout d'abord, vous voyez que l'on n'utilise pas de table. On a dit qu'on pensait objet et non plus base de données ! Il faut donc utiliser dans les FROM et les JOIN le nom des entités. Soit en utilisant le nom raccourci comme on l'a fait, soit le namespace complet de l'entité. De plus, il faut toujours donner un alias à l'entité, ici on a mis « a ». On met souvent la première lettre de l'entité, même si ce n'est absolument pas obligatoire.

							Ensuite, vous imaginez bien qu'il ne faut pas sélectionner un à un les attributs de nos entités, cela n'aurait pas de sens. Une entitéAdvert avec le titre renseigné mais pas la date ? Ce n'est pas logique. C'est pourquoi on sélectionne simplement l'alias, ici « a », ce qui sélectionne en fait tous les attributs d'une annonce. L'équivalent d'une étoile (*) en SQL donc.

							Sachez qu'il est tout de même possible de ne sélectionner qu'une partie d'un objet, en faisant « a.title » par exemple. Mais vous ne recevez alors qu'un tableau contenant les attributs sélectionnés, et non un objet. Vous ne pouvez donc pas modifier/supprimer/etc. l'objet, puisque c'est un tableau. Cela sert dans des requêtes particulières, mais la plupart du temps on sélectionnera bien tout l'objet.
							Faire des requêtes en DQL n'a donc rien de compliqué. Lorsque vous les faites, gardez bien sous la main la page de la documentation sur le DQL pour en connaître la syntaxe. En attendant, je peux vous montrer quelques exemples afin que vous ayez une idée globale du DQL.

							Pour tester rapidement vos requêtes DQL sans avoir à les implémenter dans une méthode de votre repository, Doctrine2 nous simplifie la vie grâce à la commandedoctrine:query:dql. Cela vous permet de faire quelques tests afin de construire ou de vérifier vos requêtes, à utiliser sans modération donc ! Je vous invite dès maintenant à exécuter la commande suivante :php bin/console doctrine:query:dql "SELECT a FROM OCPlatformBundle:Advert a".
			
						Exemples

							Pour faire une jointure :

								SELECT a, u FROM OCPlatformBundle:Advert a JOIN a.user u WHERE u.age = 25
								
							Pour utiliser une fonction SQL (attention toutes les fonctions SQL ne sont pas implémentées en DQL) :

								SELECT a FROM OCPlatformBundle:Advert a WHERE TRIM(a.author) = 'Alexandre'
								
							Pour sélectionner seulement un attribut (attention les résultats seront donc sous forme de tableaux et non d'objets) :

								SELECT a.title FROM OCPlatformBundle:Advert a WHERE a.id IN(1, 3, 5)
								
							Et bien sûr vous pouvez également utiliser des paramètres :

								<?php
								public function myFindDQL($id)
								{
								  $query = $this->_em->createQuery('SELECT a FROM OCPlatformBundle:Advert a WHERE a.id = :id');
								  $query->setParameter('id', $id);
								  
								  // Utilisation de getSingleResult car la requête ne doit retourner qu'un seul résultat
								  return $query->getSingleResult();
								}
								
				Utiliser les jointures dans nos requêtes
				
					Pourquoi utiliser les jointures ?

						Je vous en ai déjà parlé dans le chapitre précédent sur les relations entre entités. Lorsque vous utilisez la syntaxe $entiteA->getEntiteB(), Doctrine exécute une requête afin de charger les entités B qui sont liées à l'entité A.

						L'objectif est donc de maîtriser quand charger juste l'entité A, et quand charger l'entité A avec ses entités B liées (lorsque nous sommes certains d'en avoir besoin). Nous avons déjà vu le premier cas, par exemple un $repositoryA->find($id)ne récupère qu'une seule entité A sans récupérer les entités liées. Maintenant, voyons comment réaliser le deuxième cas, c'est-à-dire récupérer tout d'un coup avec une jointure, pour éviter une seconde requête par la suite.

						Tout d'abord, rappelons le cas d'utilisation principal de ces jointures. C'est surtout lorsque vous bouclez sur une liste d'entités A (par exemple des annonces), et que dans cette boucle vous faites$entiteA->getEntiteB()(par exemple des candidatures). Avec une requête par itération dans la boucle, vous explosez votre nombre de requêtes sur une seule page ! C'est donc principalement pour éviter cela que nous allons faire des jointures.

					Comment faire des jointures avec le QueryBuilder ?

						Heureusement, c'est très simple ! Voici tout de suite un exemple :

							<?php
							// Depuis le repository d'Advert
							public function getAdvertWithApplications()
							{
							  $qb = $this
								->createQueryBuilder('a')
								->leftJoin('a.applications', 'app')
								->addSelect('app')
							  ;

							  return $qb
								->getQuery()
								->getResult()
							  ;
							}
							
						Rien d'extravagant donc ! Voici l'idée un peu plus en détails :

							- D'abord on crée une jointure avec la méthodeleftJoin() (ou  innerJoin() pour faire l'équivalent d'unINNER JOIN). Le premier argument de la méthode est l'attribut de l'entité principale (celle qui est dans leFROM de la requête) sur lequel faire la jointure. Dans l'exemple, l'entitéAdvert possède un attributapplications. Le deuxième argument de la méthode est l'alias de l'entité jointe (arbitraire).
							- Puis on sélectionne également l'entité jointe, via unaddSelect(). En effet, unselect('app') tout court aurait écrasé leselect('a') déjà fait par lecreateQueryBuilder(), rappelez-vous.
			
							Attention : on ne peut faire une jointure que si l'entité duFROMpossède un attribut vers l'entité à joindre ! Cela veut dire que soit l'entité duFROMest l'entité propriétaire de la relation, soit la relation est bidirectionnelle.
							Dans notre exemple, la relation entreAdvert etApplication est une Many-To-One avecApplication du côté Many, le côté propriétaire donc. Cela veut dire que pour pouvoir faire la jointure dans ce sens, la relation est bidirectionnelle, afin d'ajouter un attributapplications dans l'entité inverseAdvert. C'est ce que nous avons fait à la fin du chapitre précédent.
			
							Et pourquoi n'a-t-on pas précisé la condition « ON » du JOIN ?
							
							C'est une bonne question. La réponse est très logique, pour cela réfléchissez plutôt à la question suivante : pourquoi est-ce qu'on rajoute unONhabituellement dans nos requêtes SQL ? C'est pour que MySQL (ou tout autre SGBDR) puisse savoir sur quelle condition faire la jointure. Or ici, on s'adresse à Doctrine et non directement à MySQL. Et bien entendu, Doctrine connaît déjà tout sur notre association, grâce aux annotations ! Il est donc inutile de lui préciser leON.

							Bien sûr, vous pouvez toujours personnaliser la condition de jointure, en rajoutant vos conditions à la suite duONgénéré par Doctrine, grâce à la syntaxe duWITH:

								<?php
								$qb->innerJoin('a.applications', 'app', 'WITH', 'YEAR(app.date) > 2013')
								
							Le troisième argument est le type de conditionWITH, et le quatrième argument est ladite condition.

								« WITH » ? C'est quoi cette syntaxe pour faire une jointure ?
								
							En SQL, la différence entre leONet leWITHest simple : unON définit la condition pour la jointure, alors qu'unWITH ajoute une condition pour la jointure. Attention, en DQL leONn'existe pas, seul leWITHest supporté. Ainsi, la syntaxe précédente avec leWITHserait équivalente à la syntaxe SQL suivante à base deON:

								SELECT *
								FROM Advert a
								INNER JOIN Application app ON (app.advert_id = a.id AND YEAR(app.date) > 2013)
								
							Grâce auWITH, on n'a pas besoin de réécrire la condition par défaut de la jointure, leapp.advert_id = a.id.

					Comment utiliser les jointures ?

						Réponse : comme d'habitude ! Vous n'avez rien à modifier dans votre code (contrôleur, vue). Si vous utilisez une entité dont vous avez récupéré les entités liées avec une jointure, vous pouvez alors utiliser les getters joyeusement sans craindre de requête supplémentaire. Reprenons l'exemple de la méthodegetAdvertWithApplications()définie précédemment, on pourrait utiliser les résultats comme ceci :

							<?php
							// Depuis un contrôleur
							public function listAction()
							{
							  $listAdverts = $this
								->getDoctrine()
								->getManager()
								->getRepository('OCPlatformBundle:Advert')
								->getAdvertWithApplications()
							  ;

							  foreach ($listAdverts as $advert) {
								// Ne déclenche pas de requête : les candidatures sont déjà chargées !
								// Vous pourriez faire une boucle dessus pour les afficher toutes
								$advert->getApplications();
							  }

							  // …
							}
							
						Voici donc comment vous devrez faire la plupart de vos requêtes. En effet, vous aurez souvent besoin d'utiliser des entités liées entre elles, et faire une ou plusieurs jointures s'impose très souvent. ;)

			Application : les repositories de notre plateforme d'annonces
			
				Plan d'attaque

					Je vous propose quelques cas pratiques à implémenter dans nos repositories.

					Dans un premier temps, nous allons ajouter une méthode dans l'AdvertRepository pour récupérer toutes les annonces qui correspondent à une liste de catégories. Par exemple, on veut toutes les annonces dans les catégories Développeur et Intégrateur. La définition de la méthode est donc :

						<?php
						public function getAdvertWithCategories(array $categoryNames);
						
					Et on pourra l'utiliser comme ceci par exemple :

						<?php
						$repository->getAdvertWithCategories(array('Développeur', 'Intégrateur'));
			
					Dans un deuxième temps, je vous propose de créer une méthode dans l'ApplicationRepository pour récupérer les X dernières candidatures avec leur annonce associée. La définition de la méthode doit être comme ceci :

						<?php
						public function getApplicationsWithAdvert($limit);
			
					Le paramètre$limit étant le nombre de candidature à retourner.

					À vous de jouer !

					Important : faites-le vous-mêmes ! La correction est juste en dessous, je sais, mais si vous ne faites pas maintenant l'effort d'y réfléchir par vous-mêmes, cela vous handicapera par la suite !
			
				La correction

					AdvertRepository.php:

						<?php
						// src/OC/PlatformBundle/Entity/AdvertRepository.php

						namespace OC\PlatformBundle\Entity;

						use Doctrine\ORM\EntityRepository;
						use Doctrine\ORM\QueryBuilder;

						class AdvertRepository extends EntityRepository
						{
						  public function getAdvertWithCategories(array $categoryNames)
						  {
							$qb = $this->createQueryBuilder('a');

							// On fait une jointure avec l'entité Category avec pour alias « c »
							$qb
							  ->innerJoin('a.categories', 'c')
							  ->addSelect('c')
							;

							// Puis on filtre sur le nom des catégories à l'aide d'un IN
							$qb->where($qb->expr()->in('c.name', $categoryNames));
							// La syntaxe du IN et d'autres expressions se trouve dans la documentation Doctrine

							// Enfin, on retourne le résultat
							return $qb
							  ->getQuery()
							  ->getResult()
							;
						  }
						}
						
						Que faire avec ce que retourne cette fonction ?
			
						Comme je l'ai dit précédemment, cette fonction va retourner un tableau d'Advert. Qu'est-ce que l'on veut en faire ? Les afficher. Donc la première chose à faire est de passer ce tableau à Twig. Ensuite, dans Twig, vous faites un simple{% for %}pour afficher ces annonces. Ce n'est vraiment pas compliqué à utiliser !

					ApplicationRepository.php : 

						<?php
						// src/OC/PlatformBundle/Entity/AdvertRepository.php

						namespace OC\PlatformBundle\Entity;

						use Doctrine\ORM\EntityRepository;

						class ApplicationRepository extends EntityRepository
						{
						  public function getApplicationsWithAdvert($limit)
						  {
							$qb = $this->createQueryBuilder('a');

							// On fait une jointure avec l'entité Advert avec pour alias « adv »
							$qb
							  ->innerJoin('a.advert', 'adv')
							  ->addSelect('adv')
							;

							// Puis on ne retourne que $limit résultats
							$qb->setMaxResults($limit);

							// Enfin, on retourne le résultat
							return $qb
							  ->getQuery()
							  ->getResult()
							  ;
						  }
						}
						
						Et voilà, vous avez tout le code. Je n'ai qu'une chose à vous dire à ce stade du cours : entraînez-vous ! Amusez-vous à faire des requêtes dans tous les sens dans tous les repositories. Jouez avec les relations entre les entités, créez-en d'autres. Bref, cela ne viendra pas tout seul, il va falloir travailler un peu de votre côté. ;) 

				En résumé

					Le rôle d'un repository est, à l'aide du langage DQL ou du constructeur de requêtes, de récupérer des entités selon des contraintes, des tris, etc.
					Un repository dispose toujours de quelques méthodes de base, permettant de récupérer de façon très simple les entités.
					Mais la plupart du temps, il faut créer des méthodes personnelles pour récupérer les entités exactement comme on le veut.
					Il est indispensable de faire les bonnes jointures afin de limiter au maximum le nombre de requêtes SQL sur vos pages.
					Le code du cours tel qu'il doit être à ce stade est disponible sur la branche iteration-11 du dépôt Github.
			
		
		5. Les évènements et extensions Doctrine
		
			Les évènements Doctrine
			
				L'intérêt des évènements Doctrine

					Dans certains cas, vous pouvez avoir besoin d'effectuer des actions juste avant ou juste après la création, la mise à jour ou la suppression d'une entité. Par exemple, si vous stockez la date d'édition d'une annonce, à chaque modification de l'entitéAdvert il faut mettre à jour cet attribut juste avant la mise à jour dans la base de données.

					Ces actions, vous devez les faire à chaque fois. Cet aspect systématique a deux impacts. D'une part, cela veut dire qu'il faut être sûrs de vraiment les effectuer à chaque fois pour que votre base de données soit cohérente. D'autre part, cela veut dire qu'on est bien trop fainéants pour se répéter !

					C'est ici qu'interviennent les évènements Doctrine. Plus précisément, vous les trouverez sous le nom de callbacks du cycle de vie (lifecycle en anglais) d'une entité. Un callback est une méthode de votre entité, et on va dire à Doctrine de l'exécuter à certains moments.

					On parle d'évènements de « cycle de vie », car ce sont différents évènements que Doctrine déclenche à chaque moment de la vie d'une entité : son chargement depuis la base de données, sa modification, sa suppression, etc. On en reparle plus loin, je vous dresserai une liste complète des évènements et de leur utilisation.

				Définir des callbacks de cycle de vie

					Pour vous expliquer le principe, nous allons prendre l'exemple de notre entité Advert, qui va comprendre un attribut $updatedAt représentant la date de la dernière édition de l'annonce. Si vous ne l'avez pas déjà, ajoutez-le maintenant, et n'oubliez pas de mettre à jour la base de données à l'aide de la commande doctrine:schema:update :

						<?php
						/**
						 * @ORM\Column(name="updated_at", type="datetime", nullable=true)
						 */
			 
						private $updatedAt;
			
					J'ai défini le champ comme nullable (qui accepte la valeur NULL) car les nouvelles annonces qui n'ont encore jamais été éditées auront cet attribut à null.
			
					1. Définir l'entité comme contenant des callbacks

						Tout d'abord, on doit dire à Doctrine que notre entité contient des callbacks de cycle de vie ; cela se définit grâce à l'annotationHasLifecycleCallbacksdans le namespace habituel des annotations Doctrine :

							<?php
							// src/OC/PlatformBundle/Entity/Advert.php

							namespace OC\PlatformBundle\Entity;

							use Doctrine\Common\Collections\ArrayCollection;
							use Doctrine\ORM\Mapping as ORM;

							/**
							 * @ORM\Entity(repositoryClass="OC\PlatformBundle\Entity\AdvertRepository")
							 * @ORM\HasLifecycleCallbacks()
							 */
							class Advert
							{
							  // …
							}
							
						Cette annotation permet à Doctrine de vérifier les callbacks éventuels contenus dans l'entité. Elle s'applique à la classe de l'entité, et non à un attribut particulier. Ne l'oubliez pas, car sinon vos différents callbacks seront tout simplement ignorés.

					2. Définir un callback et ses évènements associés

						Maintenant, il faut définir des méthodes et surtout, les évènements sur lesquels elles seront exécutées.

						Continuons dans notre exemple, et créons une méthodeupdateDate()dans l'entitéAdvert. Cette méthode doit définir l'attribut$updatedAt à la date actuelle, afin de mettre à jour automatiquement la date d'édition d'une annonce. Voici à quoi elle pourrait ressembler :

							<?php
							// src/OC/PlatformBundle/Entity/Advert.php

							namespace OC\PlatformBundle\Entity;

							/**
							 * @ORM\Entity(repositoryClass="OC\PlatformBundle\Entity\AdvertRepository")
							 * @ORM\HasLifecycleCallbacks()
							 */
							class Advert
							{
							  // …

							  public function updateDate()
							  {
								$this->setUpdatedAt(new \Datetime());
							  }
							}
							
						Maintenant il faut dire à Doctrine d'exécuter cette méthode (ce callback) dès que l'entitéAdvert est modifiée. On parle d'écouter un évènement. Il existe plusieurs évènements de cycle de vie avec Doctrine, celui qui nous intéresse ici est l'évènementPreUpdate: c'est-à-dire que la méthode va être exécutée juste avant que l'entité ne soit modifiée en base de données. Voici à quoi cela ressemble :

							<?php

							/**
							 * @ORM\PreUpdate
							 */
							public function updateDate()
							
						C'est tout !

						Vous pouvez dès à présent tester le comportement. Essayez de faire un petit code de test pour charger une annonce, la modifier, et l'enregistrer (avec unflush()), vous verrez que l'attribut$updatedAt va se mettre à jour automatiquement. Attention, l'évènement  updaten'est pas déclenché à la création d'une entité, mais seulement à sa modification : c'est parfaitement ce qu'on veut dans notre exemple.

						Pour aller plus loin, il y a deux points qu'il vous faut savoir. D'une part, au même titre que l'évènement  PreUpdate, il existe l'évènement  PostUpdate et bien d'autres, on en dresse une liste dans le tableau suivant. Le second point est que depuis la version 2.4 de Doctrine, le callback peut prendre en argument l'évènement déclencheur : il est possible d'accéder à l'entity manager et à l'unit of work pour effectuer des opérations courantes sur l'évènements. 
						
						Rendez-vous sur la documentation officielle de Doctrine pour en savoir un peu plus.
						
							http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/events.html#lifecycle-callbacks-event-argument

						Si vous utilisez une version antérieure à 2.4, pour exécuter des actions plus complexes lors d'évènements, il faut créer des services, on voit cela plus loin.
			
			
				Liste des évènements de cycle de vie

					Les différents évènements du cycle de vie sont récapitulés dans le tableau suivant.

			Évènement 
			  Description
			  
			PrePersist
				L'évènement PrePersist se produit juste avant que l'EntityManager ne persiste effectivement l'entité. Concrètement, cela exécute le callback juste avant un $em->persist($entity). Il ne concerne que les entités nouvellement créées. Du coup, il y a deux conséquences : d'une part, les modifications que vous apportez à l'entité seront persistées en base de données, puisqu'elles sont effectives avant que l'EntityManager n'enregistre l'entité en base. D'autre part, vous n'avez pas accès à l'id de l'entité si celui-ci est autogénéré, car justement l'entité n'est pas encore enregistrée en base de données, et donc l'id pas encore généré.
			
			PostPersist
				L'évènement postPersist se produit juste après que l'EntityManager ait effectivement persisté l'entité. Attention, cela n'exécute pas le callback juste après le $em->persist($entity), mais juste après le $em->flush(). À l'inverse du prePersist, les modifications que vous apportez à l'entité ne seront pas persistées en base (mais seront tout de même appliquées à l'entité, attention) ; mais vous avez par contre accès à l'id qui a été généré lors du flush().
			
			PreUpdate
				L'évènement preUpdate se produit juste avant que l'EntityManager ne modifie une entité. Par modifiée, j'entends que l'entité existait déjà, que vous y avez apporté des modifications, puis un $em->flush(). Le callback sera exécuté juste avant le flush(). Attention, il faut que vous ayez modifié au moins un attribut pour que l'EntityManager génère une requête et donc déclenche cet évènement.
				Vous avez accès à l'id autogénéré (car l'entité existe déjà), et vos modifications seront persistées en base de données.
			
			PostUpdate
				L'évènement postUpdate se produit juste après que l'EntityManager a effectivement modifié une entité. Vous avez accès à l'id et vos modifications ne sont pas persistées en base de données.
			
			PreRemove
				L'évènement PreRemove se produit juste avant que l'EntityManager ne supprime une entité, c'est-à-dire juste avant un $em->flush() qui précède un $em->remove($entite). Attention, soyez prudents dans cet évènement, si vous souhaitez supprimer des fichiers liés à l'entité par exemple, car à ce moment l'entité n'est pas encore effectivement supprimée, et la suppression peut être annulée en cas d'erreur dans une des opérations à effectuer dans le flush().
			
			PostRemove
				L'évènement PostRemove se produit juste après que l'EntityManager a effectivement supprimé une entité. Si vous n'avez plus accès à son id, c'est ici que vous pouvez effectuer une suppression de fichier associé par exemple.
			
			PostLoad
				L'évènement PostLoad se produit juste après que l'EntityManager a chargé une entité (ou après un $em->refresh()). Utile pour appliquer une action lors du chargement d'une entité.
			 

				Attention, ces évènements se produisent lorsque vous créez et modifiez vos entités en manipulant les objets. Ils ne sont pas déclenchés lorsque vous effectuez des requêtes DQL ou avec le QueryBuilder. En effet, ces requêtes peuvent toucher un grand nombre d'entités et il serait dangereux pour Doctrine de déclencher les évènements correspondants un à un.
			
			Un autre exemple d'utilisation

				Pour bien comprendre l'intérêt des évènements, je vous propose un deuxième exemple : un compteur de candidatures pour les annonces.

				L'idée est la suivante : nous avons un site très fréquenté, et un petit serveur. Au lieu de récupérer le nombre de candidatures par annonce de façon dynamique à l'aide d'une requêteCOUNT(*), on décide de rajouter un attributnbApplications à notre entitéAdvert. L'enjeu maintenant est de tenir cet attribut parfaitement à jour, et surtout très facilement.

				C'est là que les évènements interviennent. Si on réfléchit un peu, le processus est assez simple et systématique :

					À chaque création d'une candidature, on doit effectuer un+1au compteur contenu dans l'entitéAdvert liée ;
					
					À chaque suppression d'une candidature, on doit effectuer un-1au compteur contenu dans l'entité l'Advert liée.
					
				Ce genre de comportement, relativement simple et systématique, est typiquement ce que nous pouvons automatiser grâce aux évènements Doctrine.

				Les deux évènements qui nous intéressent ici sont donc la création et la suppression d'une candidature. Il s'agit des évènementsPrePersistetPreRemove de l'entitéApplication. Pourquoi ? Car les évènements*Updatesont déclenchés à la mise à jour d'une candidature, ce qui ne change pas notre compteur ici. Et les évènementsPost*sont déclenchés après la mise à jour effective de l'entité dans la base de données, du coup la mise à jour de notre compteur ne serait pas enregistrée.

				Tout d'abord, créons notre attribut$nbApplications dans l'entitéAdvert, ainsi que des méthodes pour incrémenter et décrémenter ce compteur (en plus du getter et du setter que je ne vous remets pas ici) :

					<?php
					// src/OC/PlatformBundle/Entity/Advert.php

					namespace OC\PlatformBundle\Entity;

					class Advert
					{
					  /**
					   * @ORM\Column(name="nb_applications", type="integer")
					   */
					  private $nbApplications = 0;

					  public function increaseApplication()
					  {
						$this->nbApplications++;
					  }

					  public function decreaseApplication()
					  {
						$this->nbApplications--;
					  }
					  
					  // ...
					}
				
				Mettre à jour la base.
				
				Ensuite, on doit définir deux callbacks dans l'entitéApplication pour mettre à jour le compteur de l'entitéAdvert liée. Notez bien que nos évènements concernent bien l'entitéApplication, et non l'entitéAdvert ! Voici comment on pourrait faire :

					<?php
					// src/OC/PlatformBundle/Entity/Application.php

					namespace OC\PlatformBundle\Entity;

					use Doctrine\ORM\Mapping as ORM;

					/**
					 * @ORM\Table(name="oc_application")
					 * @ORM\Entity(repositoryClass="OC\PlatformBundle\Entity\ApplicationRepository")
					 * @ORM\HasLifecycleCallbacks()
					 */
					class Application
					{
					  /**
					   * @ORM\PrePersist
					   */
					  public function increase()
					  {
						$this->getAdvert()->increaseApplication();
					  }

					  /**
					   * @ORM\PreRemove
					   */
					  public function decrease()
					  {
						$this->getAdvert()->decreaseApplication();
					  }

					  // ...
					}
			
					N'oubliez pas d'ajouter l'annotationHasLifecycleCallbacks() sur l'objetApplication.
			
				Cette solution est possible car nous avons une relation entre ces deux entitésApplication etAdvert, il est donc possible d'accéder à l'annonce depuis une candidature.

			Utiliser des services pour écouter les évènements Doctrine

				Les callbacks définis directement dans les entités sont pratiques car simple à mettre en place. Quelques petites annotations et le tour est joué. Cependant, leurs limites sont vite atteintes car, comme toute méthode au sein d'une entité, les callbacks n'ont accès à aucune information de l'extérieur.

				En effet, imaginez qu'on veuille mettre en place un système pour envoyer un email à chaque création d'une candidature. Dans ce cas, le code qui est exécuté à chaque création d'entité a besoin du service mailer afin d'envoyer des emails, or ce n'est pas possible depuis une entité.

				Heureusement, il est possible de dire à Doctrine d'exécuter des services Symfony pour chaque évènement du cycle de vie des entités. L'idée est vraiment la même, mais au lieu d'une méthode callback dans notre entité, on a un service défini hors de notre entité. La seule différence est la syntaxe bien sûr.

				Il y a tout de même un point qui diffère des callbacks, c'est que nos services seront exécutés pour un évènement (PostPersist par exemple) concernant toutes nos entités, et non attaché à une seule entité. Si vous voulez effectuer votre action seulement pour les entitésAdvert, il faut alors vérifier le type d'entité qui sera en argument de votre service. L'avantage est que du coup vous pouvez facilement effectuer une action commune à toutes vos entités.

				Avant de vous montrer la syntaxe, prenons le temps pour voir comment organiser nos services ici. La fonctionnalité que je vous propose est l'envoi d'un e-mail à chaque fois qu'une candidature est reçue. Dans cette phrase se cachent deux parties : d'une part l'envoi d'un e-mail, et d'autre part l'aspect systématique à chaque candidature reçue. Pour bien organiser notre code, nous allons donc faire deux services : l'un pour envoyer l'e-mail, et l'autre qui sera appelé par Doctrine, ce sera lui le callback à proprement parler. Pourquoi séparer ? Car l'envoi d'un e-mail de notification est quelque chose que nous voudrons peut-être appeler à un autre moment qu'un évènement Doctrine. Imaginons par exemple une fonctionnalité permettant de renvoyer cet e-mail après quelques jours sans réponse, les possibilités sont nombreuses. Dans tous les cas, nous avons bien deux missions distinctes, et donc deux services distincts.

				Voici donc d'abord ma proposition pour le service qui envoie les e-mails. Ce service dépend du service mailer, et la méthode en elle-même a besoin d'une instance deApplication  en argument.

					<?php
					// src/OC/PlatformBundle/Email/ApplicationMailer.php

					namespace OC\PlatformBundle\Email;

					use OC\PlatformBundle\Entity\Application;

					class ApplicationMailer
					{
					  /**
					   * @var \Swift_Mailer
					   */
					  private $mailer;

					  public function __construct(\Swift_Mailer $mailer)
					  {
						$this->mailer = $mailer;
					  }

					  public function sendNewNotification(Application $application)
					  {
						$message = new \Swift_Message(
						  'Nouvelle candidature',
						  'Vous avez reçu une nouvelle candidature.'
						);

						$message
						  ->addTo($application->getAdvert()->getAuthor()) // Ici bien sûr il faudrait un attribut "email", j'utilise "author" à la place
						  ->addFrom('admin@votresite.com')
						;

						$this->mailer->send($message);
					  }
					}

				Ainsi que sa configuration :

					# src/OC/PlatformBundle/Resources/config/services.yml

					services:
					  oc_platform.email.application_mailer:
						  class: OC\PlatformBundle\Email\ApplicationMailer
						  arguments:
							  - "@mailer"

				Le service contient une méthode, qui se contente d'envoyer un petit email à l'adresse contenue dans l'annonce liée à la candidature passée en argument. On pourrait également rajouter une méthode pour envoyer un e-mail de confirmation au candidat qui a créé la candidature, etc. Tout cela n'a en fait rien à voir avec notre sujet, les évènements Doctrine !
				
				Et le conteneur de service (si précédamment, le service créé s'est fait dans un autre Bundle)
					
					// src/OcPlatformBundle/DependencyInjection/OcPlatformBundleExtension.php

					namespace OcPlatformBundle\DependencyInjection;

					use Symfony\Component\DependencyInjection\ContainerBuilder;
					use Symfony\Component\Config\FileLocator;
					use Symfony\Component\HttpKernel\DependencyInjection\Extension;
					use Symfony\Component\DependencyInjection\Loader;

					class OcPlatformBundleExtension extends Extension
					{
						public function load(array $configs, ContainerBuilder $container)
						{
							// $configuration = new Configuration();
							// $config = $this->processConfiguration($configuration, $configs);

							$loader = new Loader\YamlFileLoader($container, new FileLocator(__DIR__.'/../Resources/config'));
							$loader->load('services.yml');
						}
					}
					
				
				Passons donc au vif du sujet, voici enfin le service callback, celui qui sera appelé par Doctrine lorsque les évènements configurés seront déclenchés.

					<?php
					// src/OC/PlatformBundle/DoctrineListener/ApplicationCreationListener.php

					namespace OC\PlatformBundle\DoctrineListener;

					use Doctrine\Common\Persistence\Event\LifecycleEventArgs;
					use OC\PlatformBundle\Email\ApplicationMailer;
					use OC\PlatformBundle\Entity\Application;

					class ApplicationCreationListener
					{
					  /**
					   * @var ApplicationMailer
					   */
					  private $applicationMailer;

					  public function __construct(ApplicationMailer $applicationMailer)
					  {
						$this->applicationMailer = $applicationMailer;
					  }

					  public function postPersist(LifecycleEventArgs $args)
					  {
						$entity = $args->getObject();

						// On ne veut envoyer un email que pour les entités Application
						if (!$entity instanceof Application) {
						  return;
						}

						$this->applicationMailer->sendNewNotification($entity);
					  }
					}

				Notez que j'ai nommé la méthode du service du nom de l'évènement que nous allons écouter. Nous ferons effectivement le lien avec l'évènement via la configuration du service, mais la méthode doit respecter le même nom que l'évènement.

				Ensuite, il y a deux points à retenir sur la syntaxe :

					Le seul argument qui est donné à votre méthode est un objet LifecycleEventArgs. Il offre deux méthodes : getObject et getObjectManager. La première, getObject, retourne l'entité sur laquelle l'évènement est en train de se produire. La seconde, getObjectManager, retourne l'EntityManager nécessaire pour persister ou supprimer de nouvelles entités que vous pourriez gérer, nous ne nous en servons pas ici ;
			
					Comme je l'avais mentionné, la méthode sera exécutée pour l'évènement PostPersist de toutes vos entités. Dans notre cas, comme souvent, nous ne voulons envoyer l'email que lorsqu'une entité en particulier est ajoutée, iciApplication. D'où le if pour vérifier le type d'entité auquel on a affaire. Si le callback est appelé sur une entité qui ne vous intéresse pas ici, sortez simplement de la méthode sans rien faire, c'est le rôle dureturn ligne 28.
			
				Maintenant que notre objet est prêt, il faut en faire un service et dire à Doctrine qu'il doit être exécuté pour tous les évènements PostPersist. Voici la syntaxe à respecter :

					# src/OC/PlatformBundle/Resources/config/services.yml

					services:
					  oc_platform.doctrine_listener.application_creation:
						class: OC\PlatformBundle\DoctrineListener\ApplicationCreationListener
						arguments:
						  - "@oc_platform.email.application_mailer"
						tags:
						  - { name: doctrine.event_listener, event: postPersist }

				La définition du service n'a rien de nouveau par rapport à ce que nous avons vu sur le chapitre dédié aux services.

				La nouveauté est par contre la section tag. Sachez simplement que c'est ce tag qui permet au conteneur de services de dire à Doctrine que ce service doit être exécuté pour les évènements PostPersist. Pas de panique, je vous explique en détail le fonctionnement des tags de services dans un chapitre de la prochaine partie, mais pour l'instant connaître cette syntaxe vous permet de les utiliser dans ce cadre.

				Bien entendu, vous pouvez écouter n'importe quel évènement avec cette syntaxe, il vous suffit de modifier l'attributevent: PostPersist du tag.
				
					
					tags:
						- { name: doctrine.event_listener, event: postPersist }
						- { name: doctrine.event_listener, event: preUpdate }
					
				ou
					
					<?php

					namespace Company\YourBundle\Listener;

					use Doctrine\Common\EventArgs;
					use Doctrine\Common\EventSubscriber;

					class YourListener implements EventSubscriber
					{
						public function getSubscribedEvents()
						{
							return array('prePersist', 'onFlush');
						}

						public function prePersist(EventArgs $args)
						{

						}

						public function onFlush(EventArgs $args)
						{

						}
					}
					

			Essayons nos évènements

				Si vous avez le même contrôleur que moi, l'actionaddAction enregistre une annonce ainsi que deux candidature en base de données. Vérifions donc que nos deux comportements fonctionnent bien : l'incrémentation d'un compteur de candidatures d'une part, et l'envoi d'e-mail d'autre part. Je vous invite donc à vous rendre sur la page /platform/add.

				Vous aurez sans doute cette erreur Address in mailbox given [Alexandre] does not comply with RFC 2822, 3.6.2, c'est parce que nous avons utilisé le nom au lieu de l'adresse e-mail pour envoyer l'e-mail justement. Si vous voulez la régler, c'est un bon exercice pour vous que de rajouter un attribut email et de l'utiliser dans notre service. Je ne le ferai pas ici.

				Voyons plutôt ce que cette erreur nous donne comme information, je vous reproduis une partie de la stack trace sur la figure suivante.

				Cette stack trace est intéressante car elle nous montre le cheminement complet pour arriver jusqu'à notre service d'envoi d'e-mail. On peut y constater que c'est à partir de notre flush depuis le contrôleur que Doctrine déclenche l'évènement postPersist, qui lui va appeler notre service comme convenu. Je vous montre cela car c'est un bon réflexe de bien lire la stack trace en cas d'erreur : en comprenant bien le cheminement des opérations, cela nous aide à comprendre et donc résoudre les erreurs.

				Nous venons donc de valider que notre envoi d'e-mail à la création d'une candidature est OK. Maintenant, vérifions le compteur de candidature. Pour cela, ouvrez le profiler sur l'onglet des requêtes SQL, je vous en reproduis un extrait sur la figure suivante.

				Je vous ai encadré en vert la valeur de notre attributnbApplicationssur l'annonce enregistrée en base de données. Sa valeur est de 2, ce qui est bien le nombre de candidatures que nous enregistrons en même temps : parfait !

					Notez également qu'à la fin de la transaction, Doctrine fait unROLLBACK et non unCOMMIT. Cela signifie qu'il annule toute la transaction, et donc l'enregistrement de notre annonce et de nos candidatures. Annuler toute la transaction parce qu'un e-mail de notification n'a pas pu être envoyé, ce n'est généralement pas le comportement souhaité. Pour éviter cela il faudrait, dans leApplicationCreationListener, rajouter un bloc try/catch afin d'intercepter l'exception de SwiftMailer, et ainsi ne pas annuler toute la transaction Doctrine. Pensez-y !
				
			
			Les extensions Doctrine
			
				L'intérêt des extensions Doctrine

					Dans la gestion des entités d'un projet, il y a des comportements assez communs que vous souhaiterez implémenter.

					Par exemple, il est très classique de vouloir générer des slugs pour nos annonces, pour des sujets d'un forum, etc. Un slug est une version simplifiée, compatible avec les URL, d'un autre attribut, souvent un titre. Par exemple le slug du titre "Recherche développeur !" serait "recherche-developpeur", notez que l'espace a été remplacé par un tiret, le point d'exclamation supprimé.

					Plutôt que de réinventer tout le comportement nous-mêmes, nous allons utiliser les extensions Doctrine ! Doctrine est en effet très flexible, et la communauté a déjà créé une série d'extensions très pratiques afin de vous aider avec les tâches usuelles liées aux entités. À l'image des évènements, utiliser ces extensions évite de se répéter au sein de votre application Symfony : c'est la philosophie DRY.

				Installer le StofDoctrineExtensionBundle

					Un bundle en particulier permet d'intégrer différentes extensions Doctrine dans un projet Symfony, il s'agit de StofDoctrineExtensionsBundle. Commençons par l'installer avec Composer, rajoutez cette dépendance dans votrecomposer.json  et exécutez uncomposer update :

						// composer.json

						"require": {
						  "stof/doctrine-extensions-bundle": "^1.2.2"
						}
						
					Ce bundle intègre la bibliothèque DoctrineExtensions sous-jacente, qui est celle qui inclut réellement les extensions Doctrine.

					N'oubliez pas d'enregistrer le bundle dans le noyau :

						<?php
						// app/AppKernel.php

						public function registerBundles()
						{
						  return array(
							// …
							new Stof\DoctrineExtensionsBundle\StofDoctrineExtensionsBundle(),
							// …
						  );
						}
						
					Voilà le bundle est installé, il faut maintenant activer telle ou telle extension.

				Utiliser une extension : l'exemple de Sluggable

					L'utilisation des différentes extensions est très simple grâce à la flexibilité de Doctrine et au bundle pour Symfony. Voici par exemple l'utilisation de l'extension Sluggable, qui permet de définir très facilement un attributslugdans une entité : le slug sera automatiquement généré !

					Tout d'abord, il faut activer l'extension Sluggable, il faut pour cela configurer le bundle via le fichier de configurationconfig.yml. Rajoutez donc cette section :

						# app/config/config.yml

						# Stof\DoctrineExtensionsBundle configuration
						stof_doctrine_extensions:
							orm:
								default:
									sluggable: true
									
					Cela va activer l'extension Sluggable. De la même manière, vous pourrez activer les autres extensions en les rajoutant à la suite.

					Concrètement, l'utilisation des extensions se fait grâce à de judicieuses annotations. Vous l'aurez deviné, pour l'extension Sluggable, l'annotation est tout simplementSlug. En l'occurrence, il faut ajouter un nouvel attributslug(le nom est arbitraire) dans votre entité, sur lequel nous mettrons l'annotation. Voici un exemple dans notre entitéAdvert :

						<?php
						// src/OC/PlatformBundle/Entity/Advert.php

						namespace OC\PlatformBundle\Entity;

						use Doctrine\ORM\Mapping as ORM;
						// N'oubliez pas ce use :
						use Gedmo\Mapping\Annotation as Gedmo;

						/**
						 * @ORM\Entity
						 */
						class Advert
						{
						  // …

						  /**
						   * @Gedmo\Slug(fields={"title"})
						   * @ORM\Column(name="slug", type="string", length=255, unique=true)
						   */
						  private $slug;

						  // …
						}
						
					Dans un premier temps, vous avez l'habitude, on utilise le namespace de l'annotation, iciGedmo\Mapping\Annotation.

					Ensuite, l'annotation Slug s'applique très simplement sur un attribut qui va contenir le slug. L'optionfieldspermet de définir le ou les attributs à partir desquels le slug sera généré : ici le titre uniquement. Mais vous pouvez en indiquer plusieurs en les séparant par des virgules.

						N'oubliez pas de mettre à jour votre base de données avec la commandedoctrine:schema:update, mais également de générer le getter et le setter du slug, grâce à la commandegenerate:doctrine:entities OCPlatformBundle:Advert.
						
					C'est tout ! Vous pouvez dès à présent tester le nouveau comportement de votre entité. Créez une entité avec un titre de test, et enregistrez-la : son attributslugsera automatiquement rempli ! Par exemple :

						<?php
						// Dans un contrôleur

						public function testAction()
						{
						  $advert = new Advert();
						  $advert->setTitle("Recherche développeur !");

						  $em = $this->getDoctrine()->getManager();
						  $em->persist($advert);
						  $em->flush(); // C'est à ce moment qu'est généré le slug

						  return new Response('Slug généré : '.$advert->getSlug());
						  // Affiche « Slug généré : recherche-developpeur »
						}

					L'attributslugest rempli automatiquement par le bundle. Ce dernier utilise en réalité tout simplement les évènements DoctrinePrePersistetPreUpdate, qui permettent d'intervenir juste avant l'enregistrement et la modification de l'entité comme on l'a vu plus haut.

						Vous avez pu remarquer que j'ai défini l'attributslugcomme unique (unique=truedans l'annotation Column). En effet, on se sert souvent du slug comme identifiant de l'entité, ici l'annonce, afin de l'utiliser dans les URL et améliorer le référencement. Sachez que l'extension est intelligente : si vous ajoutez un Advert avec un titre qui existe déjà, le slug sera suffixé de « -1 » pour garder l'unicité, par exemple « recherche-developpeur-1 ». Si vous ajoutez un troisième titre identique, alors le slug sera « recherche-developpeur-2 », etc.

					Vous savez maintenant utiliser l'extension Doctrine Sluggable ! Voyons les autres extensions disponibles.

				Liste des extensions Doctrine

					Voici la liste des principales extensions actuellement disponibles, ainsi que leur description et des liens vers la documentation pour vous permettre de les implémenter dans votre projet.

					Extension
						Description
					
					Tree
						L'extension Tree automatise la gestion des arbres et ajoute des méthodes spécifiques au repository. Les arbres sont une représentation d'entités avec des liens type parents-enfants, utiles pour les catégories d'un forum par exemple.
					
					Translatable
						L'extension Translatable offre une solution aisée pour traduire des attributs spécifiques de vos entités dans différents langages. De plus, elle charge automatiquement les traductions pour la locale courante.
					
					Sluggable
						L'extension Sluggable permet de générer automatiquement un slug à partir d'attributs spécifiés.
					
					Timestampable
						L'extension Timestampable automatise la mise à jour d'attributs de typedatedans vos entités. Vous pouvez définir la mise à jour d'un attribut à la création et/ou à la modification, ou même à la modification d'un attribut particulier. Vous l'aurez compris, cette extension fait exactement la même chose que ce qu'on a fait dans le paragraphe précédent sur les évènements Doctrine (mise à jour de la date à chaque modification), et en mieux !
					
					Blameable
						L'extension Blameable permet d'assigner l'utilisateur courant (l'entité elle-même, ou alors juste le nom d'utilisateur) dans un attribut d'une autre entité. Utile pour notre entitéAdvert par exemple, laquelle pourrait être reliée à un utilisateur.
					
					Loggable
						L'extension Loggable permet de conserver les différentes versions de vos entités, et offre des outils de gestion des versions.
					
					Sortable
						L'extension Sortable permet de gérer des entités ordonnées, c'est-à-dire avec un ordre précis.
					
					Softdeleteable
						L'extension SoftDeleteable permet de « soft-supprimer » des entités, c'est-à-dire de ne pas les supprimer réellement, juste mettre un de leurs attributs àtruepour les différencier. L'extension permet également de les filtrer lors des SELECT, pour ne pas utiliser des entités « soft-supprimées ».
					
					Uploadable
						L'extension Uploadable offre des outils pour gérer l'enregistrement de fichiers associés avec des entités. Elle inclut la gestion automatique des déplacements et des suppressions des fichiers.
					
					
					IpTraceable
						L'extension IpTraceable permet d'assigner l'ip de l'utilisateur courant à un attribut.
						Si vous n'avez pas besoin aujourd'hui de tous ces comportements, ayez-les en tête pour le jour où vous en trouverez l'utilité. Autant ne pas réinventer la roue si elle existe déjà ! ;)

			Pour conclure

				Ce chapitre touche à sa fin et marque la fin de la partie théorique sur Doctrine. Vous avez maintenant tous les outils pour gérer vos entités, et donc votre base de données. Surtout, n'hésitez pas à bien pratiquer, car c'est une partie qui implique de nombreuses notions : sans entraînement, pas de succès !

				Le prochain chapitre est un TP permettant de mettre en pratique la plupart des notions abordées dans cette partie.

			En résumé

				Les évènements permettent de centraliser du code répétitif, afin de systématiser leur exécution et de réduire la duplication de code.
				Plusieurs évènements jalonnent la vie d'une entité, afin de pouvoir exécuter une fonction aux endroits désirés.
				Les extensions permettent de reproduire des comportements communs dans une application, afin d'éviter de réinventer la roue.
				Le code du cours tel qu'il doit être à ce stade est disponible sur la branche iteration-12 du dépot Github.
		
				
				
		6. TP : Consolidation de notre code
		
			
			Lien
				
				- https://insight.sensiolabs.com
			
			
			Synthèse des entités
			
				Pour être sûr de partir sur les mêmes bases, je vous remets ici le code complet de toutes nos entités. Nous les avons déjà construites au cours de cette partie, mais cela vous permet de vérifier que vous avez le bon code pour chacune d'entre elles.

				EntitéAdvert

					On a déjà pas mal traité l'entitéAdvert au cours de cette partie. Pour l'instant, on a toujours le nom de l'auteur écrit en dur dans l'entité. Souvenez-vous, pour commencer, on n'a pas d'entitéUser (elle sera créée durant la prochaine partie) on doit donc écrire le nom de l'auteur en dur dans les annonces.

					Voici donc la version finale de l'entitéAdvert que vous devriez avoir :

						<?php

						namespace OC\PlatformBundle\Entity;

						use Doctrine\Common\Collections\ArrayCollection;
						use Doctrine\ORM\Mapping as ORM;
						// N'oubliez pas ce use :
						use Gedmo\Mapping\Annotation as Gedmo;

						/**
						 * @ORM\Table(name="oc_advert")
						 * @ORM\Entity(repositoryClass="OC\PlatformBundle\Repository\AdvertRepository")
						 * @ORM\HasLifecycleCallbacks()
						 */
						class Advert
						{
						  /**
						   * @ORM\Column(name="id", type="integer")
						   * @ORM\Id
						   * @ORM\GeneratedValue(strategy="AUTO")
						   */
						  private $id;

						  /**
						   * @ORM\Column(name="date", type="datetime")
						   */
						  private $date;

						  /**
						   * @ORM\Column(name="title", type="string", length=255)
						   */
						  private $title;

						  /**
						   * @ORM\Column(name="author", type="string", length=255)
						   */
						  private $author;

						  /**
						   * @ORM\Column(name="content", type="string", length=255)
						   */
						  private $content;

						  /**
						   * @ORM\Column(name="published", type="boolean")
						   */
						  private $published = true;

						  /**
						   * @ORM\OneToOne(targetEntity="OC\PlatformBundle\Entity\Image", cascade={"persist"})
						   */
						  private $image;

						  /**
						   * @ORM\ManyToMany(targetEntity="OC\PlatformBundle\Entity\Category", cascade={"persist"})
						   * @ORM\JoinTable(name="oc_advert_category")
						   */
						  private $categories;

						  /**
						   * @ORM\OneToMany(targetEntity="OC\PlatformBundle\Entity\Application", mappedBy="advert")
						   */
						  private $applications; // Notez le « s », une annonce est liée à plusieurs candidatures

						  /**
						   * @ORM\Column(name="updated_at", type="datetime", nullable=true)
						   */
						  private $updatedAt;

						  /**
						   * @ORM\Column(name="nb_applications", type="integer")
						   */
						  private $nbApplications = 0;

						  /**
						   * @Gedmo\Slug(fields={"title"})
						   * @ORM\Column(name="slug", type="string", length=255, unique=true)
						   */
						  private $slug;

						  public function __construct()
						  {
							$this->date         = new \Datetime();
							$this->categories   = new ArrayCollection();
							$this->applications = new ArrayCollection();
						  }

						  /**
						   * @ORM\PreUpdate
						   */
						  public function updateDate()
						  {
							$this->setUpdatedAt(new \Datetime());
						  }

						  public function increaseApplication()
						  {
							$this->nbApplications++;
						  }

						  public function decreaseApplication()
						  {
							$this->nbApplications--;
						  }

						  /**
						   * @return int
						   */
						  public function getId()
						  {
							return $this->id;
						  }

						  /**
						   * @param \DateTime $date
						   */
						  public function setDate($date)
						  {
							$this->date = $date;
						  }

						  /**
						   * @return \DateTime
						   */
						  public function getDate()
						  {
							return $this->date;
						  }

						  /**
						   * @param string $title
						   */
						  public function setTitle($title)
						  {
							$this->title = $title;
						  }

						  /**
						   * @return string
						   */
						  public function getTitle()
						  {
							return $this->title;
						  }

						  /**
						   * @param string $author
						   */
						  public function setAuthor($author)
						  {
							$this->author = $author;
						  }

						  /**
						   * @return string
						   */
						  public function getAuthor()
						  {
							return $this->author;
						  }

						  /**
						   * @param string $content
						   */
						  public function setContent($content)
						  {
							$this->content = $content;
						  }

						  /**
						   * @return string
						   */
						  public function getContent()
						  {
							return $this->content;
						  }

						  /**
						   * @param bool $published
						   */
						  public function setPublished($published)
						  {
							$this->published = $published;
						  }

						  /**
						   * @return bool
						   */
						  public function getPublished()
						  {
							return $this->published;
						  }

						  public function setImage(Image $image = null)
						  {
							$this->image = $image;
						  }

						  public function getImage()
						  {
							return $this->image;
						  }

						  /**
						   * @param Category $category
						   */
						  public function addCategory(Category $category)
						  {
							$this->categories[] = $category;
						  }

						  /**
						   * @param Category $category
						   */
						  public function removeCategory(Category $category)
						  {
							$this->categories->removeElement($category);
						  }

						  /**
						   * @return ArrayCollection
						   */
						  public function getCategories()
						  {
							return $this->categories;
						  }

						  /**
						   * @param Application $application
						   */
						  public function addApplication(Application $application)
						  {
							$this->applications[] = $application;

							// On lie l'annonce à la candidature
							$application->setAdvert($this);
						  }

						  /**
						   * @param Application $application
						   */
						  public function removeApplication(Application $application)
						  {
							$this->applications->removeElement($application);
						  }

						  /**
						   * @return \Doctrine\Common\Collections\Collection
						   */
						  public function getApplications()
						  {
							return $this->applications;
						  }

						  /**
						   * @param \DateTime $updatedAt
						   */
						  public function setUpdatedAt(\Datetime $updatedAt = null)
						  {
							  $this->updatedAt = $updatedAt;
						  }

						  /**
						   * @return \DateTime
						   */
						  public function getUpdatedAt()
						  {
							  return $this->updatedAt;
						  }

						  /**
						   * @param integer $nbApplications
						   */
						  public function setNbApplications($nbApplications)
						  {
							  $this->nbApplications = $nbApplications;
						  }

						  /**
						   * @return integer
						   */
						  public function getNbApplications()
						  {
							  return $this->nbApplications;
						  }

						  /**
						   * @param string $slug
						   */
						  public function setSlug($slug)
						  {
							  $this->slug = $slug;
						  }

						  /**
						   * @return string
						   */
						  public function getSlug()
						  {
							  return $this->slug;
						  }
						}

					EntitéImage

						L'entitéImageest une entité très simple, qui nous servira par la suite pour l'upload d'images avec Symfony. Sa particularité est qu'elle peut être liée à n'importe quelle autre entité : elle n'est pas du tout exclusive à l'entitéAdvert. Si vous souhaitez ajouter des images ailleurs que dans desAdvert, il n'y aura aucun problème.

						Voici son code, que vous devriez déjà avoir :

							<?php
							// src/OC/PlatformBundle/Entity/Image.php

							namespace OC\PlatformBundle\Entity;

							use Doctrine\ORM\Mapping as ORM;

							/**
							 * @ORM\Table(name="oc_image")
							 * @ORM\Entity
							 */
							class Image
							{
							  /**
							   * @ORM\Column(name="id", type="integer")
							   * @ORM\Id
							   * @ORM\GeneratedValue(strategy="AUTO")
							   */
							  private $id;

							  /**
							   * @ORM\Column(name="url", type="string", length=255)
							   */
							  private $url;

							  /**
							   * @ORM\Column(name="alt", type="string", length=255)
							   */
							  private $alt;
							  
							  // Getters et setters
							}
							
							
						EntitéApplication

							L'entitéApplication contient la relation avec l'entitéAdvert, c'est elle la propriétaire. Voici son code :

							<?php
							// src/OC/PlatformBundle/Entity/Application.php

							namespace OC\PlatformBundle\Entity;

							use Doctrine\ORM\Mapping as ORM;

							/**
							 * @ORM\Table(name="oc_application")
							 * @ORM\Entity(repositoryClass="OC\PlatformBundle\Repository\ApplicationRepository")
							 * @ORM\HasLifecycleCallbacks()
							 */
							class Application
							{
							  /**
							   * @ORM\Column(name="id", type="integer")
							   * @ORM\Id
							   * @ORM\GeneratedValue(strategy="AUTO")
							   */
							  private $id;

							  /**
							   * @ORM\Column(name="author", type="string", length=255)
							   */
							  private $author;

							  /**
							   * @ORM\Column(name="content", type="text")
							   */
							  private $content;

							  /**
							   * @ORM\Column(name="date", type="datetime")
							   */
							  private $date;

							  /**
							   * @ORM\ManyToOne(targetEntity="OC\PlatformBundle\Entity\Advert", inversedBy="applications")
							   * @ORM\JoinColumn(nullable=false)
							   */
							  private $advert;

							  public function __construct()
							  {
								$this->date = new \Datetime();
							  }

							  /**
							   * @ORM\PrePersist
							   */
							  public function increase()
							  {
								$this->getAdvert()->increaseApplication();
							  }

							  /**
							   * @ORM\PreRemove
							   */
							  public function decrease()
							  {
								$this->getAdvert()->decreaseApplication();
							  }

							  /**
							   * @return int
							   */
							  public function getId()
							  {
								return $this->id;
							  }

							  /**
							   * @param string $author
							   */
							  public function setAuthor($author)
							  {
								$this->author = $author;
							  }

							  /**
							   * @return string
							   */
							  public function getAuthor()
							  {
								return $this->author;
							  }

							  /**
							   * @param string $content
							   */
							  public function setContent($content)
							  {
								$this->content = $content;
							  }

							  /**
							   * @return string
							   */
							  public function getContent()
							  {
								return $this->content;
							  }

							  /**
							   * @param \Datetime $date
							   */
							  public function setDate(\Datetime $date)
							  {
								$this->date = $date;
							  }

							  /**
							   * @return \Datetime
							   */
							  public function getDate()
							  {
								return $this->date;
							  }

							  /**
							   * @param Advert $advert
							   */
							  public function setAdvert(Advert $advert)
							  {
								$this->advert = $advert;
							  }

							  /**
							   * @return Advert
							   */
							  public function getAdvert()
							  {
								return $this->advert;
							  }
							}

					EntitéCategory

						L'entitéCategory ne contient qu'un attributnom(enfin, vous pouvez en rajouter de votre côté bien sûr !). La relation avecAdvert est contenue dans l'entitéAdvert, qui en est la propriétaire. Voici son code, que vous devriez déjà avoir :

							<?php
							// src/OC/PlatformBundle/Entity/Category.php

							namespace OC\PlatformBundle\Entity;

							use Doctrine\ORM\Mapping as ORM;

							/**
							 * @ORM\Entity
							 */
							class Category
							{
							  /**
							   * @ORM\Column(name="id", type="integer")
							   * @ORM\Id
							   * @ORM\GeneratedValue(strategy="AUTO")
							   */
							  private $id;

							  /**
							   * @ORM\Column(name="name", type="string", length=255)
							   */
							  private $name;

							  // Getters et setters
							}
							
					EntitésSkill etAdvertSkill

							L'entitéSkill ne contient, au même titre que l'entitéCategory, qu'un attributnom, mais vous pouvez bien sûr en rajouter selon vos besoins. Voici son code :

							<?php
							// src/OC/PlatformBundle/Entity/Skill.php

							namespace OC\PlatformBundle\Entity;

							use Doctrine\ORM\Mapping as ORM;

							/**
							 * @ORM\Entity(repositoryClass="OC\PlatformBundle\Entity\SkillRepository")
							 */
							class Skill
							{
							  /**
							   * @ORM\Column(name="id", type="integer")
							   * @ORM\Id
							   * @ORM\GeneratedValue(strategy="AUTO")
							   */
							  private $id;

							  /**
							   * @ORM\Column(name="name", type="string", length=255)
							   */
							  private $name;
							  
							  // Getters et setters
							}
							
						L'entitéAdvertSkill est l'entité de relation entreAdvert etSkill. Elle contient les attributs$advert et$skill qui permettent de faire la relation, ainsi que d'autres attributs pour caractériser la relation, ici j'ai utilisé un attribut$level. Voici son code, vous pouvez bien entendu rajouter les attributs de relation que vous souhaitez :

							<?php
							// src/OC/PlatformBundle/Entity/AdvertSkill.php

							namespace OC\PlatformBundle\Entity;

							use Doctrine\ORM\Mapping as ORM;

							/**
							 * @ORM\Entity
							 * @ORM\Table(name="oc_advert_skill")
							 */
							class AdvertSkill
							{
							  /**
							   * @ORM\Column(name="id", type="integer")
							   * @ORM\Id
							   * @ORM\GeneratedValue(strategy="AUTO")
							   */
							  private $id;

							  /**
							   * @ORM\Column(name="level", type="string", length=255)
							   */
							  private $level;

							  /**
							   * @ORM\ManyToOne(targetEntity="OC\PlatformBundle\Entity\Advert")
							   * @ORM\JoinColumn(nullable=false)
							   */
							  private $advert;

							  /**
							   * @ORM\ManyToOne(targetEntity="OC\PlatformBundle\Entity\Skill")
							   * @ORM\JoinColumn(nullable=false)
							   */
							  private $skill;

							  // ... vous pouvez ajouter d'autres attributs bien sûr

							  /**
							   * @return integer
							   */
							  public function getId()
							  {
								return $this->id;
							  }

							  /**
							   * @param string $level
							   */
							  public function setLevel($level)
							  {
								$this->level = $level;
							  }

							  /**
							   * @return string
							   */
							  public function getLevel()
							  {
								return $this->level;
							  }

							  /**
							   * @param Advert $advert
							   */
							  public function setAdvert(Advert $advert)
							  {
								$this->advert = $advert;
							  }

							  /**
							   * @return Advert
							   */
							  public function getAdvert()
							  {
								return $this->advert;
							  }

							  /**
							   * @param Skill $skill
							   */
							  public function setSkill(Skill $skill)
							  {
								$this->skill = $skill;
							  }

							  /**
							   * @return Skill
							   */
							  public function getSkill()
							  {
								return $this->skill;
							  }
							}

						Et bien sûr…

						Si vous avez ajouté et/ou modifié des entités, n'oubliez pas de mettre à jour votre base de données ! Vérifiez les requêtes avec php bin/console doctrine:schema:update --dump-sql, puis exécutez-les avec --force.


			Adaptation du contrôleur
			
				Théorie

					Maintenant que l'on a nos entités, on va enfin pouvoir adapter notre contrôleurAdvert pour qu'il récupère et modifie des vraies annonces dans la base de données, et non plus nos annonces statiques définies à la partie précédentes pour nos tests. On l'a déjà fait pour quelques actions, mais il en reste, et c'est notre travail pour ce chapitre.

					Pour cela, il y a très peu de modifications à réaliser : voici encore un exemple du code découplé que Symfony nous permet de réaliser ! En effet, il vous suffit de modifier les quelques endroits où on avait écrit une annonce en dur dans le contrôleur. Modifiez ces endroits en utilisant bien le repository de l'entitéAdvert pour récupérer l'annonce, seules les méthodesfindAll()etfind()vont nous servir pour le moment.

					Attention, je vous demande également de faire attention au cas où l'annonce demandée n'existe pas. Si on essaie d'aller à la page/platform/advert/4alors que l'annonce d'id 4 n'existe pas, je veux une erreur correctement gérée ! ;) On a déjà vu le déclenchement d'une erreur 404 lorsque le paramètrepagede la page d'accueil n'était pas valide, reprenez ce comportement.

					À la fin, le contrôleur ne sera pas entièrement opérationnel, car il nous manque toujours la gestion des formulaires. Mais il sera déjà mieux avancé !

					Et bien sûr, n'hésitez pas à nettoyer tous les codes de tests qu'on a pu utiliser lors de cette partie pour jouer avec les entités, maintenant on doit avoir un vrai contrôleur qui ne fait que son rôle.

				Pratique

					Vous avez fini de réécrire le contrôleur ? Bien, passons à la correction.

					L'idée ici était juste de transformer les annonces écrites en dur, en des appels de fonctions pour effectivement récupérer les annonces depuis la base de données.

					Il y a deux cas :

						Des fois, on ne voulait récupérer qu'une seule annonce, c'est le cas des pages de modification ou de suppression d'une annonce par exemple. Dans ce cas, c'est la méthode find du repository Advert qu'il fallait utiliser ;
						
						Des fois, on voulait récupérer toute une liste d'annonces, c'est le cas des pages d'accueil et du menu par exemple. Dans ce cas, c'est la méthode findAll qu'il fallait utiliser.

					Voici le code que j'obtiens :

						<?php

						// src/OC/PlatformBundle/Controller/AdvertController.php

						namespace OC\PlatformBundle\Controller;

						use OC\PlatformBundle\Entity\Advert;
						use Symfony\Bundle\FrameworkBundle\Controller\Controller;
						use Symfony\Component\HttpFoundation\Request;
						use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;

						class AdvertController extends Controller
						{
						  public function indexAction($page)
						  {
							if ($page < 1) {
							  throw new NotFoundHttpException('Page "'.$page.'" inexistante.');
							}

							// Pour récupérer la liste de toutes les annonces : on utilise findAll()
							$listAdverts = $this->getDoctrine()
							  ->getManager()
							  ->getRepository('OCPlatformBundle:Advert')
							  ->findAll()
							;

							// L'appel de la vue ne change pas
							return $this->render('OCPlatformBundle:Advert:index.html.twig', array(
							  'listAdverts' => $listAdverts,
							));
						  }

						  public function viewAction($id)
						  {
							$em = $this->getDoctrine()->getManager();

							// Pour récupérer une seule annonce, on utilise la méthode find($id)
							$advert = $em->getRepository('OCPlatformBundle:Advert')->find($id);

							// $advert est donc une instance de OC\PlatformBundle\Entity\Advert
							// ou null si l'id $id n'existe pas, d'où ce if :
							if (null === $advert) {
							  throw new NotFoundHttpException("L'annonce d'id ".$id." n'existe pas.");
							}

							// Récupération de la liste des candidatures de l'annonce
							$listApplications = $em
							  ->getRepository('OCPlatformBundle:Application')
							  ->findBy(array('advert' => $advert))
							;

							// Récupération des AdvertSkill de l'annonce
							$listAdvertSkills = $em
							  ->getRepository('OCPlatformBundle:AdvertSkill')
							  ->findBy(array('advert' => $advert))
							;

							return $this->render('OCPlatformBundle:Advert:view.html.twig', array(
							  'advert'           => $advert,
							  'listApplications' => $listApplications,
							  'listAdvertSkills' => $listAdvertSkills,
							));
						  }

						  public function addAction(Request $request)
						  {
							$em = $this->getDoctrine()->getManager();

							// On ne sait toujours pas gérer le formulaire, patience cela vient dans la prochaine partie !

							if ($request->isMethod('POST')) {
							  $request->getSession()->getFlashBag()->add('notice', 'Annonce bien enregistrée.');

							  return $this->redirectToRoute('oc_platform_view', array('id' => $advert->getId()));
							}

							return $this->render('OCPlatformBundle:Advert:add.html.twig');
						  }

						  public function editAction($id, Request $request)
						  {
							$em = $this->getDoctrine()->getManager();

							$advert = $em->getRepository('OCPlatformBundle:Advert')->find($id);

							if (null === $advert) {
							  throw new NotFoundHttpException("L'annonce d'id ".$id." n'existe pas.");
							}

							// Ici encore, il faudra mettre la gestion du formulaire

							if ($request->isMethod('POST')) {
							  $request->getSession()->getFlashBag()->add('notice', 'Annonce bien modifiée.');

							  return $this->redirectToRoute('oc_platform_view', array('id' => $advert->getId()));
							}

							return $this->render('OCPlatformBundle:Advert:edit.html.twig', array(
							  'advert' => $advert
							));
						  }

						  public function deleteAction($id)
						  {
							$em = $this->getDoctrine()->getManager();

							$advert = $em->getRepository('OCPlatformBundle:Advert')->find($id);

							if (null === $advert) {
							  throw new NotFoundHttpException("L'annonce d'id ".$id." n'existe pas.");
							}

							// On boucle sur les catégories de l'annonce pour les supprimer
							foreach ($advert->getCategories() as $category) {
							  $advert->removeCategory($category);
							}

							$em->flush();
							
							return $this->render('OCPlatformBundle:Advert:delete.html.twig');
						  }

						  public function menuAction($limit)
						  {
							$em = $this->getDoctrine()->getManager();

							$listAdverts = $em->getRepository('OCPlatformBundle:Advert')->findBy(
							  array(),                 // Pas de critère
							  array('date' => 'desc'), // On trie par date décroissante
							  $limit,                  // On sélectionne $limit annonces
							  0                        // À partir du premier
							);

							return $this->render('OCPlatformBundle:Advert:menu.html.twig', array(
							  'listAdverts' => $listAdverts
							));
						  }
						}
						
						
			Utilisation des jointures
				
				Actuellement sur la page d'accueil, avec l'actionindexAction(), on ne récupère que les annonces en elles-mêmes. Comme on en a parlé dans les précédents chapitres, cela veut dire que dans la boucle pour afficher les annonces, on ne peut pas utiliser les informations sur les relations (dans notre cas, les attributs$image,$categorieset$applications). Enfin, on peut bien entendu les utiliser via$advert->getImage(), etc., mais dans ce cas, une requête sera générée pour aller récupérée l'image… à chaque itération de la boucle sur les annonces dans la vue !

				Ce comportement est bien sûr à proscrire, car le nombre de requêtes SQL va monter en flèche et ce n'est pas bon du tout pour les performances. Il faut donc modifier la requête initiale qui récupère les annonces, pour y rajouter des jointures qui vont récupérer en une seule requête les annonces ainsi que leurs entités jointes.

				Tout d'abord, on va créer une méthodegetAdverts()dans le repository de l'entitéAdvert, une version toute simple qui ne fait que récupérer les entités triées par date :

					<?php
					// src/OC/PlatformBundle/Entity/AdvertRepository.php

					namespace OC\PlatformBundle\Entity;

					use Doctrine\ORM\EntityRepository;

					class AdvertRepository extends EntityRepository
					{
					  public function getAdverts()
					  {
						$query = $this->createQueryBuilder('a')
						  ->orderBy('a.date', 'DESC')
						  ->getQuery()
						;

						return $query->getResult();
					  }
					}
					
					Adaptons ensuite le contrôleur pour utiliser cette nouvelle méthode :

					<?php
					// src/OC/PlatformBundle/Controller/AdvertController.php

					// Dans indexAction, on utilise maintenant getAdverts et non plus findAll :
					$listAdverts = $this->getDoctrine()
					  ->getManager()
					  ->getRepository('OCPlatformBundle:Advert')
					  ->getAdverts()
					;
					
				Maintenant, il nous faut mettre en place les jointures dans la méthodegetAdverts(), afin de charger toutes les informations sur les annonces et éviter les dizaines de requêtes supplémentaires.

				Dans notre exemple, nous allons afficher les données de l'entitéimageet des entitéscategory liées à chaque annonce. Il nous faut donc rajouter les jointures sur ces deux entités. On a déjà vu comment faire ces jointures, essayez donc de reproduire le même comportement dans notre méthode getAdvert de votre côté avant de lire la correction suivante :

					<?php
					// src/OC/PlatformBundle/Entity/AdvertRepository.php

					namespace OC\PlatformBundle\Entity;

					use Doctrine\ORM\EntityRepository;

					class AdvertRepository extends EntityRepository
					{
					  public function getAdverts()
					  {
						$query = $this->createQueryBuilder('a')
						  // Jointure sur l'attribut image
						  ->leftJoin('a.image', 'i')
						  ->addSelect('i')
						  // Jointure sur l'attribut categories
						  ->leftJoin('a.categories', 'c')
						  ->addSelect('c')
						  ->orderBy('a.date', 'DESC')
						  ->getQuery()
						;

						return $query->getResult();
					  }
					}
					
				Comme vous pouvez le voir, les jointures se font simplement en utilisant les attributs existants de l'entité racine, ici l'entitéAdvert. On rajoute donc juste lesleftJoin(), ainsi que lesaddSelect() afin que Doctrine n'oublie pas de sélectionner les données qu'il joint. C'est tout ! Vous pouvez maintenant utiliser un$advert->getImage() dans la boucle de la vueindex.html.twig sans déclencher de nouvelle requête.

				Soit dit en passant, ces jointures peuvent justifier la mise en place d'une relation bidirectionnelle. En effet, dans l'état actuel, on ne peut pas récupérer les informations des compétences requises par une annonce par exemple, car l'entitéAdvert n'a pas d'attributAdvertSkill, donc pas de->leftJoin()possible ! C'est l'entitéAdvertSkill qui est propriétaire de la relation unidirectionnelle. Si vous voulez afficher les compétences, vous devez commencer par rendre la relation bidirectionnelle. N'hésitez pas à le faire, c'est un bon entraînement !


		Pagination des annonces sur la page d'accueil
		
			Paginer manuellement les résultats d'une requête n'est pas trop compliqué, il faut juste faire un peu de mathématiques à l'aide des variables suivantes :

				Nombre total d'annonces ;
				Nombre d'annonces à afficher par page ;
				La page courante.
				
			Cependant, c'est un comportement assez classique et en bon développeurs que nous sommes, trouvons une méthode plus simple et déjà prête ! Il existe en effet un paginateur intégré dans Doctrine, qui permet de faire tout cela très simplement.

			Le paginateur est un objet, auquel on passe notre requête Doctrine, qui va faire tout le nécessaire pour récupérer comme il se faut nos annonces et leurs entités liées. Il vient se substituer au$query->getResults() qu'on a l'habitude d'utiliser.

			Regardez comment l'intégrer dans notre méthodegetAdverts(). Faite attention, j'ai ajouté deux arguments à la méthode, car on a besoin de la page actuelle ainsi que du nombre d'annonces par page pour savoir quelles annonces récupérer exactement.

				<?php
				// src/OC/PlatformBundle/Entity/AdvertRepository.php

				namespace OC\PlatformBundle\Entity;

				use Doctrine\ORM\EntityRepository;
				use Doctrine\ORM\Tools\Pagination\Paginator;

				class AdvertRepository extends EntityRepository
				{
				  public function getAdverts($page, $nbPerPage)
				  {
					$query = $this->createQueryBuilder('a')
					  ->leftJoin('a.image', 'i')
					  ->addSelect('i')
					  ->leftJoin('a.categories', 'c')
					  ->addSelect('c')
					  ->orderBy('a.date', 'DESC')
					  ->getQuery()
					;

					$query
					  // On définit l'annonce à partir de laquelle commencer la liste
					  ->setFirstResult(($page-1) * $nbPerPage)
					  // Ainsi que le nombre d'annonce à afficher sur une page
					  ->setMaxResults($nbPerPage);

					// Enfin, on retourne l'objet Paginator correspondant à la requête construite
					// (n'oubliez pas le use correspondant en début de fichier)
					return new Paginator($query, true);
				  }
				}
				
			Ce que retourne cet objetPaginator, c'est une liste de$nbPerPage annonces, qui s'utilise comme n'importe quel tableau habituel (vous pouvez faire une boucle dessus notamment).

			La seule petite subtilité c'est que si vous faites un count dessus, vous n'obtenez pas $nbPerPage, mais le nombre total d'annonces présentes en base de données. Cette information est indispensable pour calculer le nombre total de pages.

			Vous avez maintenant toutes les informations nécessaire pour adapter le contrôleur. L'idée est de correctement utiliser notre méthode getAdverts, et de retourner une erreur 404 si la page demandée n'existe pas. Vous devez également modifier la vue pour afficher une liste de toutes les pages disponible, veillez bien à lui donner toutes les informations nécessaires depuis le contrôleur.


				Au travail ! Encore une fois, faites l'effort de la réaliser de votre côté. Évidemment, je vous donne la solution, mais si vous n'avez pas essayé de chercher, vous ne progresserez pas. Courage !


			Il existe bien entendu différentes manières de le faire, mais voici le code du contrôleur que je vous propose :

				<?php
				// src/OC/PlatformBundle/Controller/AdvertController.php

				namespace OC\PlatformBundle\Controller;

				use Symfony\Bundle\FrameworkBundle\Controller\Controller;

				class AdvertController extends Controller
				{
				  public function indexAction($page)
				  {
					if ($page < 1) {
					  throw $this->createNotFoundException("La page ".$page." n'existe pas.");
					}

					// Ici je fixe le nombre d'annonces par page à 3
					// Mais bien sûr il faudrait utiliser un paramètre, et y accéder via $this->container->getParameter('nb_per_page')
					$nbPerPage = 3;

					// On récupère notre objet Paginator
					$listAdverts = $this->getDoctrine()
					  ->getManager()
					  ->getRepository('OCPlatformBundle:Advert')
					  ->getAdverts($page, $nbPerPage)
					;

					// On calcule le nombre total de pages grâce au count($listAdverts) qui retourne le nombre total d'annonces
					$nbPages = ceil(count($listAdverts) / $nbPerPage);

					// Si la page n'existe pas, on retourne une 404
					if ($page > $nbPages) {
					  throw $this->createNotFoundException("La page ".$page." n'existe pas.");
					}

					// On donne toutes les informations nécessaires à la vue
					return $this->render('OCPlatformBundle:Advert:index.html.twig', array(
					  'listAdverts' => $listAdverts,
					  'nbPages'     => $nbPages,
					  'page'        => $page,
					));
				  }
				}
				
			C'est tout ! En effet, rappelez-vous l'architecture MVC, toute la logique de récupération des données est dans la couche Modèle : ici notre repository. Notre contrôleur est donc réduit à son strict minimum ; la couche Modèle, grâce à un Doctrine généreux en fonctionnalités, fait tout le travail.

			Attention à une petite subtilité. Ici, la variable$listAdverts contient une instance dePaginator. Concrètement, c'est une liste d'annonces. Vous pouvez l'utiliser avec un simpleforeachpar exemple (d'ailleurs vous pouvez essayer ce code sans changer la vue : cela fonctionne bien). Cependant, pour obtenir le nombre de pages vous voyez qu'on a utilisé uncount($listAdverts): cecountne retourne pas 5, mais le nombre total d'annonces dans la base de données ! Cela est possible avec les objets qui implémentent l'interfaceCountablede PHP.
			
			Nous avons utilisé l'objet Paginator, car en réalité la pagination ne peut se faire en utilisant simplement la méthode setMaxResults. En effet, cette méthode ne fait qu'appliquer un LIMIT à la requête SQL générée. Or, si cela ne pose aucun problème lors d'une requête simple, ce n'est pas le cas pour une requête avec jointures. Rappelez-vous ce que retourne une requête SQL pur sur 3 annonces avec une jointure sur 5 candidatures chacune : 15 lignes ! Or, si vous faites un LIMIT 3, vous n'obtiendrez pas les 3 annonces, mais simplement la 1ere annonce avec ses 3 premières candidatures. C'est pourquoi ce n'est pas aussi simple, vous pouvez regarder les requêtes générées par le Paginator pour comprendre comment il esquive ce problème.
			
			Enfin, il vous restait l'affichage de la liste des pages possible à ajouter, voici ce que je peux vous proposer :

				{# src/OC/PlatformBundle/Resources/views/Advert/index.html.twig #}

				{% extends "OCPlatformBundle::layout.html.twig" %}

				{# ... #}

				<ul class="pagination">
				  {# On utilise la fonction range(a, b) qui crée un tableau de valeurs entre a et b #}
				  {% for p in range(1, nbPages) %}
					<li{% if p == page %} class="active"{% endif %}>
					  <a href="{{ path('oc_platform_home', {'page': p}) }}">{{ p }}</a>
					</li>
				  {% endfor %}
				</ul>
				
			Ce qui donne le résultat visible à la figure suivante.

				Nos annonces et la pagination s'affichent

			Notez que vous pouvez aussi utiliser des bundles comme KnpPaginatorBundle qui simplifient encore plus la gestion de la pagination, en fournissant des vues pour afficher la listes des pages avec Bootstrap, et j'en passe. N'hésitez pas à jeter un œil pour voir si c'est intéressant pour votre projet !

	Pour conclure

		Et voilà, le premier TP du cours s'achève ici. J'espère que vous avez pu exploiter toutes les connaissances que vous avez pu acquérir jusqu'ici, et qu'il vous a aidé à vous sentir plus à l'aise.

		La prochaine partie du cours va vous emmener plus loin avec Symfony, pour connaître tous les détails qui vous permettront de créer votre site Internet de toutes pièces. À bientôt !

	En résumé

		Vous savez maintenant construire vos entités.
		Vous savez maintenant développer un contrôleur abouti.
		Vous savez maintenant faire des jointures et plus encore dans vos repositories.
		Bravo !
		Le code du cours tel qu'il doit être à ce stade est disponible sur la branche iteration-13 du dépot Github.
				
				
				
	Quiz : Quiz 3
	
	
	 
	Activité : Créer un système pour nettoyer vos entités
		
		
			Présentation

				Bienvenue dans cet exercice qui sera corrigé par vos pairs !

				Vous avez bien lu les 3 premières parties du MOOC ? Parfait, le but de l’exercice est de mettre en pratique toutes les compétences acquises jusque maintenant : utilisation des services, et de Doctrine principalement. Il doit vous permettre de bien les assimiler et de vous assurer de les maîtriser.


			Votre mission : un système de purge
			
				Beaucoup d’annonces vont être créées sur notre site, certaines trouveront des candidatures pertinentes, d’autres pas forcément. C’est dans ce dernier cas qu’il nous faut un moyen de nettoyer les annonces sans candidatures qui ne sont plus utile à personne !

				Pour cela, vous devez écrire un service que nous appellerons “oc_platform.purger.advert”. Ce service va récupérer et supprimer toutes les annonces dont la date de modification est plus vieille que X jours. Ce “X” doit être un paramètre de la méthode de votre service.

				Attention également à ne pas supprimer des annonces ayant au moins une candidature. A partir du moment où on a une candidature sur une certaine annonce, alors on souhaite garder cette annonce indéfiniment.
			
			
			La méthode à créer a donc la signature suivante :

				<?php
				public function purge($days)
				
				Pour tester ce service, je vous invite à créer une action dans le contrôleur Advert, par exemple à l’URL /platform/purge/{days}, qui ne fait qu’exécuter la purge grâce à ce service. Pas besoin de vue, cette action de contrôleur ne sera pas notée.

				Pour remplir cette mission, vous devrez peut-être créer une nouvelle méthode dans un repository.
			
			
			Point de départ
			
				Pour qu’on parle tous de la même chose, je vous propose de télécharger le code source que vous devez avoir à ce stade du cours. Cela nous fera une base commune, qui vous permettra de vérifier que vous avez bien le même, et facilitera la correction. Une fois l’archive extraite, n’oubliez pas de faire un composer install et vous serez bon pour utiliser le code !

				Téléchargez le code source de départ. 
			
			
			Conseils
			
				Les dépendances de vos services

					Pour chaque service que vous faites, pensez à bien réfléchir sur les dépendances dont vous avez besoin. Posez-vous les bonnes questions : est-ce que mon service a besoin d’envoyer des e-mails ? Est-ce que mon service a besoin d’accéder à la base de données ? Etc. En fonction de ces réponses, vous devez ajouter les services correspondants en argument du service que vous créez. 

				La construction de vos requêtes SQL

					Pour construire vos requêtes SQL, servez-vous bien du chapitre sur la récupération des entités du cours, mais également de la page sur le QueryBuilder de la documentation Doctrine.

					Notamment, pour vérifier qu’un attribut contenant une collection soit vide (ne contient aucune entité dans la relation), il faut utiliser la syntaxe suivante : attribut IS EMPTY.

				Les données de test

					Pour tester toutes les requêtes que vous allez faire, vous avez d’abord besoin de créer plein d’entités dans la base de données. Le plus simple pour cela est d’utiliser les fixtures comme nous l’avons vu dans cette partie du cours, mais vous pouvez également les ajouter à la main dans PhpMyAdmin : ce ne sont au final que des données de test.
			
			
			
	 
	Partie 4 - Allons plus loin avec Symfony
		
		https://openclassrooms.com/courses/developpez-votre-site-web-avec-le-framework-symfony/creer-des-formulaires-avec-symfony
		
		
		1. Créer des formulaires avec Symfony
		
		
			Gestion des formulaires
			
			
				L'enjeu des formulaires

					Vous avez déjà créé des formulaires en HTML et PHP, vous savez donc que c'est une vraie galère ! À moins d'avoir créé vous-mêmes un système dédié, gérer correctement des formulaires s'avère être un peu mission impossible. Par « correctement », j'entends de façon maintenable, mais surtout réutilisable. Heureusement, le composantFormde Symfony arrive à la rescousse !

					N'oubliez pas que les composants peuvent être utilisés hors d'un projet Symfony. Vous pouvez donc reprendre le composantFormdans votre site même si vous n'utilisez pas Symfony.


				Un formulaire Symfony, qu'est-ce que c'est ?

					La vision Symfony sur les formulaires est la suivante : un formulaire se construit sur un objet existant, et son objectif est d'hydrater cet objet.


					Un objet existant

						Il nous faut donc des objets avant de créer des formulaires. Mais en fait, ça tombe bien : on les a déjà, ces objets ! En effet, un formulaire pour ajouter une annonce va se baser sur l'objetAdvert, objet que nous avons construit lors de la partie précédente. Tout est cohérent.

							Je dis bien « objet » et non « entité Doctrine ». En effet, les formulaires n'ont pas du tout besoin d'une entité pour se construire, mais uniquement d'un simple objet. Heureusement, nos entités sont de simples objets avant d'être des entités, donc elles conviennent parfaitement. Je précise ce point pour vous montrer que les composants Symfony sont indépendants les uns des autres.

						Pour la suite de ce chapitre, nous allons utiliser notre objetAdvert. C'est un exemple simple qui va nous permettre de construire notre premier formulaire. Je rappelle son code, sans les annotations pour plus de clarté (et parce qu'elles ne nous regardent pas ici) :

							<?php
							// src/OC/PlatformBundle/Entity/Advert.php

							namespace OC\PlatformBundle\Entity;

							use Doctrine\Common\Collections\ArrayCollection;

							class Advert
							{
							  private $id;
							  private $date;
							  private $title;
							  private $author;
							  private $content;
							  private $published = true;
							  private $image;
							  private $categories;
							  private $applications;
							  private $updatedAt;
							  private $nbApplications = 0;
							  private $slug;

							  public function __construct()
							  {
								$this->date         = new \Datetime();
								$this->categories   = new ArrayCollection();
								$this->applications = new ArrayCollection();
							  }
							  
							  // … Les getters et setters
							}
							
							Rappel : la convention pour le nom des getters/setters est importante : lorsque l'on parlera du champ « title », le composantFormutilisera l'objet via les méthodessetTitle()etgetTitle()(comme le faisait Doctrine de son côté). Donc si vous aviez euset_title()ourecuperer_titre(), cela n'aurait pas fonctionné.


					Objectif : hydrater cet objet

						Hydrater ? Un terme précis pour dire que le formulaire va remplir les attributs de l'objet avec les valeurs entrées par le visiteur. Faire$advert->setAuthor('Alexandre'),$advert->setDate(new \Datetime()), etc., c'est hydrater l'objetAdvert.

						Le formulaire en lui-même n'a donc comme seul objectif que d'hydrater un objet. Ce n'est qu'une fois l'objet hydraté que vous pourrez en faire ce que vous voudrez : enregistrer en base de données dans le cas de notre objetAdvert, envoyer un e-mail dans le cas d'un objetContact, etc. Le système de formulaire ne s'occupe pas de ce que vous faites de votre objet, il ne fait que l'hydrater.

						Une fois que vous avez compris cela, vous avez compris l'essentiel. Le reste n'est que de la syntaxe à connaître.


					Gestion basique d'un formulaire

						Concrètement, pour créer un formulaire, il nous faut deux choses :

							Un objet (on a toujours notre objetAdvert) ;
							Un moyen pour construire un formulaire à partir de cet objet, unFormBuilder, « constructeur de formulaire » en français.

						Pour faire nos tests, placez-vous dans l'actionaddAction()de notre contrôleurAdvert et modifiez-la comme suit :

							<?php
							// src/OC/PlatformBundle/Controller/AdvertController.php

							namespace OC\PlatformBundle\Controller;

							use OC\PlatformBundle\Entity\Advert;
							use Symfony\Bundle\FrameworkBundle\Controller\Controller;
							use Symfony\Component\Form\Extension\Core\Type\CheckboxType;
							use Symfony\Component\Form\Extension\Core\Type\DateType;
							use Symfony\Component\Form\Extension\Core\Type\FormType;
							use Symfony\Component\Form\Extension\Core\Type\SubmitType;
							use Symfony\Component\Form\Extension\Core\Type\TextareaType;
							use Symfony\Component\Form\Extension\Core\Type\TextType;

							class AdvertController extends Controller
							{
							  public function addAction(Request $request)
							  {
								// On crée un objet Advert
								$advert = new Advert();

								// On crée le FormBuilder grâce au service form factory
								$formBuilder = $this->get('form.factory')->createBuilder(FormType::class, $advert);

								// On ajoute les champs de l'entité que l'on veut à notre formulaire
								$formBuilder
								  ->add('date',      DateType::class)
								  ->add('title',     TextType::class)
								  ->add('content',   TextareaType::class)
								  ->add('author',    TextType::class)
								  ->add('published', CheckboxType::class)
								  ->add('save',      SubmitType::class)
								;
								// Pour l'instant, pas de candidatures, catégories, etc., on les gérera plus tard

								// À partir du formBuilder, on génère le formulaire
								$form = $formBuilder->getForm();

								// On passe la méthode createView() du formulaire à la vue
								// afin qu'elle puisse afficher le formulaire toute seule
								return $this->render('OCPlatformBundle:Advert:add.html.twig', array(
								  'form' => $form->createView(),
								));
							  }
							}
							
						Pour le moment, ce formulaire n'est pas opérationnel. On va pouvoir l'afficher, mais il ne se passera rien lorsqu'on le validera.

						Mais avant cette étape, essayons de comprendre le code présenté. Dans un premier temps, on récupère leFormBuilder. Cet objet n'est pas le formulaire en lui-même, c'est un constructeur de formulaire. On lui dit : « Crée un formulaire autour de l'objet$advert », puis : « Ajoute les champsdate,title,content, author etpublished. » Et enfin : « Maintenant, donne-moi le formulaire construit avec tout ce que je t'ai dit auparavant. »

						Prenons le temps de bien faire la différence entre les attributs de l'objet hydraté et les champs du formulaire. D'une part, un formulaire n'est pas du tout obligé d'hydrater tous les attributs d'un objet. On pourrait très bien ne pas inclure le champauthor dans notre formulaire. L'objet, lui, contient toujours l'attributauthor, mais il ne sera juste pas hydraté par le formulaire (on pourrait le définir nous-même, sans le demander au visiteur par exemple). Bon, en l'occurrence, ce n'est pas le comportement que l'on veut (on va considérer l'auteur comme obligatoire pour une annonce), mais sachez que c'est possible. ;) D'ailleurs, si vous avez l’œil, vous avez remarqué qu'on n'ajoute pas de champid: comme il sera rempli automatiquement par Doctrine (grâce à l'auto-incrémentation), le formulaire n'a pas besoin de remplir cet attribut.

						Notez également le deuxième argument de chaque méthodeadd, il s'agit du type de champ que l'on veut. Vous pouvez le voir ici, on a un type pour les dates, un autre pour une checkbox, etc. Nous verrons la liste exhaustive des types plus bas. Chaque type est représenté par une classe différente, et ce deuxième argument attend le nom de la classe du type utilisé. Nous faisons donc appel à la constanteclass de l'objet, une constante disponible depuis PHP5.5 qui contient simplement le nom de la classe. Par exemple, au lieu deTextType::class, nous aurions pu mettre'Symfony\Component\Form\Extension\Core\Type\TextType', les deux sont strictement équivalents.

						D'autre part, notez la présence d'un champ de typeSubmitType, que j'ai appelé save ici, qui va permettre de créer le bouton de soumission du formulaire. Ce champ n'a rien à voir avec l'objet, on dit qu'il n'est pas mappé avec celui-ci. Je l'ai ici ajouté au formulaire Symfony, mais vous pouvez tout aussi bien ne pas le mettre ici et écrire à la main le bouton de soumission.

						Enfin, c'est avec cet objet$formgénéré que l'on pourra gérer notre formulaire : vérifier qu'il est valide, l'afficher, etc. Par exemple, ici, on utilise sa méthode$form->createView()qui permet à la vue d'afficher ce formulaire. Concernant l'affichage du formulaire, j'ai une bonne nouvelle pour vous : Symfony nous permet d'afficher un formulaire simple en une seule ligne HTML ! Si, si : rendez-vous dans la vueAdvert/form.html.twiget ajoutez cette ligne là où nous avions laissé un trou :

							{# src/OC/PlatformBundle/Resources/views/Advert/form.html.twig #}

							<h3>Formulaire d'annonce</h3>

							<div class="well">
							  {{ form(form) }}
							</div>
							
						Ensuite, admirez le résultat à l'adresse suivante : /platform/add. Impressionnant, non ?

							Le formulaire HTML s'affiche bien

						Grâce à la fonction Twig{{ form() }}, on peut afficher un formulaire entier en une seule ligne. Alors bien sûr, il n'est pas forcément à votre goût pour le moment, mais voyez le bon côté des choses : pour l'instant, on est en plein développement, on veut juste tester notre formulaire. On s'occupera de l'esthétique plus tard.

						Bon, évidemment, comme je vous l'ai dit, ce code ne fait qu'afficher le formulaire, il n'est pas encore question de gérer sa soumission. Mais patience, on y arrive.

							La date sélectionnée par défaut est celle d'aujourd'hui, et la checkbox « Published » est déjà cochée : comment est-ce possible ?

						Bonne question ! Il est important de savoir que ces deux points ne sont pas là par magie, et que dans Symfony tout est cohérent. Regardez bien le code pour récupérer leformBuilder, on a passé notre object$advert en argument. Or, ces valeurs date et published sont définies à la création de l'objet, l'un dans le constructeur et l'autre dans la définition de l'attribut :

							<?php
							// src/OC/PlatformBundle/Entity/Advert.php

							namespace OC\PlatformBundle\Entity;

							class Advert
							{
							  private $published = true;
							  
							  public function __construct()
							  {
								$this->date = new \Datetime();
							  }
							  
							  // ...
							}
							
						C'est à ce moment qu'est définie la valeur de ces deux attributs, et c'est sur la valeur de ces attributs que se base le formulaire pour remplir ses champs. Voilà l'origine de ces valeurs !


					Ajouter des champs

						Vous pouvez le voir, ajouter des champs à un formulaire se fait assez facilement avec la méthode$formBuilder->add()duFormBuilder. Les arguments sont les suivants :

							Le nom du champ ;
							Le type du champ ;
							Les options du champ, sous forme de tableau.
							
						Par « type de champ », il ne faut pas comprendre « type HTML » commetext,passwordouselect. Il faut comprendre « type sémantique ». Par exemple, le typeDateType que l'on a utilisé affiche trois champsselectà la suite pour choisir le jour, le mois et l'année. Il existe aussi un typeTimezoneTypepour choisir le fuseau horaire. Bref, il en existe pas mal et ils n'ont rien à voir avec les types HTML, ils vont bien plus loin que ces derniers ! N'oubliez pas, Symfony est magique !

						Voici l'ensemble des types de champ disponibles. Je vous dresse ici la liste avec pour chacun un lien vers la documentation : allez-y à chaque fois que vous avez besoin d'utiliser tel ou tel type.
							
							Type					Lien
													https://symfony.com/doc/current/reference/forms/types.html
							Texte					
									
								Choix				
								Date et temps		
								Divers				
								Multiple			
								Caché				
								TextType			
								TextareaType		
								EmailType			
								IntegerType			
								MoneyType			
								NumberType			
								PasswordType		
								PercentType			
								SearchType			
								UrlType				

								RangeType			

							Choix

								ChoiceType			
								EntityType			
								CountryType			
								LanguageType		
								LocaleType			
								TimezoneType		

								CurrencyType		

							Date et temps

								DateType			
								DatetimeType		
								TimeType			
								BirthdayType		

							Divers

								CheckboxType		
								FileType			
								RadioType			

							Multiple
								
								CollectionType		
								RepeatedType		

							Caché
								
								HiddenType			
								CsrfType			


								Ayez bien cette liste en tête : le choix d'un type de champ adapté à l'attribut de l'objet sous-jacent est une étape importante dans la création d'un formulaire.


						Il est primordial de bien faire correspondre les types de champ du formulaire avec les types d'attributs que contient votre objet. En effet, si le formulaire retourne un booléen alors que votre objet attend du texte, ils ne vont pas s'entendre.

						Dans le cas d'une entité Doctrine c'est très simple, vous définissez les type de champ de formulaire pour correspondre au type  d'attribut définit avec l'annotation (ou en yaml/xml si vous utilisez un autre type de configuration). Par exemple, pour cette annotation :

							<?php
							/**
							  * @ORM\Column(name="published", type="boolean")
							  */
							private $published = true;
							
						Il nous faut donc un type de champ qui retourne un boolean, à savoir CheckboxType :

							<?php
							$formBuilder->add('published', CheckboxType::class);
							
						Et ceci est valable pour tous vos attributs.


				Gestion de la soumission d'un formulaire

					Afficher un formulaire c'est bien, mais faire quelque chose lorsqu'un visiteur le soumet, c'est quand même mieux !

						Pour gérer l'envoi du formulaire, il faut tout d'abord vérifier que la requête est de type POST : cela signifie que le visiteur est arrivé sur la page en cliquant sur le boutonsubmitdu formulaire. 
						Ensuite, il faut faire le lien entre les variables de type POST et notre formulaire, pour que les variables de type POST viennent remplir les champs correspondants du formulaire. Ces deux actions se font grâce à la méthode handleRequest()du formulaire. Cette méthode dit au formulaire : « Voici la requête d'entrée (nos variables de type POST entre autres). Lis cette requête, récupère les valeurs qui t'intéressent et hydrate l'objet. » Comme vous pouvez le voir, elle fait beaucoup de choses !

						Enfin, une fois que notre formulaire a lu ses valeurs et hydraté l'objet, il faut tester ces valeurs pour vérifier qu'elles sont valides avec ce que l'objet et le formulaire attendent. Il faut valider notre objet. Cela se fait via la méthodeisValid()du formulaire.

					Ce n'est qu'après ces trois étapes que l'on peut traiter notre objet hydraté : sauvegarder en base de données, envoyer un e-mail, etc.

					Vous êtes un peu perdus ? C'est parce que vous manquez de code. Voici comment faire tout ce que l'on vient de dire, dans le contrôleur :

						<?php
						// src/OC/PlatformBundle/Controller/AdvertController.php

						namespace OC\PlatformBundle\Controller;

						use OC\PlatformBundle\Entity\Advert;
						use Symfony\Bundle\FrameworkBundle\Controller\Controller;
						use Symfony\Component\Form\Extension\Core\Type\CheckboxType;
						use Symfony\Component\Form\Extension\Core\Type\DateType;
						use Symfony\Component\Form\Extension\Core\Type\FormType;
						use Symfony\Component\Form\Extension\Core\Type\SubmitType;
						use Symfony\Component\Form\Extension\Core\Type\TextareaType;
						use Symfony\Component\Form\Extension\Core\Type\TextType;
						use Symfony\Component\HttpFoundation\Request;

						class AdvertController extends Controller
						{
						  public function addAction(Request $request)
						  {
							// On crée un objet Advert
							$advert = new Advert();

							// J'ai raccourci cette partie, car c'est plus rapide à écrire !
							$form = $this->get('form.factory')->createBuilder(FormType::class, $advert)
							  ->add('date',      DateType::class)
							  ->add('title',     TextType::class)
							  ->add('content',   TextareaType::class)
							  ->add('author',    TextType::class)
							  ->add('published', CheckboxType::class, array('required' => false))
							  ->add('save',      SubmitType::class)
							  ->getForm()
							;

							// Si la requête est en POST
							if ($request->isMethod('POST')) {
							  // On fait le lien Requête <-> Formulaire
							  // À partir de maintenant, la variable $advert contient les valeurs entrées dans le formulaire par le visiteur
							  $form->handleRequest($request);

							  // On vérifie que les valeurs entrées sont correctes
							  // (Nous verrons la validation des objets en détail dans le prochain chapitre)
							  if ($form->isValid()) {
								// On enregistre notre objet $advert dans la base de données, par exemple
								$em = $this->getDoctrine()->getManager();
								$em->persist($advert);
								$em->flush();

								$request->getSession()->getFlashBag()->add('notice', 'Annonce bien enregistrée.');

								// On redirige vers la page de visualisation de l'annonce nouvellement créée
								return $this->redirectToRoute('oc_platform_view', array('id' => $advert->getId()));
							  }
							}

							// À ce stade, le formulaire n'est pas valide car :
							// - Soit la requête est de type GET, donc le visiteur vient d'arriver sur la page et veut voir le formulaire
							// - Soit la requête est de type POST, mais le formulaire contient des valeurs invalides, donc on l'affiche de nouveau
							return $this->render('OCPlatformBundle:Advert:add.html.twig', array(
							  'form' => $form->createView(),
							));
						  }
						}
						
					Si le code paraît long, c'est parce que j'ai mis plein de commentaires ! Prenez le temps de bien le lire et de bien le comprendre : vous verrez, c'est vraiment simple. N'hésitez pas à le tester. Essayez de ne pas remplir un champ pour observer la réaction de Symfony. Vous voyez que ce formulaire gère déjà très bien les erreurs (via la méthodeisValid), il n'enregistre l'annonce que lorsque tout va bien.

						N'hésitez pas à tester votre formulaire en ajoutant des annonces ! Il est opérationnel, et les annonces que vous ajoutez sont réellement enregistrées en base de données.

					Si vous l'avez bien testé, vous vous êtes rendu compte qu'on est obligés de cocher le champpublished. Ce n'est pas tellement le comportement voulu, car on veut pouvoir enregistrer une annonce sans forcément la publier (pour finir la rédaction plus tard par exemple). Pour cela, nous allons utiliser le troisième argument de la méthode$formBuilder->add()qui correspond aux options du champ. Les options se présentent sous la forme d'un simple tableau. Pour rendre le champ facultatif, il faut définir l'optionrequiredàfalse, comme suit :

						<?php
						$formBuilder->add('published', CheckboxType::class, array('required' => false))

					Rappelez-vous donc : un champ de formulaire est requis par défaut. Si vous voulez le rendre facultatif, vous devez préciser cette optionrequiredà la main.

					Un mot également sur la validation que vous rencontrez depuis le navigateur : impossible de valider le formulaire si un champ obligatoire n'est pas rempli.

						Le navigateur empêche la soumission du formulaire

					Pourtant, nous n'avons pas utilisé de JavaScript ! C'est juste du HTML5. En mettant l'attributrequired="required"à une balise<input>, le navigateur interdit la validation du formulaire tant que cet input est vide. Pratique ! Mais attention, cela n'empêche pas de faire une validation côté serveur, au contraire. En effet, si quelqu'un utilise votre formulaire avec un vieux navigateur qui ne supporte pas le HMTL5, il pourra valider le formulaire sans problème.

				Gérer les valeurs par défaut du formulaire

					L'un des besoins courants dans les formulaires, c'est de mettre des valeurs prédéfinies dans les champs. Cela peut servir pour des valeurs par défaut (préremplir la date, par exemple) ou alors lors de l'édition d'un objet déjà existant (pour l'édition d'une annonce, on souhaite remplir le formulaire avec les valeurs de la base de données).

					Heureusement, cela se fait très facilement. Il suffit de modifier l'instance de l'objet, ici$advert, avant de le passer en argument à la méthodecreateFormBuilder, comme ceci :

						<?php
						// On crée une nouvelle annonce
						$advert = new Advert;

						// Ici, on préremplit avec la date d'aujourd'hui, par exemple
						// Cette date sera donc préaffichée dans le formulaire, cela facilite le travail de l'utilisateur
						$advert->setDate(new \Datetime());

						// Et on construit le formBuilder avec cette instance d'annonce
						$formBuilder = $this->get('form.factory')->createBuilder(FormType::class, $advert);

						// N'oubliez pas d'ajouter les champs comme précédemment avec la méthode ->add()
						
					Et si vous voulez modifier une annonce déjà enregistrée en base de données, alors il suffit de la récupérer avant la création du formulaire, comme ceci :

						<?php
						// Récupération d'une annonce déjà existante, d'id $id.
						$advert = $this->getDoctrine()
						  ->getManager()
						  ->getRepository('OCPlatformBundle:Advert')
						  ->find($id)
						;

						// Et on construit le formBuilder avec cette instance de l'annonce, comme précédemment
						$formBuilder = $this->get('form.factory')->createBuilder(FormType::class, $advert);

						// N'oubliez pas d'ajouter les champs comme précédemment avec la méthode ->add()

				Personnaliser l'affichage d'un formulaire

					Jusqu'ici, nous n'avons pas du tout personnalisé l'affichage de notre formulaire. Voyez quand même le bon côté des choses : on travaillait côté PHP, on a pu avancer très rapidement sans se soucier d'écrire les balises<input>à la main, ce qui est long et sans intérêt.

					Pour afficher les formulaires, Symfony utilise différents thèmes, qui sont en fait des vues pour chaque type de champ : une vue pour le champ text, une vue pour un champ select, etc. Vous serez d'accord avec moi, le thème par défaut que nous utilisons pour l'instant n'est vraiment pas sexy. Heureusement, depuis quelques temps, Symfony contient un thème adapté au framework CSS Bootstrap. Pour l'utiliser, vous devez ajouter l'optionform_themes à la sectiontwig dans votreconfig.yml, comme ceci :

						# app/config/config.yml

						twig:
							form_themes:
								- 'bootstrap_3_layout.html.twig'

					C'est tout ce qu'il faut pour utiliser ce nouveau thème. Actualisez la page et vous aurez le résultat que je vous présente à la figure suivante.

						Notre fomulaire est plus sexy avec Bootstrap !

					Impressionnant n'est-ce pas ?

						Mais utiliser ce nouveau thème ne suffit pas dans bien des cas, il vous faut un moyen d'afficher de façon plus flexible vos champs au sein du formulaire. Pour cela, je ne vais pas m'étendre, mais voici un exemple qui vous permettra de faire à peu près tout ce que vous voudrez :
						
							https://symfony.com/doc/current/form/form_customization.html

							{# src/OC/PlatformBundle/Resources/views/Advert/form.html.twig #}

							<h3>Formulaire d'annonce</h3>

							<div class="well">
							  {{ form_start(form, {'attr': {'class': 'form-horizontal'}}) }}

							  {# Les erreurs générales du formulaire. #}
							  {{ form_errors(form) }}

							  {# Génération du label + error + widget pour un champ. #}
							  {{ form_row(form.date) }}

							  {# Génération manuelle et éclatée : #}
							  <div class="form-group">
								{# Génération du label. #}
								{{ form_label(form.title, "Titre de l'annonce", {'label_attr': {'class': 'col-sm-2 control-label'}}) }}

								{# Affichage des erreurs pour ce champ précis. #}
								{{ form_errors(form.title) }}

								<div class="col-sm-10">
								  {# Génération de l'input. #}
								  {{ form_widget(form.title, {'attr': {'class': 'form-control'}}) }}
								</div>
							  </div>

							  {# Idem pour un autre champ. #}
							  <div class="form-group">
								{{ form_label(form.content, "Contenu de l'annonce", {'label_attr': {'class': 'col-sm-2 control-label'}}) }}
								{{ form_errors(form.content) }}
								<div class="col-sm-10">
								  {{ form_widget(form.content, {'attr': {'class': 'form-control'}}) }}
								</div>
							  </div>

							  {{ form_row(form.author) }}
							  {{ form_row(form.published) }}

							  {# Pour le bouton, pas de label ni d'erreur, on affiche juste le widget #}
							  {{ form_widget(form.save, {'attr': {'class': 'btn btn-primary'}}) }}

							  {# Génération automatique des champs pas encore écrits.
								 Dans cet exemple, ce serait le champ CSRF (géré automatiquement par Symfony !)
								 et tous les champs cachés (type « hidden »). #}
							  {{ form_rest(form) }}

							  {# Fermeture de la balise <form> du formulaire HTML #}
							  {{ form_end(form) }}
							</div>
							
						Si vous actualisez : aucun changement ! C'est parce que j'ai repris la structure exact de bootstrap, qui était en réalité déjà utilisée par le thème qu'on a changé plus haut. Pas de changement visuel donc, mais juste de quoi vous montrer comment afficher un à un les différents éléments du formulaire : label, erreurs, champ, etc.

						Revenons rapidement sur les fonctions Twig que j'ai utilisées :

							form_start() affiche la balise d'ouverture du formulaire HTML, soit<form>. Il faut passer la variable du formulaire en premier argument, et les paramètres en deuxième argument. L'index attr des paramètres, et cela s'appliquera à toutes les fonctions suivantes, représente les attributs à ajouter à la balise HTML générée, ici le<form>. Il nous permet d'appliquer une classe CSS au formulaire, ici form-horizontal.
							form_errors() affiche les erreurs attachées au champ donné en argument. Nous verrons les erreurs de validation dans le prochain chapitre.
							form_label() affiche le label HTML du champ donné en argument. Le deuxième argument est le contenu du label.
							form_widget() affiche le champ HTML lui-même (que ce soit<input>,<select>, etc.).
							form_row() affiche le label, les erreurs et le champ en même temps, en respectant la vue définit dans le thème du formulaire que vous utilisez.
							form_rest() affiche tous les champs manquants du formulaire (dans notre cas, juste le champ CSRF puisque nous avons déjà affiché à la main tous les autres champs).
							form_end() affiche la balise de fermeture du formulaire HTML, soit</form>.

						L'habillage des formulaires est un sujet complexe : personnalisation d'un champ en particulier, de tous les champs d'un même type, etc. Toutes les fonctions Twig que nous avons vues sont également personnalisables. Je vous invite vivement à consulter la documentation à ce sujet qui vous permettra d'aller beaucoup plus loin. Cela s'appelle en anglais le form theming.

							Qu'est-ce que le CSRF ?
							
							Le champ CSRF, pour Cross Site Request Forgeries, permet de vérifier que l'internaute qui valide le formulaire est bien celui qui l'a affiché. C'est un moyen de se protéger des envois de formulaire frauduleux (plus d'informations sur le CSRF). C'est un champ que Symfony rajoute automatiquement à tous vos formulaires, afin de les sécuriser sans même que vous vous en rendiez compte. Ce champ s'appelle_token dans vos formulaires, vous pouvez le voir si vous affichez la source HTML (il est généré par la méthodeform_rest() , donc à la fin de votre formulaire).

				Créer des types de champ personnalisés

					Il se peut que vous ayez envie d'utiliser un type de champ précis, mais que ce type de champ n'existe pas par défaut. Heureusement, vous n'êtes pas coincés, vous pouvez vous en sortir en créant votre propre type de champ. Vous pourrez ensuite utiliser ce champ comme n'importe quel autre dans vos formulaires.

					Imaginons par exemple que vous n'aimiez pas le rendu du champdateavec ces trois balises<select>pour sélectionner le jour, le mois et l'année. Vous préféreriez un jolidatepickeren JavaScript. La solution ? Créer un nouveau type de champ !

					Je ne vais pas décrire la démarche ici, mais sachez que cela existe et que la documentation traite ce point.


			Externaliser la définition de ses formulaires
			
				Vous savez enfin créer un formulaire. Il y a beaucoup de syntaxe à connaître je vous l'accorde, mais au final rien de vraiment complexe, et notre formulaire se trouve être assez joli. Mais vous souvenez-vous de ce que j'avais promis au début : nous voulions un formulaire réutilisable ; or là, tout est dans le contrôleur, et je vois mal comment le réutiliser ! Pour cela, il faut détacher la définition du formulaire dans une classe à part, nomméeAdvertType(par convention).


				Définition du formulaire dansAdvertType

					AdvertTypen'est pas notre formulaire. Comme tout à l'heure, c'est notre constructeur de formulaire. Par convention, on va mettre tous nosxxxType.phpdans le répertoireFormdu bundle. En fait, on va encore utiliser le générateur ici, qui sait générer lesFormTypepour nous, et vous verrez qu'on y gagne !

					Exécutez donc la commande suivante :

						php bin/console doctrine:generate:form OCPlatformBundle:Advert
					
					Comme vous pouvez le voir c'est une commande Doctrine, car c'est lui qui a toutes les informations sur notre objetAdvert. Maintenant, vous pouvez aller voir le résultat dans le fichiersrc/OC/PlatformBundle/Form/AdvertType.php.

					On va commencer tout de suite par améliorer ce formulaire. En effet, vous pouvez voir que les types de champ ne sont pas précisés : le composantFormva les deviner à partir des annotations Doctrine qu'on a mis dans l'objet. Ce n'est pas une bonne pratique, car cela peut être source d'erreur, c'est pourquoi je vous invite dès maintenant à remettre explicitement les types comme on avait déjà fait dans le contrôleur :

						<?php

						namespace OC\PlatformBundle\Form;

						use Symfony\Component\Form\AbstractType;
						use Symfony\Component\Form\Extension\Core\Type\CheckboxType;
						use Symfony\Component\Form\Extension\Core\Type\DateTimeType;
						use Symfony\Component\Form\Extension\Core\Type\SubmitType;
						use Symfony\Component\Form\Extension\Core\Type\TextareaType;
						use Symfony\Component\Form\Extension\Core\Type\TextType;
						use Symfony\Component\Form\FormBuilderInterface;
						use Symfony\Component\OptionsResolver\OptionsResolver;

						class AdvertType extends AbstractType
						{
						  public function buildForm(FormBuilderInterface $builder, array $options)
						  {
							$builder
							  ->add('date',      DateTimeType::class)
							  ->add('title',     TextType::class)
							  ->add('author',    TextType::class)
							  ->add('content',   TextareaType::class)
							  ->add('published', CheckboxType::class, array('required' => false))
							  ->add('save',      SubmitType::class);
						  }

						  public function configureOptions(OptionsResolver $resolver)
						  {
							$resolver->setDefaults(array(
							  'data_class' => 'OC\PlatformBundle\Entity\Advert'
							));
						  }
						}

						J'ai également supprimé les champsimageetcategories, que nous verrons différemment plus loin dans ce chapitre.

						Quant àupdatedAt,nbApplications etslug, ce sont des attributs internes à notre entité, qui ne concernent en rien le formulaire, je les ai donc supprimé également. Ce n'est pas le rôle de nos visiteurs de rentrer le slug à la main, on a tout fait pour le générer automatiquement !

					Comme vous pouvez le voir, on n'a fait que déplacer la construction du formulaire, du contrôleur à une classe externe. CetAdvertType correspond donc en fait à la définition des champs de notre formulaire. Ainsi, si l'on utilise le même formulaire sur plusieurs pages différentes, on utilisera ce mêmeAdvertType. Fini le copier-coller ! Voici la réutilisabilité. ;)

					Rappelez-vous également, un formulaire se construit autour d'un objet. Ici, on a indiqué à Symfony quelle était la classe de cet objet grâce à la méthodeconfigureDefaults(), dans laquelle on a défini l'optiondata_class.


				Le contrôleur épuré

					Avec cetAdvertType, la construction du formulaire côté contrôleur s'effectue grâce à la méthodecreate()du serviceform.factory  (et non pluscreateBuilder()). Cette méthode utilise le composantFormpour construire un formulaire à partir duAdvertType::class passé en argument. On utilise le même mécanisme qu'avec les type de champ natifs. Enfin, depuis le contrôleur, on récupère donc directement un formulaire, on ne passe plus par le constructeur de formulaire comme précédemment. Voyez par vous-mêmes :

						<?php
						// Dans le contrôleur

						$advert = new Advert;
						$form = $this->get('form.factory')->create(AdvertType::class, $advert);
						
					En effet, si l'on s'est donné la peine de créer un objet à l'extérieur du contrôleur, c'est pour que ce contrôleur soit plus simple. C'est réussi ! La création du formulaire est réduit à une seule ligne.

					Au final, en utilisant cette externalisation et en supprimant les commentaires, voici à quoi ressemble la gestion d'un formulaire dans Symfony :

						<?php
						// src/OC/PlatformBundle/Controller/AdvertController.php

						namespace OC\PlatformBundle\Controller;

						use OC\PlatformBundle\Entity\Advert;
						use OC\PlatformBundle\Form\AdvertType;
						use Symfony\Bundle\FrameworkBundle\Controller\Controller;
						use Symfony\Component\HttpFoundation\Request;

						class AdvertController extends Controller
						{
						  public function addAction(Request $request)
						  {
							$advert = new Advert();
							$form   = $this->get('form.factory')->create(AdvertType::class, $advert);

							if ($request->isMethod('POST') && $form->handleRequest($request)->isValid()) {
							  $em = $this->getDoctrine()->getManager();
							  $em->persist($advert);
							  $em->flush();

							  $request->getSession()->getFlashBag()->add('notice', 'Annonce bien enregistrée.');

							  return $this->redirectToRoute('oc_platform_view', array('id' => $advert->getId()));
							}

							return $this->render('OCPlatformBundle:Advert:add.html.twig', array(
							  'form' => $form->createView(),
							));
						  }
						}
						
					Plutôt simple, non ? Au final, votre code métier, votre code qui fait réellement quelque chose, se trouve là où l'on a utilisé l'EntityManager. Pour l'exemple, nous n'avons fait qu'enregistrer l'annonce en base de données, mais c'est ici que vous pourrez envoyer un e-mail, ou effectuer toute autre action dont votre site internet aura besoin.

						Vous trouvez que faire $form = $this->get('form.factory')->create(AdvertType::class, $advert) est trop long ? Rien que pour vous, le contrôleur de base que nous héritons dispose d'une méthode raccourcie, voici l'équivalent : $form = $this->createForm(AdvertType::class, $advert).


			Les formulaires imbriqués
			
				Intérêt de l'imbrication

					Pourquoi imbriquer des formulaires ?

					C'est souvent le cas lorsque vous avez des relations entre vos objets : vous souhaitez ajouter un objet A, mais en même temps un autre objet B qui est lié au premier. Exemple concret : vous voulez ajouter un client à votre application, votreClientest lié à uneAdresse, mais vous avez envie d'ajouter l'adresse sur la même page que votre client, depuis le même formulaire. S'il fallait deux pages pour ajouter une adresse puis un client, votre site ne serait pas très ergonomique. Voici donc toute l'utilité de l'imbrication des formulaires !


					Un formulaire est un champ

						Eh oui, voici tout ce que vous devez savoir pour imbriquer des formulaires entre eux. Considérez un de vos formulaires comme un champ, et appelez ce simple champ depuis un autre formulaire ! Bon, facile à dire, mais il faut savoir le faire derrière.

						D'abord, créez le formulaire de notre entitéImage. Vous l'aurez compris, on peut utiliser le générateur ici, exécutez donc cette commande :

							php bin/console doctrine:generate:form OCPlatformBundle:Image

						En explicitant les types des champs, cela donne le code suivant :

							<?php
							// src/OC/PlatformBundle/Form/ImageType.php

							namespace OC\PlatformBundle\Form;

							use Symfony\Component\Form\AbstractType;
							use Symfony\Component\Form\Extension\Core\Type\TextType;
							use Symfony\Component\Form\FormBuilderInterface;
							use Symfony\Component\OptionsResolver\OptionsResolver;

							class ImageType extends AbstractType
							{
							  public function buildForm(FormBuilderInterface $builder, array $options)
							  {
								$builder
								  ->add('url', TextType::class)
								  ->add('alt', TextType::class);
							  }

							  public function configureOptions(OptionsResolver $resolver)
							  {
								$resolver->setDefaults(array(
								  'data_class' => 'OC\PlatformBundle\Entity\Image'
								));
							  }
							}

						Ensuite, il existe deux façons d'imbriquer ce formulaire :

							Avec une relation simple où l'on imbrique une seule fois un sous-formulaire dans le formulaire principal. C'est le cas le plus courant, celui de notreAdvert avec une seuleImage.
							Avec une relation multiple, où l'on imbrique plusieurs fois le sous-formulaire dans le formulaire principal. C'est le cas d'unClientqui pourrait enregistrer plusieursAdresse.


					Relation simple : imbriquer un seul formulaire

						C'est le cas le plus courant, qui correspond à notre exemple de l'Advert et de sonImage. Pour imbriquer un seul formulaire en étant cohérent avec une entité, il faut que l'entité du formulaire principal (ici,Advert) ait une relation One-To-One ou Many-To-One avec l'entité (ici,Image) dont on veut imbriquer le formulaire.

						Une fois que vous savez cela, on peut imbriquer nos formulaires. C'est vraiment simple : allez dansAdvertTypeet ajoutez un champimage(du nom de la propriété de notre entité), de type…ImageType, bien sûr !

							<?php
							// src/OC/PlatformBundle/Form/AdvertType.php

							class AdvertType extends AbstractType
							{
							  public function buildForm(FormBuilderInterface $builder, array $options)
							  {
								$builder
								  ->add('date',      DateTimeType::class)
								  ->add('title',     TextType::class)
								  ->add('author',    TextType::class)
								  ->add('content',   TextareaType::class)
								  ->add('published', CheckboxType::class, array('required' => false))
								  ->add('image',     ImageType::class) // Ajoutez cette ligne
								  ->add('save',      SubmitType::class);
							  }
							  
							  // ...
							}

						C'est tout ! Allez sur la page d'ajout : /platform/add. Le formulaire est déjà à jour (voir figure suivante), avec une partie « Image » où l'on peut remplir les deux seuls champs de ce formulaire, les champs « Url » et « Alt ». C'était d'une facilité déconcertante, n'est-ce pas ?

							Les champs pour l'image apparaissent

							Les champs sont affichés après le bouton Save, ce n'est pas très joli. Pourquoi ? Car on ne les a pas affiché manuellement, ils sont donc générés par la fonctionform_rest() rappelez-vous, soit après le bouton Save. Je vous laisse les afficher au dessus du bouton si vous voulez.


						Réfléchissons bien à ce qu'on vient de faire.

						D'un côté, nous avons l'objet Advert qui possède un attributimage. Cet attributimage contient, lui, un objetImage. Il ne peut pas contenir autre chose, à cause du setter associé : celui-ci force l'argument à être un objet de la classeImage.

						L'objectif du formulaire est donc de venir injecter dans cet attributimageun objetImage, et pas autre chose ! On l'a vu au début de ce chapitre, un formulaire de typeXxxTyperetourne un objet de classeXxx (pour être précis, un objet de classe défini dans l'optiondata_class de la méthodeconfigureOptions()). Il est donc tout à fait logique de mettre dansAdvertType, un champimagede typeImageType.

						Sachez qu'il est bien entendu possible d'imbriquer les formulaires à l'infini de cette façon. La seule limitation, c'est de faire quelque chose de compréhensible pour vos visiteurs, ce qui est tout de même le plus important.

						Je fais un petit apparté Doctrine sur une erreur qui arrive souvent. Si jamais lorsque vous validez votre formulaire vous avez une erreur de ce type :

							A new entity was found through the relationship 'OC\PlatformBundle\Entity\Advert#image'
							that was not configured to cascade persist operations for entity:
							OC\PlatformBundle\Entity\Image@000000000579b29e0000000061a76c55. To solve this issue:
							Either explicitly call EntityManager#persist() on this unknown entity or configure cascade
							persist this association in the mapping for example @ManyToOne(..,cascade={"persist"}). If
							you cannot find out which entity causes the problem implement
							'OC\PlatformBundle\Entity\Image#__toString()' to get a clue.

						… c'est que Doctrine ne sait pas quoi faire avec l'entitéImagequi est dans l'entitéAdvert, car vous ne lui avez pas dit de persister cette entité. Si vous avez bien persistéAdvert, vous n'avez rien précisé pourImage et Doctrine est un peu perdu. Pour corriger l'erreur, il faut dire à Doctrine de persister cet objetImage , suivez simplement les indications du message d'erreur :

							Soit vous ajoutez manuellement un$em->persist($advert->getImage())dans le contrôleur, avant leflush();
							Soit, et c'est mieux, vous ajoutez une option à l'annotation@ORM\OneToOnedans l'entitéAdvert, ce que nous avons fait si vous suivez ce cours depuis le début, comme ceci :
							
							/**
							 * @ORM\OneToOne(targetEntity="OC\PlatformBundle\Entity\Image", cascade={"persist"})
							 */
							private $image;
							
						Soumettez le formulaire, vous verrez que l'annonce et son image sont enregistrés en base de données, ce qui veut dire que notre formulaire a bien hydraté nos deux entités.

						C'est fini pour l'imbrication simple d'un formulaire dans un autre. Passons maintenant à l'imbrication multiple.

					Relation multiple : imbriquer un même formulaire plusieurs fois

						On imbrique un même formulaire plusieurs fois lorsque deux entités sont en relation Many-To-One ou Many-To-Many.

						On va prendre l'exemple ici de l'imbrication de plusieursCategoryTypedans leAdvertTypeprincipal. Attention, cela veut dire qu'à chaque ajout d'Advert, on aura la possibilité de créer de nouvellesCategory. Ce n'est pas le comportement classique qui consiste plutôt à sélectionner desCategory existantes. Ce n'est pas grave, c'est pour l'exemple, sachant que plus loin dans ce chapitre on étudie également la manière de sélectionner  ces catégories.

						Tout d'abord, créez le formulaireCategoryTypegrâce au générateur :

							php bin/console doctrine:generate:form OCPlatformBundle:Category
							
						Voici ce que cela donne après avoir explicité les champs encore une fois :

							<?php
							// src/OC/PlatformBundle/Form/CategoryType.php

							namespace OC\PlatformBundle\Form;

							use Symfony\Component\Form\AbstractType;
							use Symfony\Component\Form\Extension\Core\Type\TextType;
							use Symfony\Component\Form\FormBuilderInterface;
							use Symfony\Component\OptionsResolver\OptionsResolver;

							class CategoryType extends AbstractType
							{
							  public function buildForm(FormBuilderInterface $builder, array $options)
							  {
								$builder
								  ->add('name', TextType::class);
							  }

							  public function configureOptions(OptionsResolver $resolver)
							  {
								$resolver->setDefaults(array(
								  'data_class' => 'OC\PlatformBundle\Entity\Category'
								));
							  }
							}

						Maintenant, il faut rajouter le champcategoriesdans leAdvertType. Il faut pour cela utiliser le typecollectionet lui passer quelques options, comme ceci :

							<?php
							// src/OC/PlatformBundle/Form/AdvertType.php

							class AdvertType extends AbstractType
							{
							  public function buildForm(FormBuilderInterface $builder, array $options)
							  {
								$builder
								  ->add('date',      DateTimeType::class)
								  ->add('title',     TextType::class)
								  ->add('author',    TextType::class)
								  ->add('content',   TextareaType::class)
								  ->add('published', CheckboxType::class, array('required' => false))
								  ->add('image',     ImageType::class)
								  /*
								   * Rappel :
								   ** - 1er argument : nom du champ, ici « categories », car c'est le nom de l'attribut
								   ** - 2e argument : type du champ, ici « CollectionType » qui est une liste de quelque chose
								   ** - 3e argument : tableau d'options du champ
								   */
								  ->add('categories', CollectionType::class, array(
									'entry_type'   => CategoryType::class,
									'allow_add'    => true,
									'allow_delete' => true
								  ))
								  ->add('save',      SubmitType::class);
							  }
							}
							
						On a ici utilisé le type de champCollectionType, qui permet en réalité de construire une collection (une liste) de n'importe quoi. On précise ce "n'importe quoi" grâce à l'optionentry_type : le formulaire sait donc qu'il doit créer une liste deCategoryType, mais on aurait pu faire une liste de typeTextType : le formulaire aurait donc injecté dans l'attributcategoriesun simple tableau de textes (mais ce n'est pas ce que nous voulons évidemment !).

						Ce champ de typeCollectionType comporte plusieurs options en plus du type. Vous notez les optionsallow_addetallow_delete, qui autorisent au formulaire d'ajouter des entrées en plus dans la collection, ainsi que d'en supprimer. En effet, on pourrait tout à fait ne pas autoriser ces actions, ce qui aurait pour effet de ne permettre que la modification desCategory qui sont déjà liées à l'Advert.

						Assez parlé, testons dès maintenant le résultat. Pour cela, actualisez la page d'ajout d'un annonce. Ah mince, le mot « Categories » est bien inscrit, mais il n'y a rien en dessous. Ce n'est pas un bug, c'est bien voulu par Symfony. En effet, comme l'entitéAdvert liée au formulaire de base n'a pas encore de catégories associées, le champCollectionType n'a encore rien à afficher ! Si on veut créer des catégories, il ne peut pas savoir à l'avance combien on veut en créer : 1, 2, 3 ou plus ?

						La solution, sachant qu'on doit pouvoir en ajouter à l'infini, et même en supprimer, est d'utiliser du JavaScript. OK, cela ne nous fait pas peur !

						D'abord, affichez la source de la page et regardez l'étrange balise<div>que Symfony a rajoutée en dessous du labelCategorie:

						Notez surtout l'attributdata-prototype. C'est en fait un attribut (au nom arbitraire) rajouté par Symfony et qui contient ce à quoi doit ressembler le code HTML pour ajouter un formulaireCategoryType. Voici son contenu sans les entités HTML :

							<div class="form-group">
							  <label class="col-sm-2 control-label required">__name__label__</label>
							  <div class="col-sm-10">
								<div id="advert_categories___name__">
								  <div class="form-group">
									<label class="col-sm-2 control-label required" for="advert_categories___name___name">Name</label>
									<div class="col-sm-10">
									  <input type="text" id="advert_categories___name___name" name="advert[categories][__name__][name]" required="required" class="form-control" />
									</div>
								  </div>
								</div>
							  </div>
							</div>
							
						Vous voyez qu'il contient les balises<label>et<input>, tout ce qu'il faut pour créer le champname compris dansCategoryType, en fait. Si ce formulaire avait d'autres champs en plus de « name », ceux-ci apparaîtraient ici également.

						Du coup on le remercie car, grâce à ce template, ajouter des champs en JavaScript est un jeu d'enfant. Je parle de template car vous pouvez noter la présence de "__name__" à plusieurs reprises. C'est une sorte de variable que nous devrons remplacer par des valeurs différentes à chaque fois qu'on ajoute le champ. En effet, un champ de formulaire HTML doit avoir un nom unique, donc si on souhaite afficher plusieurs champs pour nos catégories, il faut leur donner des noms différents.

						Je vous propose de faire un petit script JavaScript dont le but est :

							D'ajouter un boutonAjouterqui permet d'ajouter à l'infini ce sous-formulaireCategoryTypecontenu dans l'attributdata-prototype;

							D'ajouter pour chaque sous-formulaire, un boutonSupprimerpermettant de supprimer la catégorie associée.

						Voici ce que je vous ai préparé, un petit script qui emploie la bibliothèque jQuery, mettez-le pour l'instant directement dans la vue du formulaire :

							{# src/OC/PlatformBundle/Resources/views/Advert/form.html.twig #}

							{# Le formulaire reste globalement le même,
							   On ne rajoute que le champ catégorie et le lien pour en ajouter #}
							<div class="well">
							  {# ... #}
							  
							  {{ form_row(form.categories) }}
							  <a href="#" id="add_category" class="btn btn-default">Ajouter une catégorie</a>
							  
							  {# ... #}
							</div>

							{# On charge la bibliothèque jQuery. Ici, je la prends depuis le CDN google
							   mais si vous l'avez en local, changez simplement l'adresse. #}
							<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>

							{# Voici le script en question : #}
							<script type="text/javascript">
							  $(document).ready(function() {
								// On récupère la balise <div> en question qui contient l'attribut « data-prototype » qui nous intéresse.
								var $container = $('div#oc_platformbundle_advert_categories');

								// On définit un compteur unique pour nommer les champs qu'on va ajouter dynamiquement
								var index = $container.find(':input').length;

								// On ajoute un nouveau champ à chaque clic sur le lien d'ajout.
								$('#add_category').click(function(e) {
								  addCategory($container);

								  e.preventDefault(); // évite qu'un # apparaisse dans l'URL
								  return false;
								});

								// On ajoute un premier champ automatiquement s'il n'en existe pas déjà un (cas d'une nouvelle annonce par exemple).
								if (index == 0) {
								  addCategory($container);
								} else {
								  // S'il existe déjà des catégories, on ajoute un lien de suppression pour chacune d'entre elles
								  $container.children('div').each(function() {
									addDeleteLink($(this));
								  });
								}

								// La fonction qui ajoute un formulaire CategoryType
								function addCategory($container) {
								  // Dans le contenu de l'attribut « data-prototype », on remplace :
								  // - le texte "__name__label__" qu'il contient par le label du champ
								  // - le texte "__name__" qu'il contient par le numéro du champ
								  var template = $container.attr('data-prototype')
									.replace(/__name__label__/g, 'Catégorie n°' + (index+1))
									.replace(/__name__/g,        index)
								  ;

								  // On crée un objet jquery qui contient ce template
								  var $prototype = $(template);

								  // On ajoute au prototype un lien pour pouvoir supprimer la catégorie
								  addDeleteLink($prototype);

								  // On ajoute le prototype modifié à la fin de la balise <div>
								  $container.append($prototype);

								  // Enfin, on incrémente le compteur pour que le prochain ajout se fasse avec un autre numéro
								  index++;
								}

								// La fonction qui ajoute un lien de suppression d'une catégorie
								function addDeleteLink($prototype) {
								  // Création du lien
								  var $deleteLink = $('<a href="#" class="btn btn-danger">Supprimer</a>');

								  // Ajout du lien
								  $prototype.append($deleteLink);

								  // Ajout du listener sur le clic du lien pour effectivement supprimer la catégorie
								  $deleteLink.click(function(e) {
									$prototype.remove();

									e.preventDefault(); // évite qu'un # apparaisse dans l'URL
									return false;
								  });
								}
							  });
							</script>
							
						Appuyez sur F5 sur la page d'ajout et admirez le résultat (voir figure suivante). Voilà qui est mieux !

							Formulaire opérationnel avec nos catégories

						Et voilà, votre formulaire est maintenant opérationnel ! Vous pouvez vous amuser à créer des annonces contenant plein de nouvelles catégories en même temps.

						Pour bien visualiser les données que votre formulaire envoie, n'hésitez pas à utiliser le Profiler en cliquant sur la toolbar. Dans l'onglet Form, vous pourrez trouver le résultat de la figure suivante.

							La structure de notre formulaire
							
						Jetez également un oeil à l'onglet Request / Response, sur la figure suivante.

							Les données soumises par notre navigateur

						Notez déjà que toutes les données du formulaire sont contenues dans une même variable. En vieux PHP, tout votre formulaire serait contenu dans$_POST['advert']. Notez ensuite comment le__name__ du prototype a été remplacé par notre Javascript : simplement par un chiffre commençant par 0. Ainsi, tous nos champs de catégories ont un nom différent : 0, 1, etc.


					Un type de champ très utile :entity

						Je vous ai prévenu que ce qu'on vient de faire sur l'attributcategoriesétait particulier : sur le formulaire d'ajout d'une annonce nous pouvons créer des nouvelles catégories et non sélectionner des catégories déjà existantes. Ce paragraphe n'a rien à voir avec l'imbrication de formulaire, mais je me dois de vous en parler maintenant pour que vous compreniez bien la différence entre les types de champEntityType etCollectionType.

						Le type de champ EntityType est un type assez puissant, vous allez le voir très vite. Nous allons l'utiliser à la place du typeCollectionType qu'on vient de mettre en place. Vous connaîtrez ainsi les deux types, libre à vous ensuite d'utiliser celui qui convient le mieux à votre cas.

						Le typeEntityType permet donc de sélectionner des entités. D'un<select>côté formulaire HTML, vous obtenez une ou plusieurs entités côté formulaire Symfony. Testons-le tout de suite, modifiez le champcategoriescomme suit :

							<?php
							// src/OC/PlatformBundle/Form/AdvertType.php

							use Symfony\Bridge\Doctrine\Form\Type\EntityType;

							// ...

							$builder
							  ->add('categories', EntityType::class, array(
								'class'        => 'OCPlatformBundle:Category',
								'choice_label' => 'name',
								'multiple'     => true,
							  ))
							;
							
						Rafraîchissez le formulaire et admirez :

							On peut ainsi sélectionner une ou plusieurs catégories


					Les options du type de champ

						Alors, quelques explications sur les options de ce type de champ :

							L'optionclassdéfinit quel est le type d'entité à sélectionner. Ici, on veut sélectionner des entitésCategory, on renseigne donc le raccourci Doctrine pour cette entité (ou son namespace complet).
							
							L'optionchoice_label définit comment afficher les entités dans leselectdu formulaire. En effet, comment afficher une catégorie ? Par son nom ? Son id ? Un mix des deux ? Ce n'est pas à Symfony de le deviner, on lui précise donc grâce à cette optionchoice_label. Ici j'ai renseignéname, c'est donc via leur nom qu'on liste les catégories dans leselect. Sachez que vous pouvez également renseignerdisplay (ou autre !) et créer le getter associé (à savoirgetDisplay()) dans l'entitéCategory, ce sera donc le retour de cette méthode qui sera affiché dans leselect.
							
							L'optionmultipledéfinit qu'on parle ici d'une liste de catégories, et non d'une catégorie unique. Cette option est très importante, car, si vous l'oubliez, le formulaire (qui retourne une entitéCategory) et votre entitéAdvert (qui attend une liste d'entitésCategory) ne vont pas s'entendre !

						Alors, intéressant, ce type de champ, n'est-ce pas ?

						Et encore, ce n'est pas fini. Si la fonctionnalité de ce type (sélectionner une ou plusieurs entités) est unique, le rendu peut avoir quatre formes en fonction des optionsmultipleetexpanded:

							Les quatre formes (suivant les valeur boolean de ces variables, on aura soit un sélect, soit des bouton radio, soit des checkbox)

						Par défaut, les options multiple et expanded sont à false. :)

					L'optionquery_builder

						Comme vous avez pu le constater, toutes les catégories de la base de données apparaissent dans ce champ. Or parfois ce n'est pas le comportement voulu. Imaginons par exemple un champ où vous souhaitez afficher uniquement les catégories qui commencent  par une certaine lettre (oui, c'est totalement arbitraire pour l'exemple ;)). Tout est prévu : il faut jouer avec l'optionquery_builder.

						Cette option porte bien son nom puisqu'elle permet de passer au champ un QueryBuilder, que vous connaissez depuis la partie sur Doctrine. Tout d'abord, créons une méthode dans le repository de l'entité du champ (dans notre cas,CategoryRepository) qui retourne le bon QueryBuilder, celui qui ne retourne que les annonces publiées :

							<?php
							// src/OC/PlatformBundle/Repository/CategoryRepository.php

							namespace OC\PlatformBundle\Repository;

							use Doctrine\ORM\EntityRepository;

							class CategoryRepository extends EntityRepository
							{
							  public function getLikeQueryBuilder($pattern)
							  {
								return $this
								  ->createQueryBuilder('c')
								  ->where('c.name LIKE :pattern')
								  ->setParameter('pattern', $pattern)
								;
							  }
							}

							Notez bien que cette méthode retourne un QueryBuilder, et non une Query ou les résultats d'une requête comme on a l'habitude de faire.

							Pour que Doctrine utilise votre nouveau repository, n'oubliez pas de rajouter l'option repositoryClass à votre entité Category avec l'annotation suivante :  @ORM\Entity(repositoryClass="OC\PlatformBundle\Repository\CategoryRepository")

						Il ne reste maintenant qu'à faire appel à cette méthode depuis l'optionquery_buildergrâce à une closure dont l'argument est le repository, comme ceci :

							<?php
							// src/OC/PlatformBundle/Form/AdvertType.php

							use OC\PlatformBundle\Repository\CategoryRepository;

							class AdvertType extends AbstractType
							{
							  public function buildForm(FormBuilderInterface $builder, array $options)
							  {
								// Arbitrairement, on récupère toutes les catégories qui commencent par "D"
								$pattern = 'D%';
								
								$builder
								  // ...
								  ->add('categories', EntityType::class, array(
									'class'         => 'OCPlatformBundle:Category',
									'choice_label'  => 'name',
									'multiple'      => true,
									'query_builder' => function(CategoryRepository $repository) use($pattern) {
									  return $repository->getLikeQueryBuilder($pattern);
									}
								  ))
								;
							  }
							}
							
							Notez aussi comment j'ai passé la variable$pattern à la fonction. Celle-ci n'est appelée qu'avec un seul argument, le repository de l'entité. Si vous voulez lui passer d'autres variables, vous devez les lui injecter grâce auuse($var1, $var2, ...). Souvenez-vous de cette syntaxe (purement PHP !), elle est toujours utile ;)


				Aller plus loin avec les formulaires

					L'héritage de formulaire

						Je souhaiterais vous faire un point sur l'héritage de formulaire. En effet, nos formulaires, représentés par les objetsXxxType sont de simples objets, mais le composant Form a un mécanisme d'héritage dynamique un peu particulier.

						L'utilité de l'héritage dans le cadre des formulaires, c'est de pouvoir construire des formulaires différents, mais ayant la même base. Pour faire simple, je vais prendre l'exemple des formulaires d'ajout et de modification d'une Advert. Imaginons que le formulaire d'ajout comprenne tous les champs, mais que pour l'édition il soit impossible de modifier la date par exemple. Bien sûr, les applications de ce mécanisme vont bien au-delà.

						Comme nous sommes en présence de deux formulaires distincts, on va faire deuxXxxTypedistincts :AdvertTypepour l'ajout, etAdvertEditTypepour la modification. Seulement, il est hors de question de répéter la définition de tous les champs dans leAdvertEditType, tout d'abord c'est long, mais surtout si jamais un champ change, on devra modifier à la foisAdvertTypeetAdvertEditType, c'est impensable.

						On va donc faire hériterAdvertEditType deAdvertType. Le processus est le suivant :

							Copiez-collez le fichierAdvertType.phpet renommez la copie enAdvertEditType.php;

							Modifiez le nom de la classe enAdvertEditType ;

							Ajouter une méthodegetParent  qui retourne la classe du formulaire parent,AdvertType::class  ;

							Remplacez la définition manuelle de tous les champs (les$builder->add()) par une simple ligne pour supprimer le champ date: $builder->remove('date') ;

							Enfin, supprimez la méthodeconfigureOptions()qu'il ne sert à rien d'hériter dans notre cas.

						Voici ce que cela donne :

							<?php
							// src/OC/PlatformBundle/Form/AdvertEditType.php

							namespace OC\PlatformBundle\Form;

							use Symfony\Component\Form\AbstractType;
							use Symfony\Component\Form\FormBuilderInterface;

							class AdvertEditType extends AbstractType
							{
							  public function buildForm(FormBuilderInterface $builder, array $options)
							  {
								$builder->remove('date');
							  }

							  public function getParent()
							  {
								return AdvertType::class;
							  }
							}

						Concrètement, la différence entre l'héritage natif PHP et ce qu'on appelle l'héritage de formulaires réside dans la méthodegetParent() qui retourne le formulaire parent. Ainsi, lors de la construction de ce formulaire, le composant Form exécutera d'abord la méthodebuildForm du formulaire parent, iciAdvertType, avant d'exécuter celle-ci qui vient supprimer le champ date. Au même titre que les type de champs dans la création du formulaire, la valeur du parent peut très bien êtreTextType::class (ou autre) : votre champ hériterait donc du champ texte de base.

						Maintenant, si vous utilisez le formulaireAdvertEditType, vous ne pourrez pas modifier l'attributdatede l'entitéAdvert. Objectif atteint ! Prenez le temps de tester ce nouveau formulaire depuis l'actioneditAction()de notre site, c'est un bon entraînement.

							Si vous voulez utiliser la même vue pour les deux formulaires, vous aurez une erreur comme quoi le champform.date n'existe pas dans la vue pour le formulaire d'édition. Pour corriger cela, englobez simplement le{{ form_row(form.date) }} d'un{% if form.date is defined %}.

						À retenir

							Plusieurs choses à retenir de cet héritage de formulaire :

								D'une part, si vous avez besoin de plusieurs formulaires : faites plusieursXxxType! Cela ne mange pas de pain, et vous évite de faire du code impropre derrière en mettant des conditions hasardeuses. Le raisonnement est simple : si le formulaire que vous voulez afficher à votre internaute est différent (champ en moins, champ en plus), alors côté Symfony c'est un tout autre formulaire, qui mérite son propreXxxType.
								
								D'autre part, pensez à bien utiliser l'héritage de formulaires pour éviter de dupliquer du code. Si faire plusieurs formulaires est une bonne chose, dupliquer les champs à droite et à gauche ne l'est pas. Centralisez donc la définition de vos champs dans un formulaire, et utilisez l'héritage pour le propager aux autres.


					Construire un formulaire différemment selon des paramètres

						Un autre besoin qui se fait sentir lors de l'élaboration de formulaires un peu plus complexes que notre simpleAdvertType, c'est la modulation d'un formulaire en fonction de certains paramètres.

						Par exemple, on pourrait empêcher de dépublier une annonce une fois qu'elle est publiée. Le comportement serait le suivant :

							Si l'annonce n'est pas encore publiée, on peut modifier sa valeur de publication lorsqu'on modifie l'annonce;
							
							Si l'annonce est déjà publiée, on ne peut plus modifier sa valeur de publication lorsqu'on modifie l'annonce.
							
						C'est un exemple simple, retenez l'idée derrière qui est de construire différemment le formulaire suivant les valeurs de l'objet sous-jacent. Ce n'est pas aussi évident qu'il n'y paraît, car dans la méthodebuildForm()nous n'avons pas accès aux valeurs de l'objetAdvert qui sert de base au formulaire ! Comment savoir si l'annonce est déjà publiée ou non ?

						Pour arriver à nos fins, il faut utiliser les évènements de formulaire. Ce sont des évènements que le formulaire déclenche à certains moments de sa construction. Il existe notamment l'évènementPRE_SET_DATAqui est déclenché juste avant que les champs ne soient remplis avec les valeurs de l'objet (les valeurs par défaut donc). Cet évènement permet de modifier la structure du formulaire.

						Sans plus attendre, voici à quoi ressemble notre nouvelle méthodebuildForm():

							<?php
							// src/OC/PlatformBundle/Form/AdvertType.php

							namespace OC\PlatformBundle\Form;

							use OC\PlatformBundle\Repository\CategoryRepository;
							use Symfony\Bridge\Doctrine\Form\Type\EntityType;
							use Symfony\Component\Form\AbstractType;
							use Symfony\Component\Form\Extension\Core\Type\CheckboxType;
							use Symfony\Component\Form\Extension\Core\Type\DateTimeType;
							use Symfony\Component\Form\Extension\Core\Type\SubmitType;
							use Symfony\Component\Form\Extension\Core\Type\TextareaType;
							use Symfony\Component\Form\Extension\Core\Type\TextType;
							use Symfony\Component\Form\FormBuilderInterface;
							// N'oubliez pas ces deux use !
							use Symfony\Component\Form\FormEvent;
							use Symfony\Component\Form\FormEvents;
							use Symfony\Component\OptionsResolver\OptionsResolver;

							class AdvertType extends AbstractType
							{
							  public function buildForm(FormBuilderInterface $builder, array $options)
							  {
								// Ajoutez ici tous vos champs sauf le champ published
								$builder = ...;

								// On ajoute une fonction qui va écouter un évènement
								$builder->addEventListener(
								  FormEvents::PRE_SET_DATA,    // 1er argument : L'évènement qui nous intéresse : ici, PRE_SET_DATA
								  function(FormEvent $event) { // 2e argument : La fonction à exécuter lorsque l'évènement est déclenché
									// On récupère notre objet Advert sous-jacent
									$advert = $event->getData();

									// Cette condition est importante, on en reparle plus loin
									if (null === $advert) {
									  return; // On sort de la fonction sans rien faire lorsque $advert vaut null
									}

									// Si l'annonce n'est pas publiée, ou si elle n'existe pas encore en base (id est null)
									if (!$advert->getPublished() || null === $advert->getId()) {
									  // Alors on ajoute le champ published
									  $event->getForm()->add('published', CheckboxType::class, array('required' => false));
									} else {
									  // Sinon, on le supprime
									  $event->getForm()->remove('published');
									}
								  }
								);
							  }
							  
							  // ...
							}
							
						Il y a beaucoup de syntaxe dans ce code, mais il est au fond abordable, et vous montre les possibilités qu'offrent les évènements de formulaire.

						La fonction qui est exécutée par l'évènement prend en argument l'évènement lui-même, la variable$event. Depuis cet objet évènement, vous pouvez récupérer d'une part l'objet sous-jacent, via$event->getData(), et d'autre part le formulaire, via$event->getForm().

						Récupérer l'Advert nous permet d'utiliser les valeurs qu'il contient, chose qu'on ne pouvait pas faire d'habitude dans la méthodebuildForm(), qui, elle, est exécutée une fois pour toutes, indépendamment de l'objet sous-jacent. Pour mieux visualiser cette unique instance duXxxType, pensez à un champ de typeCollectionType, rappelez-vous sa définition :

							<?php
							$builder->add('categories', CollectionType::class, array('entry_type' => CategoryType::class);

						Avec ce code, on ne crée qu'un seul objetCategoryType, or celui-ci sera utilisé pour ajouter plusieurs catégories différentes. Il est donc normal de ne pas avoir accès à l'objet$category lors de la construction du formulaire, autrement dit la construction de l'objetCategoryType. C'est pour cela qu'il faut utiliser l'évènementPRE_SET_DATA, qui, lui, est déclenché à chaque fois que le formulaire remplit les valeurs de ses champs par les valeurs d'un nouvel objetCategory.

							Je reviens sur la conditionif (null == $advert)dans la fonction. En fait, à la première création du formulaire, celui-ci exécute sa méthodesetData()avecnullen argument. Cette occurrence de l'évènementPRE_SET_DATAne nous intéresse pas, d'où la condition pour sortir de la fonction lorsque$event->getData()vautnull. Ensuite, lorsque le formulaire récupère l'objet ($advert dans notre cas) sur lequel se construire, il réexécute sa méthodesetData()avec l'objet en argument. C'est cette occurrence-là qui nous intéresse.

						Sachez qu'il est également possible d'ajouter non pas une simple fonction à exécuter lors de l'évènement, mais un service ! Tout cela et bien plus encore est décrit dans la documentation des évènements de formulaire. N'hésitez pas à vous documenter dessus, car c'est cette méthode des évènements qui permet également la création des fameuses combobox : deux champs<select>dont le deuxième (par exempleville) dépend de la valeur du premier (par exemplepays).


			Le type de champ File pour envoyer des fichiers

				Dans cette partie, nous allons apprendre à envoyer un fichier via le typeFileType, ainsi qu'à le persister via les évènements Doctrine (j'espère que vous ne les avez pas déjà oubliés !).

				Le type de champFile

					Un champFileType de formulaire ne retourne pas du texte, mais une instance de la classeUploadedFile. Or nous allons stocker dans la base de données seulement l'adresse du fichier, donc du texte pur. Pour cette raison, il faut utiliser un attribut à part dans l'entité sous-jacente au formulaire, iciImage.

				Préparer l'objet sous-jacent

					Ouvrez donc l'entitéImageet ajoutez l'attribut$filesuivant :

						<?php
						// src/OC/PlatformBundle/Entity/Image

						namespace OC\PlatformBundle\Entity;

						use Doctrine\ORM\Mapping as ORM;
						// N'oubliez pas ce use :
						use Symfony\Component\HttpFoundation\File\UploadedFile;

						/**
						 * @ORM\Entity(repositoryClass="OC\PlatformBundle\Entity\ImageRepository")
						 */
						class Image
						{
						  /**
						   * @ORM\Column(name="id", type="integer")
						   * @ORM\Id
						   * @ORM\GeneratedValue(strategy="AUTO")
						   */
						  private $id;

						  /**
						   * @ORM\Column(name="url", type="string", length=255)
						   */
						  private $url;

						  /**
						   * @ORM\Column(name="alt", type="string", length=255)
						   */
						  private $alt;

						  private $file;
						  
						  public function getFile()
						  {
							return $this->file;
						  }

						  public function setFile(UploadedFile $file = null)
						  {
							$this->file = $file;
						  }
						  
						  // ...
						}
						
						
					Notez bien que je n'ai pas mis d'annotation pour Doctrine : ce n'est pas cet attribut$fileque nous allons persister par la suite, on ne met donc pas d'annotation. Par contre, c'est bien cet attribut qui servira pour le formulaire, et non les autres.


				Adapter le formulaire

					Passons maintenant au formulaire. Nous avions construit un champ de formulaire sur l'attribut$url, dans lequel l'utilisateur devait mettre directement l'URL de son image. Maintenant on veut plutôt lui permettre d'envoyer un fichier depuis son ordinateur.

					On va donc supprimer le champ sur$url(et sur$alt, on va pouvoir le générer dynamiquement) et en créer un nouveau sur$file:

						<?php
						// src/OC/PlatformBundle/Form/ImageType.php

						namespace OC\PlatformBundle\Form;

						use Symfony\Component\Form\AbstractType;
						use Symfony\Component\Form\Extension\Core\Type\FileType;
						use Symfony\Component\Form\FormBuilderInterface;
						use Symfony\Component\OptionsResolver\OptionsResolver;

						class ImageType extends AbstractType
						{
						  public function buildForm(FormBuilderInterface $builder, array $options)
						  {
							$builder
							  ->add('file', FileType::class)
							;
						  }
						}
						
					Le rendu de votre formulaire est déjà bon. Essayez de vous rendre sur la page d'ajout, vous allez voir le champ d'upload de la figure suivante.

						Champ pour envoyer un fichier

						Lorsque vous utilisez des formulaires avec des envois de fichiers, vous savez qu'il faut préciser l'enctypedans la balise HTML du formulaire. Si vous utilisez la fonction{{ form_start(form) }} pour générer votre balise  <form>, alors l'enctypeest automatiquement rajouté dès que Symfony détecte un champ de typeFileType. Sinon, vous devez le rajouter à la main.

					Bon, par contre évidemment le formulaire n'est pas opérationnel. La sauvegarde du fichier envoyé ne va pas se faire toute seule !

				Manipuler le fichier envoyé

					Une fois le formulaire soumis, il faut bien évidemment s'occuper du fichier envoyé. L'objetUploadedFileque le formulaire nous renvoie simplifie grandement les choses, grâce à sa méthodemove(). Créons une méthodeupload()dans notre objetImagepour s'occuper de tout cela :

						<?php
						// src/OC/PlatformBundle/Entity/Image

						class Image
						{
						  public function upload()
						  {
							// Si jamais il n'y a pas de fichier (champ facultatif), on ne fait rien
							if (null === $this->file) {
							  return;
							}

							// On récupère le nom original du fichier de l'internaute
							$name = $this->file->getClientOriginalName();

							// On déplace le fichier envoyé dans le répertoire de notre choix
							$this->file->move($this->getUploadRootDir(), $name);

							// On sauvegarde le nom de fichier dans notre attribut $url
							$this->url = $name;

							// On crée également le futur attribut alt de notre balise <img>
							$this->alt = $name;
						  }

						  public function getUploadDir()
						  {
							// On retourne le chemin relatif vers l'image pour un navigateur (relatif au répertoire /web donc)
							return 'uploads/img';
						  }

						  protected function getUploadRootDir()
						  {
							// On retourne le chemin relatif vers l'image pour notre code PHP
							return __DIR__.'/../Resources/public/'.$this->getUploadDir();
						  }
						}
						
					Plusieurs choses dans ce code.

					D'une part, on a défini le répertoire dans lequel stocker nos images. J'ai mis ici Resources/public/uploads/img, ce répertoire est relatif au répertoireweb, vous pouvez tout à fait le personnaliser. La méthodegetUploadDir()retourne ce chemin relatif, à utiliser dans vos vues car les navigateurs sont relatifs à notre répertoireweb. La méthodegetUploadRootDir(), quant à elle, retourne le chemin vers le même fichier, mais en absolu. Vous le savez__DIR__représente le répertoire absolu du fichier courant, ici notre entité, du coup pour atteindre le répertoireweb, il faut remonter pas mal de dossiers, comme vous pouvez le voir. :p

					D'autre part, la méthodeupload()s'occupe concrètement de notre fichier. Elle fait l'équivalent dumove_uploaded_file()que vous pouviez utiliser en PHP pur. Ici j'ai choisi pour l'instant de garder le nom du fichier tel qu'il était sur le PC du visiteur, ce n'est évidemment pas optimal, car si deux fichiers du même nom sont envoyés, le second écrasera le premier !

					Enfin, d'un point de vue persistance de notre entitéImagedans la base de données, la méthodeupload()s'occupe également de renseigner les deux attributs persistés,$urlet$alt. En effet, l'attribut$file, qui est le seul rempli par le formulaire, n'est pas du tout persisté.

					Bien entendu, cette méthode ne s'exécute pas toute seule, il faut l'exécuter à la main depuis le contrôleur. Rajoutez donc un appel manuel à cette méthode dansaddAction, une fois que le formulaire est valide :

						<?php
						// src/OC/PlatformBundle/Controller/AdvertController.php

						// …

						  public function addAction(Request $request)
						  {
							$advert = new Advert();
							$form   = $this->get('form.factory')->create(AdvertType::class, $advert);

							if ($request->isMethod('POST') && $form->handleRequest($request)->isValid()) {
							  // Ajoutez cette ligne :
							  // c'est elle qui déplace l'image là où on veut les stocker
							  $advert->getImage()->upload();

							  // Le reste de la méthode reste inchangé
							  $em = $this->getDoctrine()->getManager();
							  $em->persist($advert);
							  $em->flush();
							  
							  // ...
							}
							
							// ...
						  }

						// …
						
							Il est impératif d'exécuter la méthodeupload()avant de persister l'entité, car sinon les attributs$urlet$altne seront pas définis à l'exécution duflush, et cela créerait une erreur (ils ne peuvent pas êtrenulldans la base de données).

					Si vous commencez à bien penser « découplage », ce que nous venons de faire ne devrait pas vous plaire. Le contrôleur ne devrait pas avoir à agir juste parce que nous avons un peu modifié le comportement de l'entitéImage. Et imaginez qu'un jour nous oubliions d'exécuter manuellement cette méthodeupload()! Bref, vous l'aurez compris, il faut ici réutiliser les évènements Doctrine pour automatiser tout cela. ;)


				Automatiser le traitement grâce aux évènements

					La manipulation du champ de typeFileType que nous venons de faire est bonne, mais son implémentation est juste un peu maladroite. Il faut automatiser cela grâce aux évènements Doctrine. Mais ce n'est pas que de l'esthétisme, c'est impératif pour gérer tous les cas… comme la suppression d'une entitéImage par exemple !

					On va également en profiter pour modifier le nom donné au fichier qu'on déplace dans notre répertoire Resources/public/uploads/img. Le fichier va prendre comme nom l'id de l'entité, suffixé de son extension évidemment.

				Quels évènements utiliser ?

					C'est une question qu'il faut toujours se poser consciencieusement, car le comportement peut changer du tout au tout suivant les évènements choisis. Dans notre cas, il y a en réalité quatre actions différentes à exécuter :

						Avant l'enregistrement effectif dans la base de données : il faut remplir les attributs$urlet$altavec les bonnes valeurs suivant le fichier envoyé. On doit impérativement le faire avant l'enregistrement, pour qu'ils puissent être enregistrés eux-mêmes en base de données. Pour cette action, il faut utiliser les évènements :
							PrePersist
							PreUpdate
							
						Juste après l'enregistrement : il faut déplacer effectivement le fichier envoyé. On ne le fait pas avant, car l'enregistrement dans la base de données peut échouer. En cas d'échec de l'enregistrement de l'entité en base de données, il ne faudrait pas se retrouver avec un fichier orphelin sur notre disque. On attend donc que l'enregistrement se fasse effectivement avant de déplacer le fichier. Pour cette action, il faut utiliser les évènements :
							PostPersist
							PostUpdate
						
						Juste avant la suppression : il faut sauvegarder le nom du fichier dans un attribut non persisté,$filename par exemple. En effet, comme le nom du fichier dépend de l'id, on n'y aura plus accès enPostRemove, (l'entité étant supprimé, elle n'a plus d'id) on est donc obligé de le sauvegarder enPreRemove: peu pratique mais obligatoire. Pour cette action, il faut utiliser l'évènement :
							PreRemove
						
						Juste après la suppression : il faut supprimer le fichier qui était associé à l'entité. Encore une fois, on ne le fait pas avant la suppression, car si l'entité n'est au final pas supprimée, on aurait alors une entité sans fichier. Pour cette action, il faut utiliser l'évènement :
							PostRemove


				Implémenter les méthodes des évènements

					La méthode est la suivante :

						On éclate l'ancien code de la méthodeupload()dans les méthodes :
							preUpload(): pour ce qui est de la génération des attributs$urlet$alt;
							upload(): pour le déplacement effectif du fichier.

						On ajoute une méthodepreRemoveUpload()qui sauvegarde le nom du fichier, qui dépend de l'id de l'entité, dans un attribut temporaire.
						
						On ajoute une méthoderemoveUpload()qui supprime effectivement le fichier grâce au nom enregistré.
						
					N'oubliez pas de rajouter un attribut (ici j'ai mis$tempFilename) pour la sauvegarde du nom du fichier. Au final, voici ce que cela donne :

						<?php
						// src/OC/PlatformBundle/Entity/Image

						namespace OC\PlatformBundle\Entity;

						use Doctrine\ORM\Mapping as ORM;
						use Symfony\Component\HttpFoundation\File\UploadedFile;

						/**
						 * @ORM\Table(name="oc_image")
						 * @ORM\Entity
						 * @ORM\HasLifecycleCallbacks
						 */
						class Image
						{
						  // ...
						  
						  private $file;

						  // On ajoute cet attribut pour y stocker le nom du fichier temporairement
						  private $tempFilename;

						  // On modifie le setter de File, pour prendre en compte l'upload d'un fichier lorsqu'il en existe déjà un autre
						  public function setFile(UploadedFile $file)
						  {
							$this->file = $file;

							// On vérifie si on avait déjà un fichier pour cette entité
							if (null !== $this->url) {
							  // On sauvegarde l'extension du fichier pour le supprimer plus tard
							  $this->tempFilename = $this->url;

							  // On réinitialise les valeurs des attributs url et alt
							  $this->url = null;
							  $this->alt = null;
							}
						  }

						  /**
						   * @ORM\PrePersist()
						   * @ORM\PreUpdate()
						   */
						  public function preUpload()
						  {
							// Si jamais il n'y a pas de fichier (champ facultatif), on ne fait rien
							if (null === $this->file) {
							  return;
							}

							// Le nom du fichier est son id, on doit juste stocker également son extension
							// Pour faire propre, on devrait renommer cet attribut en « extension », plutôt que « url »
							$this->url = $this->file->guessExtension();

							// Et on génère l'attribut alt de la balise <img>, à la valeur du nom du fichier sur le PC de l'internaute
							$this->alt = $this->file->getClientOriginalName();
						  }

						  /**
						   * @ORM\PostPersist()
						   * @ORM\PostUpdate()
						   */
						  public function upload()
						  {
							// Si jamais il n'y a pas de fichier (champ facultatif), on ne fait rien
							if (null === $this->file) {
							  return;
							}

							// Si on avait un ancien fichier, on le supprime
							if (null !== $this->tempFilename) {
							  $oldFile = $this->getUploadRootDir().'/'.$this->id.'.'.$this->tempFilename;
							  if (file_exists($oldFile)) {
								unlink($oldFile);
							  }
							}

							// On déplace le fichier envoyé dans le répertoire de notre choix
							$this->file->move(
							  $this->getUploadRootDir(), // Le répertoire de destination
							  $this->id.'.'.$this->url   // Le nom du fichier à créer, ici « id.extension »
							);
						  }

						  /**
						   * @ORM\PreRemove()
						   */
						  public function preRemoveUpload()
						  {
							// On sauvegarde temporairement le nom du fichier, car il dépend de l'id
							$this->tempFilename = $this->getUploadRootDir().'/'.$this->id.'.'.$this->url;
						  }

						  /**
						   * @ORM\PostRemove()
						   */
						  public function removeUpload()
						  {
							// En PostRemove, on n'a pas accès à l'id, on utilise notre nom sauvegardé
							if (file_exists($this->tempFilename)) {
							  // On supprime le fichier
							  unlink($this->tempFilename);
							}
						  }

						  public function getUploadDir()
						  {
							// On retourne le chemin relatif vers l'image pour un navigateur
							return 'uploads/img';
						  }

						  protected function getUploadRootDir()
						  {
							// On retourne le chemin relatif vers l'image pour notre code PHP
							return __DIR__.'/../Resources/public/'.$this->getUploadDir();
						  }

						  // …
						}

					Et voilà, votre upload est maintenant totalement opérationnel.

						Bien sûr, vous devez supprimer l'appel à$advert->getImage()->upload()qu'on avait mis à la main dans le contrôleur. Cette ligne n'est plus utile maintenant que tout est fait automatiquement grâce aux évènements !
						
					Vous pouvez vous amuser avec votre système d'upload. Créez des annonces avec des images jointes, vous verrez automatiquement les fichiers apparaître dansResources/public/uploads/img. Supprimez une annonce : l'image jointe sera automatiquement supprimée du répertoire.

						Pour que l'entitéImageliée à une annonce soit supprimée lorsque vous supprimez l'entitéAdvert, assurez-vous que l'actionremovesoit en cascade. Pour cela, votre annotation sur l'attribut$imagedans votre entitéAdvert devrait ressembler à ceci :@ORM\OneToOne(targetEntity="OC\PlatformBundle\Entity\Image", cascade={"persist", "remove"}).

						Attention à ne pas laisser la possibilité à vos visiteurs d'envoyer n'importe quel type de fichier sur votre site internet ! Il est impératif d'ajouter une règle de validation@Assert\Filepour limiter les types de fichiers, et ne pas laisser une faille de sécurité béante. On aborde les règles de validation dans le prochain chapitre.

					Vous devez également modifier la vueview.html.twigqui affiche les images. Nous avions utilisé{{ advert.image.url }}, mais ce n'est plus bon puisque l'on ne stocke plus que l'extension du fichier dans l'attribut$url. Il faudrait donc mettre le code suivant :

						<img
						  src="{{ asset(advert.image.uploadDir ~ '/' ~ advert.image.id ~ '.' ~ advert.image.url) }}"
						  alt="{{ advert.image.alt }}"
						/>
						
					En fait, comme vous pouvez le voir, c'est assez long à écrire dans la vue. Il est donc intéressant d'ajouter une méthode qui fait tout cela dans l'entité, par exemplegetWebPath():

						<?php
						// src/OC/PlatformBundle/Entity/Image

						  public function getWebPath()
						  {
							return $this->getUploadDir().'/'.$this->getId().'.'.$this->getUrl();
						  }
						  
					Et du coup, dans la vue, il ne reste plus que :

						<img 
						  src="{{ asset(advert.image.webPath) }}"
						  alt="{{ advert.image.alt }}"
						/>
						
						Tout ce code est assez long j'en conviens, mais c'est inhérent à l'envoi d'image en général : il y a plein de cas à gérer (ajout, suppression, etc.). N'oubliez pas également qu'il est totalement réutilisable ! Si vous souhaitez ajouter uneImage depuis une autre entité queAdvert, vous n'aurez plus rien à faire ;)

						Sachez également que de nombreux bundles existent pour vous simplifier la vie avec les envois de fichiers, ou bien pour faire des envois plus complexes (multiple, etc.), n'hésitez pas à cherche votre bonheur sur internet. Je ne saurais que vous conseiller VichUploaderBundle pour commencer, c'est un bundle très actif et bien maintenu par la communauté.

			Application : les formulaires de notre site

				Théorie

					Nous avons déjà généré presque tous les formulaires utiles pour notre site, mais nous n'avons pas entièrement adapté les actions du contrôleur pour les rendre pleinement opérationnelles.

					Je vous invite donc à reprendre tout notre contrôleur, et à le modifier de telle sorte que toutes ses actions soient entièrement fonctionnelles, vous avez toutes les clés en main maintenant ! Je pense notamment aux actions de modification et de suppression, que nous n'avons pas déjà faites dans ce chapitre. Au boulot ! Essayez d'implémenter vous-mêmes la gestion du formulaire dans les actions correspondantes. Ensuite seulement, lisez la suite de ce paragraphe pour avoir la solution.

				Pratique

					Je vous remets déjà tous les formulaires pour être sûr qu'on parle de la même chose.

					AdvertType

						<?php
						// src/OC/PlatformBundle/Form/AdvertType.php

						namespace OC\PlatformBundle\Form;

						use OC\PlatformBundle\Repository\CategoryRepository;
						use Symfony\Bridge\Doctrine\Form\Type\EntityType;
						use Symfony\Component\Form\AbstractType;
						use Symfony\Component\Form\Extension\Core\Type\CheckboxType;
						use Symfony\Component\Form\Extension\Core\Type\DateTimeType;
						use Symfony\Component\Form\Extension\Core\Type\SubmitType;
						use Symfony\Component\Form\Extension\Core\Type\TextareaType;
						use Symfony\Component\Form\Extension\Core\Type\TextType;
						use Symfony\Component\Form\FormBuilderInterface;
						use Symfony\Component\Form\FormEvent;
						use Symfony\Component\Form\FormEvents;
						use Symfony\Component\OptionsResolver\OptionsResolver;

						class AdvertType extends AbstractType
						{
						  public function buildForm(FormBuilderInterface $builder, array $options)
						  {
							// Arbitrairement, on récupère toutes les catégories qui commencent par "D"
							$pattern = 'D%';

							$builder
							  ->add('date',      DateTimeType::class)
							  ->add('title',     TextType::class)
							  ->add('author',    TextType::class)
							  ->add('content',   TextareaType::class)
							  ->add('image',     ImageType::class)
							  ->add('categories', EntityType::class, array(
								'class'         => 'OCPlatformBundle:Category',
								'choice_label'  => 'name',
								'multiple'      => true,
								'query_builder' => function(CategoryRepository $repository) use($pattern) {
								  return $repository->getLikeQueryBuilder($pattern);
								}
							  ))
							  ->add('save',      SubmitType::class)
							;

							$builder->addEventListener(
							  FormEvents::PRE_SET_DATA,
							  function(FormEvent $event) {
								$advert = $event->getData();

								if (null === $advert) {
								  return;
								}

								if (!$advert->getPublished() || null === $advert->getId()) {
								  $event->getForm()->add('published', CheckboxType::class, array('required' => false));
								} else {
								  $event->getForm()->remove('published');
								}
							  }
							);
						  }

						  public function configureOptions(OptionsResolver $resolver)
						  {
							$resolver->setDefaults(array(
							  'data_class' => 'OC\PlatformBundle\Entity\Advert'
							));
						  }
						}


					AdvertEditType

						<?php
						// src/OC/PlatformBundle/Form/AdvertEditType.php

						namespace OC\PlatformBundle\Form;

						use Symfony\Component\Form\AbstractType;
						use Symfony\Component\Form\FormBuilderInterface;

						class AdvertEditType extends AbstractType
						{
						  public function buildForm(FormBuilderInterface $builder, array $options)
						  {
							$builder->remove('date');
						  }

						  public function getParent()
						  {
							return AdvertType::class;
						  }
						}

					ImageType

						<?php
						// src/OC/PlatformBundle/Form/ImageType.php

						namespace OC\PlatformBundle\Form;

						use Symfony\Component\Form\AbstractType;
						use Symfony\Component\Form\Extension\Core\Type\FileType;
						use Symfony\Component\Form\FormBuilderInterface;
						use Symfony\Component\OptionsResolver\OptionsResolver;

						class ImageType extends AbstractType
						{
						  public function buildForm(FormBuilderInterface $builder, array $options)
						  {
							$builder
							  ->add('file', FileType::class)
							;
						  }

						  public function configureOptions(OptionsResolver $resolver)
						  {
							$resolver->setDefaults(array(
							  'data_class' => 'OC\PlatformBundle\Entity\Image'
							));
						  }
						}

					L'action « ajouter » du contrôleur

					On a déjà fait cette action, je vous la remets ici comme référence :

						<?php
						// src/OC/PlatformBundle/Controller/AdvertController.php

						  public function addAction(Request $request)
						  {
							$advert = new Advert();
							$form   = $this->get('form.factory')->create(AdvertType::class, $advert);

							if ($request->isMethod('POST') && $form->handleRequest($request)->isValid()) {
							  $em = $this->getDoctrine()->getManager();
							  $em->persist($advert);
							  $em->flush();

							  $request->getSession()->getFlashBag()->add('notice', 'Annonce bien enregistrée.');

							  return $this->redirectToRoute('oc_platform_view', array('id' => $advert->getId()));
							}

							return $this->render('OCPlatformBundle:Advert:add.html.twig', array(
							  'form' => $form->createView(),
							));
						  }
					
						  
				L'action « modifier » du contrôleur

					Voici l'une des actions que vous deviez faire tout seuls. Ici pas de piège, il fallait juste penser à bien utiliserAdvertEditTypeet nonAdvertType, car on est en mode édition.

						<?php
						// src/OC/PlatformBundle/Controller/AdvertController.php

						  public function editAction($id, Request $request)
						  {
							$em = $this->getDoctrine()->getManager();

							$advert = $em->getRepository('OCPlatformBundle:Advert')->find($id);

							if (null === $advert) {
							  throw new NotFoundHttpException("L'annonce d'id ".$id." n'existe pas.");
							}

							$form = $this->get('form.factory')->create(AdvertEditType::class, $advert);

							if ($request->isMethod('POST') && $form->handleRequest($request)->isValid()) {
							  // Inutile de persister ici, Doctrine connait déjà notre annonce
							  $em->flush();

							  $request->getSession()->getFlashBag()->add('notice', 'Annonce bien modifiée.');

							  return $this->redirectToRoute('oc_platform_view', array('id' => $advert->getId()));
							}

							return $this->render('OCPlatformBundle:Advert:edit.html.twig', array(
							  'advert' => $advert,
							  'form'   => $form->createView(),
							));
						  }
						  
				L'action « supprimer » du contrôleur

					Enfin, voici l'action pour supprimer une annonce. On la protège derrière un formulaire presque vide. Je dis « presque », car le formulaire va automatiquement contenir un champ CSRF, c'est justement ce que nous recherchons en l'utilisant, pour éviter qu'une faille permette de faire supprimer une annonce. Vous trouverez plus d'informations sur la faille CSRF sur Wikipédia.

						<?php
						// src/OC/PlatformBundle/Controller/AdvertController.php

						  public function deleteAction(Request $request, $id)
						  {
							$em = $this->getDoctrine()->getManager();

							$advert = $em->getRepository('OCPlatformBundle:Advert')->find($id);

							if (null === $advert) {
							  throw new NotFoundHttpException("L'annonce d'id ".$id." n'existe pas.");
							}

							// On crée un formulaire vide, qui ne contiendra que le champ CSRF
							// Cela permet de protéger la suppression d'annonce contre cette faille
							$form = $this->get('form.factory')->create();

							if ($request->isMethod('POST') && $form->handleRequest($request)->isValid()) {
							  $em->remove($advert);
							  $em->flush();

							  $request->getSession()->getFlashBag()->add('info', "L'annonce a bien été supprimée.");

							  return $this->redirectToRoute('oc_platform_home');
							}
							
							return $this->render('OCPlatformBundle:Advert:delete.html.twig', array(
							  'advert' => $advert,
							  'form'   => $form->createView(),
							));
						  }
						  
						  
					Je vous invite par la même occasion à faire la vuedelete.html.twig. Voici ce que j'obtiens de mon côté :

						{# src/OC/PlatformBundle/Resources/views/Advert/delete.html.twig #}

						{% extends "OCPlatformBundle::layout.html.twig" %}

						{% block title %}
						  Supprimer une annonce - {{ parent() }}
						{% endblock %}

						{% block ocplatform_body %}

						  <h2>Supprimer une annonce</h2>

						  <p>
							Etes-vous certain de vouloir supprimer l'annonce "{{ advert.title }}" ?
						  </p>

						  {# On met l'id de l'annonce dans la route de l'action du formulaire #}
						  <form action="{{ path('oc_platform_delete', {'id': advert.id}) }}" method="post">
							<a href="{{ path('oc_platform_view', {'id': advert.id}) }}" class="btn btn-default">
							  <i class="glyphicon glyphicon-chevron-left"></i>
							  Retour à l'annonce
							</a>
							{# Ici j'ai écrit le bouton de soumission à la main #}
							<input type="submit" value="Supprimer" class="btn btn-danger" />
							{# Ceci va générer le champ CSRF #}
							{{ form_rest(form) }}
						  </form>

						{% endblock %}
						
					Le rendu est celui de la figure suivante.

						Confirmation de suppression


				Pour conclure

					Ce chapitre se termine ici. Son contenu est très imposant mais cohérent. Dans tous les cas, et plus encore pour ce chapitre, vous devez absolument vous entraîner en parallèle de votre lecture, pour bien assimiler et être sûrs de bien comprendre toutes les notions.

					Mais bien entendu, vous ne pouvez pas vous arrêter en si bon chemin. Maintenant que vos formulaires sont opérationnels, il faut bien vérifier un peu ce que vos visiteurs vont y mettre comme données ! C'est l'objectif du prochain chapitre, qui traite de la validation des données, justement. Il vient compléter le chapitre actuel, continuez donc la lecture !

				En résumé

					Un formulaire se construit sur un objet existant, et son objectif est d'hydrater cet objet.
					Un formulaire se construit grâce à unFormBuilder, et dans un fichierXxxTypeindépendant.
					En développement, le rendu d'un formulaire se fait en une seule ligne grâce à la méthode{{ form(form) }}.
					Il est possible d'imbriquer les formulaires grâce auxXxxType.
					Le type de champCollectionType affiche une liste de champs d'un certain type.
					Le type de champEntityType retourne une ou plusieurs entités.
					Il est possible d'utiliser le mécanisme d'héritage pour créer des formulaires différents mais ayant la même base.
					Le type de champFileType permet l'upload de fichier, et se couple aux entités grâce aux évènements Doctrine.
					Le code du cours tel qu'il doit être à ce stade est disponible sur la branche iteration-14 du dépot Github.
			
			
		
		2. Validez vos données
		
			Pourquoi valider des données ?

				Never trust user input

					Ce chapitre introduit la validation des objets avec le composant Validator de Symfony. En effet, c'est normalement un des premiers réflexes à avoir lorsque l'on demande à l'utilisateur de remplir des informations : vérifier ce qu'il rempli ! Il faut toujours considérer que soit il ne sait pas remplir un formulaire, soit c'est un petit malin qui essaie de trouver la faille. Bref, ne jamais faire confiance à ce que l'utilisateur vous donne (« never trust user input » en anglais).

					La validation et les formulaires sont bien sûr liés, dans le sens où les formulaires ont besoin de la validation. Mais l'inverse n'est pas vrai ! Dans Symfony, le validator est un service indépendant et n'a nul besoin d'un formulaire pour exister. Ayez-le en tête, avec le validator, on peut valider n'importe quel objet, entité ou non, le tout sans avoir besoin de formulaire.

				L'intérêt de la validation

					L'objectif de ce chapitre est donc d'apprendre à définir qu'un objet est valide ou pas. Plus concrètement, il nous faudra établir des règles précises pour dire que tel attribut (le nom d'auteur par exemple) doit faire 3 caractères minimum, que tel autre attribut (l'âge par exemple) doit être compris entre 7 et 77 ans, etc. En vérifiant les données avant de les enregistrer en base de données, on est certain d'avoir une base de données cohérente, en laquelle on peut avoir confiance !

				La théorie de la validation

					La théorie, très simple, est la suivante. On définit des règles de validation que l'on va rattacher à une classe. Puis on fait appel à un service extérieur pour venir lire un objet (instance de ladite classe) et ses règles, et définir si oui ou non l'objet en question respecte ces règles. Simple et logique !


				Définir les règles de validation

					Les différentes formes de règles

						Pour définir ces règles de validation, ou contraintes, il existe deux moyens :

							Le premier est d'utiliser les annotations, vous les connaissez maintenant. Leur avantage est d'être situées au sein même de l'entité, et juste à côté des annotations du mapping  Doctrine si vous les utilisez également pour votre mapping.
							
							Le deuxième est d'utiliser le YAML, XML ou PHP. Vous placez donc vos règles de validation hors de l'entité, dans un fichier séparé.

						Les deux moyens sont parfaitement équivalents en termes de fonctionnalités. Le choix se fait donc selon vos préférences. Dans la suite du cours, j'utiliserai les annotations, car je trouve extrêmement pratique de centraliser règles de validation et mapping Doctrine au même endroit. Facile à lire et à modifier. ;)

				Définir les règles de validation

					Préparation

						Nous allons prendre l'exemple de notre entité Advert pour construire nos règles. La première étape consiste à déterminer les règles que nous voulons avec des mots, comme ceci :

							La date doit être une date valide ;
							Le titre doit faire au moins 10 caractères de long ;
							Le contenu ne doit pas être vide ;
							Le nom de l'auteur doit faire au moins 2 caractères de long ;
							L'image liée doit être valide selon les règles attachées à l'objet Image.

						À partir de cela, nous pourrons convertir ces mots en annotations.

						
						Annotations

							Pour définir les règles de validation, nous allons donc utiliser les annotations. La première chose à savoir est le namespace des annotations à utiliser. Souvenez-vous, pour le mapping Doctrine c'était @ORM, ici nous allons utiliser @Assert, donc le namespace complet est le suivant :

								<?php
								use Symfony\Component\Validator\Constraints as Assert;

							Ce use est à rajouter au début de l'objet que l'on va valider, notre entité Advert en l'occurrence. En réalité, vous pouvez définir l'alias à autre chose qu'Assert. Mais c'est une convention qui s'est installée, donc autant la suivre pour avoir un code plus facilement lisible pour les autres développeurs.

							Ensuite, il ne reste plus qu'à ajouter les annotations pour traduire les règles que l'on vient de lister. Sans plus attendre, voici donc la syntaxe à respecter. Exemple avec notre objet Advert :

								<?php
								// src/OC/PlatformBundle/Entity/Advert.php

								namespace OC\PlatformBundle\Entity;

								use Doctrine\Common\Collections\ArrayCollection;
								use Doctrine\ORM\Mapping as ORM;
								use Gedmo\Mapping\Annotation as Gedmo;
								// N'oubliez pas de rajouter ce « use », il définit le namespace pour les annotations de validation
								use Symfony\Component\Validator\Constraints as Assert;

								/**
								 * @ORM\Table(name="oc_advert")
								 * @ORM\Entity(repositoryClass="OC\PlatformBundle\Repository\AdvertRepository")
								 * @ORM\HasLifecycleCallbacks()
								 */
								class Advert
								{
								  /**
								   * @ORM\Column(name="id", type="integer")
								   * @ORM\Id
								   * @ORM\GeneratedValue(strategy="AUTO")
								   */
								  private $id;

								  /**
								   * @ORM\Column(name="date", type="datetime")
								   * @Assert\DateTime()
								   */
								  private $date;

								  /**
								   * @ORM\Column(name="title", type="string", length=255)
								   * @Assert\Length(min=10)
								   */
								  private $title;

								  /**
								   * @ORM\Column(name="author", type="string", length=255)
								   * @Assert\Length(min=2)
								   */
								  private $author;

								  /**
								   * @ORM\Column(name="content", type="text")
								   * @Assert\NotBlank()
								   */
								  private $content;

								  /**
								   * @ORM\OneToOne(targetEntity="OC\PlatformBundle\Entity\Image", cascade={"persist", "remove"})
								   * @Assert\Valid()
								   */
								  private $image;
								  
								  // ...
								}

							Vraiment pratique d'avoir les métadonnées Doctrine et les règles de validation au même endroit, n'est-ce pas ?

								J'ai pris l'exemple ici d'une entité, car ce sera souvent le cas. Mais n'oubliez pas que vous pouvez mettre des règles de validation sur n'importe quel objet, qui n'est pas forcément une entité.

						Syntaxe

							Revenons un peu sur les annotations que l'on a ajoutées. Nous avons utilisé la forme simple, qui est construite comme ceci :

								@Assert\Contrainte(valeur de l'option par défaut)

							Avec :

								La Contrainte, qui peut être, comme vous l'avez vu, NotBlank ou Length, etc. Nous voyons plus loin toutes les contraintes possibles.

								La Valeur entre parenthèses, qui est la valeur de l'option par défaut. En effet chaque contrainte a plusieurs options, dont une par défaut souvent intuitive. Par exemple, l'option par défaut de Type est la valeur du type à restreindre.

							Mais on peut aussi utiliser la forme étendue qui permet de personnaliser la valeur de plusieurs options en même temps, comme ceci :

								@Assert\Contrainte(option1="valeur1", option2="valeur2", …)

							Les différentes options diffèrent d'une contrainte à une autre, mais voici un exemple avec la contrainte Length :

								@Assert\Length(min=10, minMessage="Le titre doit faire au moins {{ limit }} caractères.")

									Oui, vous pouvez utilisez {{ limit }}, qui est ici la longueur minimum définie dans le l'option "min".

								Bien entendu, vous pouvez mettre plusieurs contraintes sur un même attribut. Par exemple pour un attribut représentant une URL, on pourrait mettre les deux contraintes suivantes :

									<?php
									/**
									 * @Assert\Length(max=255)
									 * @Assert\Url()
									 */
									private $note

								Vous savez tout ! Il n'y a rien de plus à connaître sur les annotations. À part les contraintes existantes et leurs options, évidemment.

							Liste des contraintes existantes

								Voici un tableau qui regroupe la plupart des contraintes, à avoir sous la main lorsque vous définissez vos règles de validation ! Elles sont bien entendu toutes documentées, donc n'hésitez pas à vous référer à la documentation officielle pour toute information supplémentaire.

								Toutes les contraintes disposent de l'option message, qui est le message à afficher lorsque la contrainte est violée. Je n'ai pas répété cette option dans les tableaux suivants, mais sachez qu'elle existe bien à chaque fois.

							Contraintes de base :

								Contrainte
									Rôle
										Options

								NotBlank
									La contrainte Blank fait l'inverse.
										-
								Blank
									La contrainte NotBlank vérifie que la valeur soumise n'est ni une chaîne de caractères vide, ni NULL.
										-

								True
									La contrainte False vérifie que la valeur vaut false, 0 ou "0".
										-
								False
									La contrainte True vérifie que la valeur vaut true, 1 ou "1".
										-
										
								NotNull
									La contrainte Null vérifie que la valeur est strictement égale à null.
										-
								Null
									La contrainte NotNull vérifie que la valeur est strictement différente de null.
										-

								Type
									La contrainte Type vérifie que la valeur est bien du type donné en argument.
										type (option par défaut) : le type duquel doit être la valeur, parmi array, bool, int, object, etc.

							Contraintes sur des chaînes de caractères :

								Contrainte
									Rôle
										Options
										
								Email
									La contrainte Email vérifie que la valeur est une adresse e-mail valide.
										checkMX (défaut : false) : si défini à true, Symfony va vérifier les MX de l'e-mail via la fonction checkdnsrr.

								Length
									La contrainte Length vérifie que la valeur donnée fait au moins X ou au plus Y caractères de long.
										min : le nombre de caractères minimum à respecter.
										max : le nombre de catactères maximum à respecter.
										minMessage : le message d'erreur dans le cas où la contrainte minimum n'est pas respectée.
										maxMessage : le message d'erreur dans le cas où la contrainte maximum n'est pas respectée.
										charset (défaut : UTF-8) : le charset à utiliser pour calculer la longueur.

								Url
									La contrainte Url vérifie que la valeur est une adresse URL valide.
										protocols (défaut : array('http', 'https')) : définit les protocoles considérés comme valides.
										Si vous voulez accepter les URL en ftp://, ajoutez-le à cette option.

								Regex
									La contrainte Regex vérifie la valeur par rapport à une regex.
										pattern (option par défaut) : la regex à faire correspondre.
										match (défaut : true) : définit si la valeur doit (true) ou ne doit pas (false) correspondre à la regex.

								Ip
									La contrainte Ip vérifie que la valeur est une adresse IP valide.
										type (défaut : 4) : version de l'IP à considérer. 4 pour IPv4, 6 pour IPv6, all pour toutes les versions, et d'autres.

								Language
									La contrainte Language vérifie que la valeur est un code de langage valide selon la norme.
										-
								Locale
									La contrainte Locale vérifie que la valeur est une locale valide. Exemple : fr ou fr_FR.
										-
								Country
									La contrainte Country vérifie que la valeur est un code pays en 2 lettres valide. Exemple : fr.
										-

							Contraintes sur les nombres :

								Contrainte
									Rôle
										Options
								Range
									La contrainte Range vérifie que la valeur ne dépasse pas X, ou qu'elle dépasse Y.
										min : la valeur minimum à respecter.
										max : la valeur maximum à respecter.
										minMessage : le message d'erreur dans le cas où la contrainte minimum n'est pas respectée.
										maxMessage : le message d'erreur dans le cas où la contrainte maximum n'est pas respectée.
										invalidMessage : message d'erreur lorsque la valeur n'est pas un nombre.

							Contraintes sur les dates :

								Contrainte
									Rôle
										Options
								Date
									La contrainte Date vérifie que la valeur est un objet de type Datetime, ou une chaîne de caractères du type YYYY-MM-DD.
										-
								Time
									La contrainte Time vérifie que la valeur est un objet de type Datetime, ou une chaîne de caractères du type HH:MM:SS.
										-
								DateTime
									La contrainte Datetime vérifie que la valeur est un objet de type Datetime, ou une chaîne de caractères du type YYYY-MM-DD HH:MM:SS.
										-

							Contraintes sur les fichiers :

								Contrainte
									Rôle
										Options
								File
									La contrainte File vérifie que la valeur est un fichier valide, c'est-à-dire soit une chaîne de caractères qui pointe vers un fichier existant, soit une instance de la classe File (ce qui inclut UploadedFile).
										maxSize : la taille maximale du fichier. Exemple : 1M ou 1k.
										mimeTypes : mimeType(s) que le fichier doit avoir.

								Image
									La contrainte Image vérifie que la valeur est valide selon la contrainte précédente File (dont elle hérite les options), sauf que les mimeTypes acceptés sont automatiquement définis comme ceux de fichiers images. Il est également possible de mettre des contraintes sur la hauteur max ou la largeur max de l'image.
										maxSize : la taille maximale du fichier. Exemple : 1M ou 1k.
										minWidth / maxWidth : la largeur minimale et maximale que doit respecter l'image.
										minHeight / maxHeight : la hauteur minimale et maximale que doit respecter l'image.


							Les noms de contraintes sont sensibles à la casse. Cela signifie que la contrainte DateTime existe, mais que Datetime ou datetime n'existent pas ! Soyez attentifs à ce détail pour éviter des erreurs inattendues. ;)

							Je ne vous ai listé que les contraintes les plus fréquentes. Il en existe d'autres que je vous invite à découvrir dans la documentation.
	
	
					Déclencher la validation

						Le service Validator

							Comme je l'ai dit précédemment, ce n'est pas l'objet qui se valide tout seul, on doit déclencher la validation nous-mêmes. Ainsi, vous pouvez tout à fait assigner une valeur non valide à un attribut sans qu'aucune erreur ne se déclenche. Par exemple, vous pouvez faire $advert->setTitle('abc') alors que ce titre a moins de 10 caractères. Il est invalide mais rien ne se passera.

							Pour valider l'objet, on passe par un acteur externe : le service validator. Ce service s'obtient comme n'importe quel autre service :

								<?php
								// Depuis un contrôleur

								$validator = $this->get('validator');

							Ensuite, on doit demander à ce service de valider notre objet. Cela se fait grâce à la méthode validate du service. Cette méthode retourne un objet qui est soit vide si l'objet est valide, soit rempli des différentes erreurs lorsque l'objet n'est pas valide. Pour bien comprendre, exécutez cette méthode dans un contrôleur :

								<?php
								// Depuis un contrôleur

								// …

								  public function testAction()
								  {
									$advert = new Advert;
										
									$advert->setDate(new \Datetime());  // Champ « date » OK
									$advert->setTitle('abc');           // Champ « title » incorrect : moins de 10 caractères
									//$advert->setContent('blabla');    // Champ « content » incorrect : on ne le définit pas
									$advert->setAuthor('A');            // Champ « author » incorrect : moins de 2 caractères
										
									// On récupère le service validator
									$validator = $this->get('validator');
										
									// On déclenche la validation sur notre object
									$listErrors = $validator->validate($advert);

									// Si $listErrors n'est pas vide, on affiche les erreurs
									if(count($listErrors) > 0) {
									  // $listErrors est un objet, sa méthode __toString permet de lister joliement les erreurs
									  return new Response((string) $listErrors);
									} else {
									  return new Response("L'annonce est valide !");
									}
								  }
								  
							Vous pouvez vous amuser avec le contenu de l'entité Advert pour voir comment réagit le validateur.


						La validation automatique sur les formulaires

							En pratique, on ne se servira que très peu du service validator nous-mêmes. En effet, le formulaire de Symfony le fait à notre place ! Nous venons de voir le fonctionnement du service validator pour comprendre comment l'ensemble marche, mais en réalité on l'utilisera très peu de cette manière.

							Rappelez-vous le code pour la soumission d'un formulaire :

								<?php
								if ($form->handleRequest($request)->isValid()) {
								  // ...
								}
								
							Dans la méthode handleRequest, le formulaire $form va lui-même faire appel au service validator, et valider l'objet qui vient d'être hydraté par le formulaire. Ensuite, la méthode isValid vient compter le nombre d'erreur et retourne false s'il y a au moins une erreur. Derrière cette ligne se cache donc le code que nous avons vu au paragraphe précédent. Les erreurs sont assignées au formulaire, et sont affichées dans la vue. Nous n'avons rien à faire, pratique !

						Conclusion

							Cette section a pour objectif de vous faire comprendre ce qu'il se passe déjà lorsque vous utilisez la méthode isValid d'un formulaire. De plus, vous savez qu'il est possible de valider un objet indépendamment de tout formulaire, en mettant la main à la pâte.


				Encore plus de règles de validation

					Valider depuis un getter

						Le composant Validation accepte les contraintes sur les attributs, mais également sur les getters ! C'est très pratique, car vous pouvez alors mettre une contrainte sur une fonction, avec toute la liberté que cela vous apporte. Vous le savez, un getter est une méthode qui commence le plus souvent par « get », mais qui peut également commencer par « is ».

						Tout de suite, un exemple d'utilisation :

							<?php
							class Advert
							{

							  // …

							  /**
							   * @Assert\IsTrue()
							   */
							  public function isAdvertValid()
							  {
								return false;
							  }
							}
							
						Cet exemple vraiment basique considère toujours l'annonce comme non valide, car l'annotation @Assert\IsTrue() attend que la méthode retourne true, alors qu'ici la méthode retourne false. Vous pouvez l'essayer dans votre formulaire, vous verrez le message « Cette valeur doit être vraie » (message par défaut de l'annotation IsTrue()) qui s'affiche en haut du formulaire. C'est donc une erreur qui s'applique à l'ensemble du formulaire.

						Mais il existe un moyen de déclencher une erreur liée à un champ en particulier, ainsi l'erreur s'affichera juste à côté de ce champ. Il suffit de nommer le getter « is + le nom d'un attribut » : par exemple isTitle si l'on veut valider le title. Essayez par vous-mêmes le code suivant :

							<?php
							class Advert
							{

							  // …

							  /**
							   * @Assert\IsTrue()
							   */
							  public function isTitle()
							  {
								return false;
							  }
							}
							
						Vous verrez que l'erreur « Cette valeur doit être vraie » s'affiche bien à côté du champ title.

						Bien entendu, vous pouvez faire plein de traitements et de vérifications dans cette méthode, ici j'ai juste mis return false pour l'exemple. Je vous laisse imaginer les possibilités.


					Valider intelligemment un attribut objet

						Derrière ce titre se cache une problématique toute simple : lorsque je valide un objet A, comment valider un objet B en attribut, d'après ses propres règles de validation ?

						Il faut utiliser la contrainte Valid, qui va déclencher la validation du sous-objet B selon les règles de validation de cet objet B. Prenons un exemple :

							<?php
							class A
							{
							  /**
							   * @Assert\Length(min=5)
							   */
							  private $title;

							  /**
							   * @Assert\Valid()
							   */
							  private $b;
							}

							class B
							{
							  /**
							   * @Assert\Range(max=10)
							   */
							  private $number;
							}
							
						Avec cette règle, lorsqu'on déclenche la validation sur l'objet A, le service validator va valider l'attribut title selon le Length(), puis va aller chercher les règles de l'objet B pour valider l'attribut number de B selon le Range(). N'oubliez pas cette contrainte, car valider un sous-objet n'est pas le comportement par défaut : sans cette règle Valid  dans notre exemple, vous auriez pu sans problème ajouter une instance de B qui ne respecte pas la contrainte de 10 minimum pour son attribut number. Vous pourriez donc rencontrer des petits soucis de logique si vous l'oubliez.


					Valider depuis un Callback

						L'objectif de la contrainte Callback est d'être personnalisable à souhait. En effet, vous pouvez parfois avoir besoin de valider des données selon votre propre logique, qui ne rentre pas dans un Length par exemple.

						L'exemple classique est la censure de mots non désirés dans un attribut texte. Reprenons notre Advert, et considérons que l'attribut content ne peut pas contenir les mots « démotivation » et « abandon ». Voici comment mettre en place une règle qui va rendre invalide le contenu s'il contient l'un de ces mots :

							<?php
							// src/OC/PlatformBundle/Entity/Advert.php

							namespace OC\PlatformBundle\Entity;

							use Symfony\Component\Validator\Constraints as Assert;
							// Ajoutez ce use pour le contexte
							use Symfony\Component\Validator\Context\ExecutionContextInterface;

							/**
							 * @ORM\Entity
							 */
							class Advert
							{
							  // …
								
							  /**
							   * @Assert\Callback
							   */
							  public function isContentValid(ExecutionContextInterface $context)
							  {
								$forbiddenWords = array('démotivation', 'abandon');

								// On vérifie que le contenu ne contient pas l'un des mots
								if (preg_match('#'.implode('|', $forbiddenWords).'#', $this->getContent())) {
								  // La règle est violée, on définit l'erreur
								  $context
									->buildViolation('Contenu invalide car il contient un mot interdit.') // message
									->atPath('content')                                                   // attribut de l'objet qui est violé
									->addViolation() // ceci déclenche l'erreur, ne l'oubliez pas
								  ;
								}
							  }
							}
							
						Vous auriez même pu aller plus loin en comparant des attributs entre eux, par exemple pour interdire le pseudo dans un mot de passe. L'avantage du Callback par rapport à une simple contrainte sur un getter, c'est de pouvoir ajouter plusieurs erreurs à la fois, en définissant sur quel attribut chacune se trouve grâce à la méthode atPath (en mettant content ou title, etc). Souvent la contrainte sur un getter suffira, mais pensez à ce Callback pour les fois où vous serez limités. 


					Valider un champ unique

						Il existe une dernière contrainte très pratique : UniqueEntity. Cette contrainte permet de valider que la valeur d'un attribut est unique parmi toutes les entités existantes. Pratique pour vérifier qu'une adresse e-mail n'existe pas déjà dans la base de données par exemple.

						Vous avez bien lu, j'ai parlé d'entité. En effet, c'est une contrainte un peu particulière, car elle ne se trouve pas dans le composant Validator (qui lui est indépendant de Doctrine), mais dans le bridge entre Doctrine et Symfony (ce qui fait le lien entre ces deux bibliothèques). On n'utilisera donc pas @Assert\UniqueEntity, mais simplement @UniqueEntity. Il faut bien sûr en contrepartie faire attention de rajouter ce use à chaque fois que vous l'utilisez :

							use Symfony\Bridge\Doctrine\Validator\Constraints\UniqueEntity;

						Voici comment on pourrait, dans notre exemple avec Advert, contraindre nos titres à être tous différents les uns des autres :

							<?php
							// src/OC/PlatformBundle/Entity/Advert.php

							namespace OC\PlatformBundle\Entity;

							use Doctrine\ORM\Mapping as ORM;
							// On rajoute ce use pour la contrainte :
							use Symfony\Bridge\Doctrine\Validator\Constraints\UniqueEntity;

							/**
							 * @ORM\Entity
							 * @UniqueEntity(fields="title", message="Une annonce existe déjà avec ce titre.")
							 */
							class Advert
							{
							  /**
							   * @var string
							   *
							   * Et pour être logique, il faudrait aussi mettre la colonne titre en Unique pour Doctrine :
							   * @ORM\Column(name="title", type="string", length=255, unique=true)
							   */
							  private $title;
							  
							  // ...
							}
							
						Attention, ici l'annotation se définit sur la classe, et non sur une méthode ou sur un attribut.

							Le validateur indique au formulaire que le titre existe déjà. Le formulaire m'affiche l'erreur.

							Le validateur indique au formulaire que le titre existe déjà en base de données. Le formulaire m'affiche ensuite l'erreur.

						Je vous invite à faire un tour dans l'onglet Forms du profiler, c'est souvent une mine d'informations sur vos formulaires et leurs erreurs. La figure suivante montre par exemple l'erreur que nous avons sur ce titre déjà existant.

							L'erreur est bien attaché au champ titre.


					Valider selon nos propres contraintes

						Vous commencez à vous habituer : avec Symfony il est possible de tout faire ! L'objectif de cette section est d'apprendre à créer notre propre contrainte, que l'on pourra utiliser en annotation : @NotreContrainte. L'avantage d'avoir sa propre contrainte est double :

							D'une part, c'est une contrainte réutilisable sur vos différents objets : on pourra l'utiliser sur Advert, mais également sur Application, etc. ;

							D'autre part, cela permet de placer le code de validation dans un objet externe… et surtout dans un service ! Indispensable, vous comprendrez.

						Une contrainte est toujours liée à un validateur, qui va être en mesure de valider la contrainte. Nous allons donc les faire en deux étapes. Pour l'exemple, nous allons créer une contrainte AntiFlood, qui impose un délai de 15 secondes entre chaque message posté sur le site (que ce soit une annonce ou une candidature).


						Créer la contrainte

							Tout d'abord, il faut créer la contrainte en elle-même : c'est celle que nous appellerons en annotation depuis nos objets. Une classe de contrainte est vraiment très basique, toute la logique se trouvera en réalité dans le validateur. Je vous invite donc simplement à créer le fichier suivant :

								<?php
								// src/OC/PlatformBundle/Validator/Antiflood.php

								namespace OC\PlatformBundle\Validator;

								use Symfony\Component\Validator\Constraint;

								/**
								 * @Annotation
								 */
								class Antiflood extends Constraint
								{
								  public $message = "Vous avez déjà posté un message il y a moins de 15 secondes, merci d'attendre un peu.";
								}
								
							L'annotation @Annotation est nécessaire pour que cette nouvelle contrainte soit disponible via les annotations dans les autres classes. En effet, toutes les classes ne sont pas des annotations, heureusement. 

							Les options de l'annotation correspondent en réalité aux attributs publics de la classe d'annotation. Ici, on a l'attribut message, on pourra donc faire :

								@Antiflood(message="Mon message personnalisé")

							C'est tout pour la contrainte ! Passons au validateur.


						Créer le validateur

							C'est la contrainte qui décide par quel validateur elle doit se faire valider. Par défaut, une contrainte Xxx demande à se faire valider par le validateur XxxValidator. Créons donc le validateur AntifloodValidator :

								<?php
								// src/OC/PlatformBundle/Validator/AntifloodValidator.php

								namespace OC\PlatformBundle\Validator;

								use Symfony\Component\Validator\Constraint;
								use Symfony\Component\Validator\ConstraintValidator;

								class AntifloodValidator extends ConstraintValidator
								{
								  public function validate($value, Constraint $constraint)
								  {
									// Pour l'instant, on considère comme flood tout message de moins de 3 caractères
									if (strlen($value) < 3) {
									  // C'est cette ligne qui déclenche l'erreur pour le formulaire, avec en argument le message de la contrainte
									  $this->context->addViolation($constraint->message);
									}
								  }
								}
								
							C'est tout pour le validateur. Il n'est pas très compliqué non plus, il contient juste une méthode validate() qui permet de valider ou non la valeur. Son argument $value correspond à la valeur de l'attribut sur laquelle on a défini l'annotation. Par exemple, si l'on avait défini l'annotation comme ceci :

								/**
								 * @Antiflood()
								 */
								private $content;
								
							… alors c'est tout logiquement le contenu de l'attribut $contenu au moment de la validation qui sera injecté en tant qu'argument $value.

							La méthode validate() ne doit pas renvoyer true ou false pour confirmer que la valeur est valide ou non. Elle doit juste lever une Violation si la valeur est invalide. C'est ce qu'on a fait ici dans le cas où la chaîne fait moins de 3 caractères : on ajoute une violation, dont l'argument est le message d'erreur (accessible publiquement dans l'attribut de la contrainte).

							Il y a deux moyens de définir une violation :

								Lorsque vous n'avez que le message de l'erreur à passer, vous pouvez utiliser la méthode addViolation  qu'on a utilisé ici.
								
								Lorsque vous avez plus, comme dans notre précédent callback où on définissait l'attribut sur laquelle attacher la violation, alors vous pouvez utiliser la méthode buildViolation qu'on a utilisé précédemment.

							Sachez aussi que vous pouvez utiliser des messages d'erreur avec des paramètres. Par exemple : "Votre message %string% est considéré comme flood". Pour définir ce paramètre %string% utilisé dans le message, il faut utiliser la deuxième méthode pour définir la violation, comme ceci :

								<?php
								$this->context
								  ->buildViolation($constraint->message)
								  ->setParameters(array('%string%' => $value))
								  ->addViolation()
								;

							Et voilà, vous savez créer votre propre contrainte ! Pour l'utiliser, c'est comme n'importe quelle autre annotation : on importe le namespace de l'annotation, et on la met en commentaire juste avant l'attribut concerné. Voici un exemple sur l'entité Advert :

								<?php
								// src/OC/PlatformBundle/Entity/Advert.php

								namespace OC\PlatformBundle\Entity;

								use OC\PlatformBundle\Validator\Antiflood;

								class Advert
								{
								  /**
								   * @Assert\NotBlank()
								   * @Antiflood()
								   */
								  private $content;

								  // …
								}

							Votre annotation sera ainsi prise en compte au même titre que le @Assert\NotBlank par exemple ! Et bien sûr, vous pouvez l'utiliser sur tous les objets que vous voulez : Advert, Application, etc. N'hésitez pas à la tester dès maintenant (essayez de créer une annonce avec un contenu qui a moins de 3 caractères), elle fonctionne déjà.

							Mais si vous avez bien suivi, vous savez qu'on n'a pas encore vu le principal intérêt de nos propres contraintes : la validation par un service !


						Transformer son validateur en service

							Un service on l'a déjà vu, c'est un objet qui remplit une fonction et auquel on peut accéder de presque n'importe où dans votre code Symfony. Dans ce paragraphe, voyons comment s'en servir dans le cadre de nos contraintes de validation.

								Quel est l'intérêt d'utiliser un service pour valider une contrainte ?

							Rappelez vous notre objectif pour cette contrainte d'anti-flood : on veut empêcher quelqu'un de poster à moins de 15 secondes d'intervalle. Il nous faut donc un accès à son IP pour le reconnaitre, et à la base de données pour savoir quand était son dernier post. Tout cela est impossible sans service.

							L'intérêt est donc qu'un service peut accéder à toutes sortes d'informations utiles. Il suffit de créer un service, de lui « injecter » les données, et il pourra ainsi s'en servir. Dans notre cas, on va lui injecter la requête et l'EntityManager comme données : il pourra ainsi valider notre contrainte non seulement à partir de la valeur $value d'entrée, mais également en fonction de paramètres extérieurs qu'on ira chercher dans la base de données !

							Définition du service

								Prenons un exemple pour bien comprendre le champ des possibilités. Il nous faut créer un service, en y injectant les services request_stack et entity_manager, et en y apposant le tag validator.contraint_validator. Voici ce que cela donne, dans le fichier services.yml dans votre bundle :

									# src/OC/PlatformBundle/Resources/config/services.yml

									services:
										oc_platform.validator.antiflood:                              # Le nom du service
											class: OC\PlatformBundle\Validator\AntifloodValidator     # La classe du service, ici notre validateur déjà créé
											arguments: ["@request_stack", "@doctrine.orm.entity_manager"] # Les données qu'on injecte au service : la requête et l'EntityManager
											tags:
												- { name: validator.constraint_validator, alias: oc_platform_antiflood }  # C'est avec l'alias qu'on retrouvera le service

									Si le fichier services.yml n'existe pas déjà chez vous, c'est qu'il n'est pas chargé automatiquement. Pour cela, il faut faire une petite manipulation, je vous invite à lire le début du chapitre sur les services.

							Modification de la contrainte

								Maintenant que notre validateur est un service en plus d'être simplement un objet, nous devons adapter un petit peu notre code. Tout d'abord, modifions la contrainte pour qu'elle demande à se faire valider par le service d'alias oc_platform_antiflood et non plus simplement par l'objet classique AntifloodValidator. Pour cela, il suffit de lui rajouter la méthode validateBy() suivante (lignes 15 à 18) :

									<?php
									// src/OC/PlatformBundle/Validator/Antiflood.php

									namespace OC\PlatformBundle\Validator;

									use Symfony\Component\Validator\Constraint;

									/**
									 * @Annotation
									 */
									class Antiflood extends Constraint
									{
									  public $message = "Vous avez déjà posté un message il y a moins de 15 secondes, merci d'attendre un peu.";

									  public function validatedBy()
									  {
										return 'oc_platform_antiflood'; // Ici, on fait appel à l'alias du service
									  }
									}

							Modification du validateur

								Enfin, il faut adapter notre validateur pour que d'une part il récupère les données qu'on lui injecte, grâce au constructeur, et d'autre part qu'il s'en serve tout simplement :

									<?php
									// src/OC/PlatformBundle/Validator/AntifloodValidator.php

									namespace OC\PlatformBundle\Validator;

									use Doctrine\ORM\EntityManagerInterface;
									use Symfony\Component\HttpFoundation\RequestStack;
									use Symfony\Component\Validator\Constraint;
									use Symfony\Component\Validator\ConstraintValidator;

									class AntifloodValidator extends ConstraintValidator
									{
									  private $requestStack;
									  private $em;

									  // Les arguments déclarés dans la définition du service arrivent au constructeur
									  // On doit les enregistrer dans l'objet pour pouvoir s'en resservir dans la méthode validate()
									  public function __construct(RequestStack $requestStack, EntityManagerInterface $em)
									  {
										$this->requestStack = $requestStack;
										$this->em           = $em;
									  }

									  public function validate($value, Constraint $constraint)
									  {
										// Pour récupérer l'objet Request tel qu'on le connait, il faut utiliser getCurrentRequest du service request_stack
										$request = $this->requestStack->getCurrentRequest();

										// On récupère l'IP de celui qui poste
										$ip = $request->getClientIp();

										// On vérifie si cette IP a déjà posté une candidature il y a moins de 15 secondes
										$isFlood = $this->em
										  ->getRepository('OCPlatformBundle:Application')
										  ->isFlood($ip, 15) // Bien entendu, il faudrait écrire cette méthode isFlood, c'est pour l'exemple
										;

										if ($isFlood) {
										  // C'est cette ligne qui déclenche l'erreur pour le formulaire, avec en argument le message
										  $this->context->addViolation($constraint->message);
										}
									  }
									}

								Et voilà, nous venons de faire une contrainte qui s'utilise aussi facilement qu'une annotation, et qui pourtant fait un gros travail en allant chercher dans la base de données si l'IP courante envoie trop de messages. Un peu de travail à la création de la contrainte, mais son utilisation est un jeu d'enfant à présent !

									Je fais un petit apparté sur l'utilisation de la requête en dépendance d'un service. La requête en tant que telle n'est pas un service ! En effet, elle peut changer au cours de la page, notamment lorsque vous faites des sous-requêtes, par exemple avec l'utilisation de {{ render }} depuis une vue qui crée une nouvelle sous-requête. Elle peut également être null lorsque vous exécutez une commande depuis la console (la requête représentant la requête HTTP, en console elle n'existe pas !).

									Pour ces raisons, il faut passer par le service request_stack qui, dans sa méthode getCurrentRequest(), contient la requête courante (la requête principale ou la sous-requête), voir null s'il n'y a pas de requête.

									Vous trouverez un brin plus d'informations sur la page de la documentation sur la création de contrainte, notamment comment faire une contrainte qui s'applique non pas à un attribut, mais à une classe entière.

									Je n'ai pas écrit la méthode isFlood. Je ne le fais pas ici, mais c'est un bon exercice de votre côté ;) Il faudrait ajouter un attribut ip dans les entités Advert  et Application , puis écrire un service qui irait chercher si oui ou non l'ip courante a créé une annonce ou une application dans les X dernières secondes. A ce stade, vous êtes parfaitement capable de réaliser cette méthode.
									
									
									
									- méthode isFlood() - fonction d'un scénario de scénarios à placer dans un sous-scénario de l'application
										- localisation 
											- de la source de la fonction
												- les classes des repository des entités Advert et Aplication (création et mise à jour)
											- de l'appelle de la fonction 
												- dans la méthode validate() de la class AntifloodValidator
										- objectif de la fonction
											- formater(agréger|granulariser)|stocker(CRUD)
												- si, oui ou non, la soumission du formulaire est un Flood
													- de part
														- la nature du message
															- lenght > 3
														- la fréquence du message
															- entre 
																- les créations d'advert ou application diffrérentes
																	- si le délais entre les soumissions est respecté par rapport à l'ip courant de l'emméteur du formulaire
																		- Advert
																			- attribut
																				- date (entre dernière création de l'ip courant en base et date de nouvelle création)
																				- update_at (entre dernière mise à jour de l'ip courant en base et date de mise à jour)
																				- ip
																		- Application
																			- attribut
																				- date (entre dernière création de l'ip courant en base et date de nouvelle création)
																				- ip
																- les modifications d'advert ou application
																	- si le délais entre les soumissions est respecté par rapport à l'ip courant de l'emméteur du formulaire
																		- Advert
																			- attribut
																				- date (entre dernière création de l'ip courant en base et date de nouvelle création)
																				- update_at (entre dernière mise à jour de l'ip courant en base et date de mise à jour)
																				- ip
																		- Application
																			- attribut
																				- date (entre dernière création de l'ip courant en base et date de nouvelle création)
																				- ip
										- suite de l'exécution de la fonction
											- dans la méthode validate() de la class AntifloodValidator
												- en testant le retour
													- on ajoute le message d'erreur de la contrainte au context de validation de l'attribut de l'entité
										- avec les paramètres
											- ip du client
												- en string d'un patterne d'entiers
												- de source
													- définit par le request dans le contexte de la fonction validate() qui appelle la fonction isFlood()
												- vérification d'intégrité
													- pas besoin de le contrôler
											- délais
												- en entier de seconde
												- source
													- définit arbitrairement dans le fonction isFlood()
												- vérification d'intégrité
													- pas besoin de le contrôler
										- niveau de scalabilité de fonctions génériques* suivant les besoins* dans l'application de l'algorithme de la fonction
											- logique métier
												- appelle de cette fonction du repository Advert ou Application en question
													- où on affecte à une variable, l'appelle d'un service
														- qui instancie une classe
													- d'où, dans un return, on exécute une méthode
														- avec des paramètres
											- contrainte et besoins
												- utiliser un service
													- qui irait chercher si oui ou non l'ip courante a créé une annonce ou une application dans les X dernières secondes
											- structure
												- d'implémentation
													- [[[ Bundle ] Contrôleur ] Classe ] Méthode
												- mode d'appelle
													- Rooter | Use | Service | Event Composant | Annotation
												- de localisation d'appelle
													- Rooter | Contrôler | Modèle
										- notes
											- il n'y a pas de champs de mise à jour dans la table application
												- ne pas en créer
											- on ne peut pas savoir si on est dans une création ou une modification
												- que ce soit une création ou une modification
													- se limiter dans la méthode, à checker, suivant entité
														- à partir de l'ip
															- si la dernière date, de création ou de mise à jour
																- respecte le délais
											- trouver une solution pour envoyer à l'annotation de la contrainte AntiFlood() le nom de l'entité appelant
												- utiliser les session
													- en implémentant une clé dans validate()
													- et l'appelant dans isFlood()
												- en spécifiant la variable en public + la nommer dans l'identité de l'annotation
										- todo <<<<<<<<<<<< a-1
											- l'attribut ip
												- méthodologie de conception
													- Cordination des parties (à confronter)
														- Scrum + Redmine|Trello
														- Gaant + Pert
													- Cordination des développeur (à confronter)
														- UML
														- Merise
													- Mode de développement
														- TDD, BDD, DDD 
													- Normes
														- Design Pattern
														- solide
														- psr
												- de son contexte d'emploi
													- pour une création d'entités Advert et Aplication
														- est définit avant le persist de l'entité (avec ses entités liées)
														- todo <<<<<<<<<<<< a-2
															- créer l'attribut ip + annotation doctrine des paramètres du champs dans la table
																- Advert
																- Application (pas de formulaire de création et de modification de Candidatures, dans à ne pas traiter)
															- avant tout enregistrement de création
																- appeler du contrôler le setter de Ip avec pour argument l'ip courant du client
													- pour une modification d'entités Advert et Aplication
														- est 
															- récupéré du répository de l'entité (avec ses entités liées)
															- redéfinit, si on passe le Validator, avant le persist de l'entité (avec ses entités liées)
																- avant tout enregistrement e modification
																	- appeler du contrôler le setter de Ip avec pour argument l'ip courant du client
														- todo <<<<<<<<<<<<< a-3
															- rien à faire
											- la méthode isFlood()
												- méthodologie de conception
													- Cordination des parties (à confronter)
														- Scrum + Redmine|Trello
														- Gaant + Pert
													- Cordination des développeur (à confronter)
														- UML
														- Merise
													- Mode de développement
														- TDD, BDD, DDD
													- Normes
														- Design Pattern
														- solide
														- psr
												- de son contexte d'emploi
													- pour une création ou une modification d'entités Advert et Aplication
														- est définit dans la méthode validate() de la class AntifloodValidator
														- todo <<<<<<<<<<< a-4
															- créer une méthode isFlood() dans le répository de l'entité en question
																- qui instencie dans une variable, par l'appelle d'un un service
																	- l'objet d'une classe générique**
																- de laquelle on appellerait une méthode check(), en return
																	- avec pour paramètre
																		- l'entité manager
																		- un tableau d'attributs
																			- entity
																					cle1			=> 	a 			
																					cle2			=> OcPlatformBundle:Advert
																					champs date	=>
																						[ update_at, date]
																				ou
																					cle1			=> 	a 			
																					cle2			=> OcPlatformBundle:Application
																					champs date	=>
																						[ date ]
																			- ip => l'ip courant
																			- periode => timestamp
																	- qui**
																		- en DQL, dans une variable $query
																			- créer la requête de sélection, de l'entity manager 
																				- par la méthode createQuery
																					 - du répository de l'entité
																						- de l'entités en base, 
																							- dont le champs de l'ip correspond à celui du client
																							- dont la dernière date égale à
																								[- si exist de modification non null]
																								- de création
																							- dont la période, entre cette date et maintenant, est suppérieur à la periode fournis
																		- que l'on exécute et teste 
																			- si vide ou null
																				- renvoyer true
																			- sinon
																				- revoyer false


					Pour conclure

						Vous savez maintenant valider dignement vos données, félicitations !

						Le formulaire était le dernier point que vous aviez vraiment besoin d'apprendre. À partir de maintenant, vous pouvez créer un site internet en entier avec Symfony, il ne manque plus que la sécurité à aborder, car pour l'instant, sur notre plateforme d'annonce, tout le monde peut tout faire. Rendez-vous au prochain chapitre pour régler ce détail. 

					En résumé

						Le composant validator permet de valider les données d'un objet suivant des règles définies.
						Cette validation est systématique lors de la soumission d'un formulaire : il est en effet impensable de laisser l'utilisateur entrer ce qu'il veut sans vérifier !
						Les règles de validation se définissent via les annotations directement à côté des attributs de la classe à valider. Vous pouvez bien sûr utiliser d'autres formats tels que le YAML ou le XML.
						Il est également possible de valider à l'aide de getters, de callbacks ou même de services. Cela rend la procédure de validation très flexible et très puissante.
						Le code du cours tel qu'il doit être à ce stade est disponible sur la branche iteration-15 du dépot Github.
			
			
		
		3. Sécurité et gestion des utilisateurs
		
			Authentification et autorisation

				La sécurité sous Symfony est très poussée, vous pouvez la contrôler très finement, mais surtout très facilement. Pour atteindre ce but, Symfony a bien séparé deux mécanismes différents : l'authentification et l'autorisation. Prenez le temps de bien comprendre ces deux notions pour bien attaquer la suite du cours. :)

				Les notions d'authentification et d'autorisation

					L'authentification

						L'authentification est le processus qui va définir qui vous êtes, en tant que visiteur. L'enjeu est vraiment très simple : soit vous ne vous êtes pas identifié sur le site et vous êtes un anonyme, soit vous vous êtes identifié (via le formulaire d'identification ou via un cookie « Se souvenir de moi ») et vous êtes un membre du site. C'est ce que la procédure d'authentification va déterminer. Ce qui gère l'authentification dans Symfony s'appelle un firewall, ou un pare-feu en français.

						Ainsi vous pourrez sécuriser des parties de votre site Internet juste en forçant le visiteur à être un membre authentifié. Si le visiteur l'est, le firewall va le laisser passer, sinon il le redirigera sur la page d'identification. Cela se fera donc dans les paramètres du firewall, nous les verrons plus en détail par la suite.

					L'autorisation

						L'autorisation est le processus qui va déterminer si vous avez le droit d'accéder à la ressource (la page) demandée. Il agit donc après le firewall. Ce qui gère l'autorisation dans Symfony s'appelle l'access control.

						Par exemple, un membre identifié lambda aura accès à la liste de sujets d'un forum, mais ne peut pas supprimer de sujet. Seuls les membres disposant des droits d'administrateur le peuvent, c'est ce que l'access control va vérifier.

				Exemples

					Pour bien comprendre la différence entre l'authentification et l'autorisation, je reprends ici les exemples de la documentation officielle, qui sont, je trouve, très intéressants et illustratifs. Dans ces exemples, vous distinguerez bien les différents acteurs de la sécurité.

					Je suis anonyme, et je veux accéder à la page/fooqui ne requiert pas de droits

						Dans cet exemple, un visiteur anonyme souhaite accéder à la page/foo. Cette page ne requiert pas de droits particuliers, donc tous ceux qui ont réussi à passer le firewall peuvent y avoir accès. La figure suivante montre le processus.

							Schéma du processus de sécurité

						Sur ce schéma, vous distinguez bien le firewall d'un côté et l'access control (contrôle d'accès) de l'autre. Reprenons-le ensemble pour bien comprendre :

							Le visiteur n'est pas identifié, il est anonyme, et tente d'accéder à la page/foo.
							
							Le firewall est configuré de telle manière qu'il n'est pas nécessaire d'être identifié pour accéder à la page/foo. Il laisse donc passer notre visiteur anonyme.
							
							Le contrôle d'accès regarde si la page/foorequiert des droits d'accès : il n'y en a pas. Il laisse donc passer notre visiteur, qui n'a aucun droit particulier.
							
							Le visiteur a donc accès à la page/foo.

					Je suis anonyme, et je veux accéder à la page/admin/fooqui requiert certains droits

						Dans cet exemple, c'est le même visiteur anonyme qui veut accéder à la page/admin/foo. Mais cette fois, la page/admin/foorequiert le rôleROLE_ADMIN; c'est un droit particulier, nous le verrons plus loin. Notre visiteur va se faire refuser l'accès à la page, la figure suivante montre comment.

							Schéma du processus de sécurité

							Voici le processus pas à pas :

								Le visiteur n'est pas identifié, il est toujours anonyme, et tente d'accéder à la page/admin/foo.
								
								Le firewall est configuré de manière qu'il ne soit pas nécessaire d'être identifié pour accéder à la page/admin/foo. Il laisse donc passer notre visiteur.
								
								Le contrôle d'accès regarde si la page/admin/foorequiert des droits d'accès : oui, il faut le rôleROLE_ADMIN. Le visiteur n'a pas ce rôle, donc le contrôle d'accès lui interdit l'accès à la page/admin/foo.
								
								Le visiteur n'a donc pas accès à la page/admin/foo, et se fait rediriger sur la page d'identification.

					Je suis identifié, et je veux accéder à la page/admin/fooqui requiert certains droits

						Cet exemple est le même que précédemment, sauf que cette fois notre visiteur est identifié, il s'appelle Ryan. Il n'est donc plus anonyme.

							Schéma du processus de sécurité

								Ryan s'identifie et il tente d'accéder à la page/admin/foo. D'abord, le firewall confirme l'authentification de Ryan (c'est son rôle !). Visiblement c'est bon, il laisse donc passer Ryan.

								Le contrôle d'accès regarde si la page/admin/foorequiert des droits d'accès : oui, il faut le rôleROLE_ADMIN, que Ryan n'a pas. Il interdit donc l'accès à la page/admin/fooà Ryan.

								Ryan n'a pas accès à la page/admin/foonon pas parce qu'il ne s'est pas identifié, mais parce que son compte utilisateur n'a pas les droits suffisants. Le contrôle d'accès lui affiche donc une page d'erreur lui disant qu'il n'a pas les droits suffisants.

					Je suis identifié, et je veux accéder à la page/admin/fooqui requiert des droits que j'ai.

						Ici, nous sommes maintenant identifiés en tant qu'administrateur, on a donc le rôleROLE_ADMIN! Du coup, nous pouvons accéder à la page/admin/foo, comme le montre la figure suivante.

							Schéma du processus de sécurité

								L'utilisateur admin s'identifie, et il tente d'accéder à la page/admin/foo. D'abord, le firewall confirme l'authentification d'admin. Ici aussi, c'est bon, il laisse donc passer admin.
								
								Le contrôle d'accès regarde si la page/admin/foorequiert des droits d'accès : oui, il faut le rôleROLE_ADMIN, qu'admin a bien. Il laisse donc passer l'utilisateur.
								
								L'utilisateur admin a alors accès à la page/admin/foo, car il est identifié et il dispose des droits nécessaires.

				Processus général

					Lorsqu'un utilisateur tente d'accéder à une ressource protégée, le processus est finalement toujours le même, le voici :

						Un utilisateur veut accéder à une ressource protégée ;
						
						Le firewall redirige l'utilisateur au formulaire de connexion ;
						
						L'utilisateur soumet ses informations d'identification (par exemple login et mot de passe) ;
						
						Le firewall authentifie l'utilisateur ;
						
						L'utilisateur authentifié renvoie la requête initiale ;
						
						Le contrôle d'accès vérifie les droits de l'utilisateur, et autorise ou non l'accès à la ressource protégée.

					Ces étapes sont simples, mais très flexibles. En effet, derrière le mot « authentification » se cache en pratique bien des méthodes : un formulaire de connexion classique, mais également l'authentification via Facebook, Google, etc., ou via les certificats X.509, etc. Bref, le processus reste toujours le même, mais les méthodes pour authentifier vos internautes sont nombreuses, et répondent à tous vos besoins. Et, surtout, elles n'ont pas d'impact sur le reste de votre code : qu'un utilisateur soit authentifié via Facebook ou un formulaire classique ne change rien à vos contrôleurs !

			Première approche de la sécurité
				
				Si les processus que nous venons de voir sont relativement simples, leur mise en place et leur configuration nécessitent un peu de travail.

				Nous allons construire pas à pas la sécurité de notre application. Cette section commence donc par une approche théorique de la configuration de la sécurité avec Symfony (notamment l'authentification), puis on mettra en place un formulaire de connexion simple. On pourra ainsi s'identifier sur notre propre site, ce qui est plutôt intéressant ! Par contre, les utilisateurs ne seront pas encore liés à la base de données, on le verra un peu plus loin, avançons doucement.

				Le fichier de configuration de la sécurité

					La sécurité étant un point important, elle a l'honneur d'avoir son propre fichier de configuration. Il s'agit du fichiersecurity.yml, situé dans le répertoireapp/configde votre application. Il est un peu vide pour le moment, je vous propose déjà de rajouter quelques sections que l'on décrit juste après. Votre fichier doit ressembler à ceci :

						# app/config/security.yml

						security:
						  encoders:
							Symfony\Component\Security\Core\User\User: plaintext

						  role_hierarchy:
							ROLE_ADMIN:       ROLE_USER
							ROLE_SUPER_ADMIN: [ROLE_USER, ROLE_ADMIN, ROLE_ALLOWED_TO_SWITCH]

						  providers:
							in_memory:
							  memory:
								users:
								  user:  { password: userpass, roles: [ 'ROLE_USER' ] }
								  admin: { password: adminpass, roles: [ 'ROLE_ADMIN' ] }

						  firewalls:
							dev:
							  pattern: ^/(_(profiler|wdt)|css|images|js)/
							  security: false

						  access_control:
							#- { path: ^/login, roles: IS_AUTHENTICATED_ANONYMOUSLY, requires_channel: https }

							Le nom de la section de base s'appelle security, il n'est pas sorti d'un chapeau... c'est tout simplement le nom choisi par le bundle SecurityBundle pour sa configuration. Eh oui, la sécurité dans Symfony vient d'un bundle ! La configuration que nous ferons dans ce chapitre n'est autre que la configuration de ce bundle.

					Bien évidemment, rien de toute cette configuration ne vous parle pour le moment ! Rassurez-vous : à la fin du chapitre ce fichier ne vous fera plus peur. Pour le moment, décrivons rapidement chaque section de la configuration.

					Section encoders

						security:
							encoders:
								Symfony\Component\Security\Core\User\User: plaintext

						Un encodeur est un objet qui encode les mots de passe de vos utilisateurs. Cette section de configuration permet de modifier l'encodeur utilisé pour vos utilisateurs, et donc la façon dont sont encodés les mots de passe dans votre application.

						Vous l'avez deviné, ici l'encodeur utiliséplaintextn'encode en réalité rien du tout. Il laisse en fait les mots de passe en clair, c'est pourquoi les mots de passe que nous verrons dans une section juste en dessous sont en clair. Évidemment, nous définirons par la suite un vrai encodeur, du type sha512, une méthode sûre !

					Section role_hierarchy

						security:
							role_hierarchy:
								ROLE_ADMIN:       ROLE_USER
								ROLE_SUPER_ADMIN: [ROLE_USER, ROLE_ADMIN, ROLE_ALLOWED_TO_SWITCH]

						La notion de « rôle » est au centre du processus d'autorisation. On assigne un ou plusieurs rôles à chaque utilisateur, et pour accéder aux ressources on demande que l'utilisateur ait un ou plusieurs rôles. Ainsi, lorsqu'un utilisateur tente d'accéder à une ressource, le contrôleur d'accès vérifie s'il dispose du ou des rôles requis par la ressource. Si c'est le cas, l'accès est accordé. Sinon, l'accès est refusé.

						Cette section de la configuration dresse la hiérarchie des rôles. Ainsi, le rôleROLE_USERest compris dans le rôleROLE_ADMIN. Cela signifie que si votre page requiert le rôleROLE_USER, et qu'un utilisateur disposant du rôleROLE_ADMINtente d'y accéder, il sera autorisé, car en disposant du rôle d'administrateur, il dispose également du rôleROLE_USER.

						Les noms des rôles n'ont pas d'importance, si ce n'est qu'ils doivent commencer par «ROLE_».

					Section providers

						security:
							providers:
								in_memory:
									memory:
										users:
											user:  { password: userpass, roles: [ 'ROLE_USER' ] }
											admin: { password: adminpass, roles: [ 'ROLE_ADMIN' ] }

						Un provider est un fournisseur d'utilisateurs. Les firewalls s'adressent aux providers pour récupérer les utilisateurs et les identifier.

						Pour l'instant vous pouvez le voir dans le fichier, un seul fournisseur est défini, nomméin_memory(encore une fois, le nom est arbitraire). C'est un fournisseur assez particulier dans le sens où les utilisateurs sont directement listés dans ce fichier de configuration, il s'agit des utilisateurs « user » et « admin ». Vous l'aurez compris, c'est un fournisseur pour faire du développement, pour tester la couche sécurité sans avoir besoin d'une quelconque base de données derrière. Il faudra bien sûr le supprimer par la suite.

						Je vous rassure, il existe d'autres types de fournisseurs que celui-ci. On utilisera notamment par la suite un fournisseur permettant de récupérer les utilisateurs dans la base de données, il est déjà bien plus intéressant.

					Section firewalls

						security:
							firewalls:
								dev:
									pattern:  ^/(_(profiler|wdt)|css|images|js)/
									security: false
									
						Comme on l'a vu précédemment, un firewall (ou pare-feu) cherche à vérifier que vous êtes bien celui que vous prétendez être. Ici, seul le pare-feudevest défini, nous avons supprimé les autres pare-feu de démonstration. Ce pare-feu permet de désactiver la sécurité sur certaines URL, on en reparle plus loin.

					Section access_control

						security:
							access_control:
								#- { path: ^/login, roles: IS_AUTHENTICATED_ANONYMOUSLY, requires_channel: https }
								
						Comme on l'a vu, le contrôle d'accès (ou access control en anglais) va s'occuper de déterminer si le visiteur a les bons droits (rôles) pour accéder à la ressource demandée. Il y a différents moyens d'utiliser les contrôles d'accès :

							Soit ici depuis la configuration, en appliquant des règles sur des URL. On sécurise ainsi un ensemble d'URL en une seule ligne, par exemple toutes celles qui commencent par/admin.

							Soit directement dans les contrôleurs, en appliquant des règles sur les méthodes des contrôleurs. On peut ainsi appliquer des règles différentes selon des paramètres, vous êtes très libres.

						Ces deux moyens d'utiliser la même protection par rôle sont très complémentaires, et offrent une flexibilité intéressante, on en reparle.

					Mettre en place un pare-feu

						Maintenant que nous avons survolé le fichier de configuration, vous avez une vue d'ensemble rapide de ce qu'il est possible de configurer. Parfait !

						Il est temps de passer aux choses sérieuses, en mettant en place une authentification pour notre application. Nous allons le faire en deux étapes. La première est la construction d'un pare-feu, la deuxième est la construction d'un formulaire de connexion. Commençons.

						1. Créer le pare-feu

							Commençons par créer un pare-feu simple, que nous appelleronsmain, comme ceci :

								# app/config/security.yml

								security:
								  firewalls:
									dev:
									  pattern: ^/(_(profiler|wdt)|css|images|js)/
									  security: false
									main:
									  pattern:   ^/
									  anonymous: true
									  
							Dans les trois petites lignes que nous venons de rajouter :

								main est le nom du pare-feu. Il s'agit juste d'un identifiant unique, mettez en réalité ce que vous voulez.

								pattern: ^/est un masque d'URL. Cela signifie que toutes les URL commençant par « / » (c'est-à-dire notre site tout entier) sont protégées par ce pare-feu. On dit qu'elles sont derrière le pare-feumain.

								anonymous: trueaccepte les utilisateurs anonymes. Nous protégerons nos ressources grâce aux rôles.

									Le pare-feumainrecoupe les URL du pare-feudev, c'est vrai. En fait, seul un unique pare-feu peut agir sur une URL, et la règle d'attribution est la même que pour les routes : premier arrivé, premier servi ! En l'occurrence, le pare-feudevest défini avant notre pare-feumain, donc une URL/css/…sera protégée par le pare-feudev(car elle correspond à sonpattern). Ce pare-feu désactive totalement la sécurité, au final les URL/css/…ne sont pas protégées du tout. ;)

								Si vous actualisez n'importe quelle page de votre site, vous pouvez maintenant voir dans la barre d'outils en bas que vous êtes authentifié en tant qu'anonyme, comme sur la figure suivante.

									Je suis authentifié en tant qu'anonyme

								Authentifié en tant qu'anonyme ? C'est pas un peu bizarre ça ?

									Hé, hé ! En effet ! En fait, les utilisateurs anonymes sont techniquement authentifiés : le firewall les a bien reconnu comme étant des anonymes. Mais ils restent des anonymes, et si nous mettions la valeur du paramètreanonymousàfalse dans la configuration, on se ferait bien refuser l'accès. Pour distinguer les anonymes authentifiés des vrais membres authentifiés, il faudra jouer sur les rôles, on en reparle plus loin, ne vous inquiétez pas.

									Bon, votre pare-feu est maintenant créé, mais bien sûr il n'est pas complet, il manque un élément indispensable pour le faire fonctionner : la méthode d'authentification. En effet, votre pare-feu veut bien protéger vos URL, mais il faut lui dire comment vérifier que vos visiteurs sont bien identifiés ! Et notamment, où trouver vos utilisateurs !

								Définir une méthode d'authentification pour le pare-feu

									Nous allons faire simple pour la méthode d'authentification : un bon vieux formulaire HTML. Pour configurer cela, c'est l'optionform_login, entre autres, qu'il faut rajouter à notre pare-feu :

										# app/config/security.yml

										security:
										  provider:     in_memory
										  firewalls:
											# ...
											main:
											  pattern:      ^/
											  anonymous:    true
											  form_login:
												login_path: login
												check_path: login_check
											  logout:
												path:       logout
												target:     login
												
									Expliquons les quelques nouvelles lignes :

										provider: in_memoryest le fournisseur d'utilisateurs pour ce pare-feu. Comme je vous l'ai mentionné précédemment, un pare-feu a besoin de savoir où trouver ses utilisateurs, cela se fait par le biais de ce paramètre. La valeurin_memorycorrespond au nom du fournisseur défini dans la sectionprovidersqu'on a vu plus haut.

										form_loginest la méthode d'authentification utilisée pour ce pare-feu. Elle correspond à la méthode classique, via un formulaire HTML. Ses options sont les suivantes :
				
											login_path: logincorrespond à la route du formulaire de connexion. En effet, ce formulaire est bien disponible à une certaine adresse, il s'agit ici de la routelogin, que nous définirons juste après.

											check_path: login_checkcorrespond à la route de validation du formulaire de connexion, c'est sur cette route que seront vérifiés les identifiants renseignés par l'utilisateur sur le formulaire précédent.

										logoutrend possible la déconnexion. En effet, par défaut il est impossible de se déconnecter une fois authentifié. Ses options sont les suivantes :

											pathest le nom de la route à laquelle le visiteur doit aller pour être déconnecté. On va la définir plus loin.

											targetest le nom de la route vers laquelle sera redirigé le visiteur après sa déconnexion.

									Je vous dois plus d'explications. Rappelez-vous, le processus est le suivant : lorsque le système de sécurité (ici, le pare-feu) initie le processus d'authentification, il va rediriger l'utilisateur sur le formulaire de connexion (la routelogin). On va créer ce formulaire juste après, il devra envoyer les valeurs (nom d'utilisateur et mot de passe) vers la route (ici,login_check) qui va prendre en charge la gestion du formulaire.

									Nous nous occupons de l'affichage du formulaire, mais c'est le système de sécurité de Symfony qui va s'occuper de la gestion de ce formulaire. Concrètement, nous allons définir un contrôleur à exécuter pour la routelogin, mais pas pour la routelogin_check! Symfony va attraper la requête de notre visiteur sur la routelogin_check, et gérer lui-même l'authentification. En cas de succès, le visiteur sera authentifié. En cas d'échec, Symfony le renverra vers notre formulaire de connexion pour qu'il réessaie.

									Voici alors les trois routes à définir dans le fichierrouting.yml:

										# app/config/routing.yml

										# ...

										login:
											path: /login
											defaults:
												_controller: OCUserBundle:Security:login

										login_check:
											path: /login_check

										logout:
											path: /logout

									Comme vous pouvez le voir, on ne définit pas de contrôleur pour les routeslogin_checketlogout. Symfony va attraper tout seul les requêtes sur ces routes (grâce au gestionnaire d'évènements, nous voyons cela dans un prochain chapitre).

								Créer le bundleOCUserBundle

									Ce paragraphe n'est applicable que si vous ne disposez pas déjà d'un bundleUserBundle.

									Cela ne vous a pas échappé, j'ai défini le contrôleur à exécuter sur la routelogincomme étant dans le bundleOCUserBundle. En effet, la gestion des utilisateurs sur un site mérite amplement son propre bundle !

									Je vous laisse générer ce bundle à l'aide de la commande suivante qu'on a déjà abordée :

										php bin/console generate:bundle

									Avant de continuer, je vous propose un petit nettoyage dans ce nouveauOCUserBundle, car le générateur a tendance à trop en faire. Vous pouvez donc supprimer allègrement :

										Le contrôleurController/DefaultController.php;
										
										Son répertoire de testsTests/Controller;
										
										Son répertoire de vuesResources/views/Default;
										
										Le fichier de routesResources/config/routing.yml ;
										
										La ligne d'import (oc_user) du fichier de routes dans le fichier app/config/routing.yml.

								Créer le formulaire de connexion

									Il s'agit maintenant de créer le formulaire de connexion, disponible sur la routelogin, soit l'URL/login. Commençons par le contrôleur :

										<?php
										// src/OC/UserBundle/Controller/SecurityController.php;

										namespace OC\UserBundle\Controller;

										use Symfony\Bundle\FrameworkBundle\Controller\Controller;
										use Symfony\Component\HttpFoundation\Request;

										class SecurityController extends Controller
										{
										  public function loginAction(Request $request)
										  {
											// Si le visiteur est déjà identifié, on le redirige vers l'accueil
											if ($this->get('security.authorization_checker')->isGranted('IS_AUTHENTICATED_REMEMBERED')) {
											  return $this->redirectToRoute('oc_platform_accueil');
											}

											// Le service authentication_utils permet de récupérer le nom d'utilisateur
											// et l'erreur dans le cas où le formulaire a déjà été soumis mais était invalide
											// (mauvais mot de passe par exemple)
											$authenticationUtils = $this->get('security.authentication_utils');

											return $this->render('OCUserBundle:Security:login.html.twig', array(
											  'last_username' => $authenticationUtils->getLastUsername(),
											  'error'         => $authenticationUtils->getLastAuthenticationError(),
											));
										  }
										}

									Ne vous laissez pas impressionner par le contrôleur, de toute façon vous n'avez pas à le modifier pour le moment. En réalité, il ne fait qu'afficher la vue du formulaire. Le code au milieu n'est là que pour récupérer les erreurs d'une éventuelle soumission précédente du formulaire. Rappelez-vous : c'est Symfony qui gère la soumission, et lorsqu'il y a une erreur dans l'identification, il redirige le visiteur vers ce contrôleur, en nous donnant heureusement l'erreur pour qu'on puisse lui afficher.

									La vue pourrait être la suivante :

										{# src/OC/UserBundle/Resources/views/Security/login.html.twig #}

										{% extends "OCCoreBundle::layout.html.twig" %}

										{% block body %}

										  {# S'il y a une erreur, on l'affiche dans un joli cadre #}
										  {% if error %}
											<div class="alert alert-danger">{{ error.message }}</div>
										  {% endif %}

										  {# Le formulaire, avec URL de soumission vers la route « login_check » comme on l'a vu #}
										  <form action="{{ path('login_check') }}" method="post">
											<label for="username">Login :</label>
											<input type="text" id="username" name="_username" value="{{ last_username }}" />

											<label for="password">Mot de passe :</label>
											<input type="password" id="password" name="_password" />
											<br />
											<input type="submit" value="Connexion" />
										  </form>

										{% endblock %}
			
									La figure suivante montre le rendu du formulaire, accessible à l'adresse/login.

										Le formulaire de connexion

									Lorsque j'entre de faux identifiants, l'erreur générée est celle visible à la figure suivante.

										Mauvais identifiants

									Enfin, lorsque j'entre les bons identifiants, la barre d'outils sur la page suivante m'indique bien que je suis authentifié en tant qu'utilisateur « user », comme le montre la figure suivante.

										Je suis bien authentifié

											Mais quels sont les bons identifiants ?

									Il faut lire attentivement le fichier de configuration qu'on a parcouru précédemment. Rappelez-vous, on a défini le fournisseur d'utilisateur de notre pare-feu àin_memory, qui est défini quelques lignes plus haut dans le fichier de configuration. Ce fournisseur est particulier, dans le sens où il lit les utilisateurs directement dans sa configuration. On a donc deux utilisateurs possibles : « user » et « admin », avec pour mot de passe respectivement « userpass » et « adminpass ».

									Voilà, notre formulaire de connexion est maintenant opérationnel. Vous trouverez plus d'informations pour le personnaliser dans la documentation.

							Les erreurs courantes

								Il y a quelques pièges à connaître quand vous travaillerez plus avec la sécurité, en voici quelques-uns.

								Ne pas oublier la définition des routes

									Une erreur bête est d'oublier de créer les routeslogin,login_checketlogout. Ce sont des routes obligatoires, et si vous les oubliez vous risquez de tomber sur des erreurs 404 au milieu de votre processus d'authentification.

								Les pare-feu ne partagent pas

									Si vous utilisez plusieurs pare-feu, sachez qu'ils ne partagent rien les uns avec les autres. Ainsi, si vous êtes authentifiés sur l'un, vous ne le serez pas forcément sur l'autre, et inversement. Cela permet d’accroître la sécurité lors d'un paramétrage complexe.

								Bien mettre/login_checkderrière le pare-feu

									Vous devez vous assurer que l'URL ducheck_path(ici,/login_check) est bien derrière le pare-feu que vous utilisez pour le formulaire de connexion (ici,main). En effet, c'est la route qui permet l'authentification au pare-feu. Or, comme les pare-feu ne partagent rien, si cette route n'appartient pas au pare-feu que vous voulez, vous aurez droit à une belle erreur.

									Dans notre cas, lepattern: ^/du pare-feumainprend bien l'URL/login_check, c'est donc OK.

								Ne pas sécuriser le formulaire de connexion

									En effet, si le formulaire est sécurisé, comment les nouveaux arrivants vont-ils pouvoir s'authentifier ? En l'occurrence, il faut faire attention que la page/loginne requière aucun rôle, on fera attention à cela lorsqu'on va définir les autorisations.

										Cette erreur est vicieuse, car si vous sécurisez à tort l'URL/login, vous subirez une redirection infinie. En effet, Symfony considère que vous n'avez pas accès à/login, il vous redirige donc vers le formulaire pour vous authentifier, or il s'agit de la page/login, or vous n'avez pas accès à/login, etc.

									De plus, si vous souhaitez interdire les anonymes sur le pare-feumain, le problème se pose également, car un nouvel arrivant sera forcément anonyme et ne pourra pas accéder au formulaire de connexion. L'idée dans ce cas est de sortir le formulaire de connexion (la page/login) du pare-feumain. En effet, c'est lecheck_pathqui doit obligatoirement appartenir au pare-feu, pas le formulaire en lui-même. Si vous souhaitez interdire les anonymes sur votre site (et uniquement dans ce cas), vous pouvez donc vous en sortir avec la configuration suivante :

										# app/config/security.yml

										# ...

										firewalls:
											# On crée un pare-feu uniquement pour le formulaire
											main_login:
												# Cette expression régulière permet de prendre /login (mais pas /login_check !)
												pattern:   ^/login$
												anonymous: true # On autorise alors les anonymes sur ce pare-feu
											main:
												pattern:   ^/
												anonymous: false
												# ...

									En plaçant ce nouveau pare-feu avant notre pare-feumain, on sort le formulaire de connexion du pare-feu sécurisé. Nos nouveaux arrivants auront donc une chance de s'identifier !

							Récupérer l'utilisateur courant

								Pour récupérer les informations sur l'utilisateur courant, qu'il soit anonyme ou non, il faut utiliser le servicesecurity.token_storage.

								Ce service dispose d'une méthodegetToken(), qui permet de récupérer la session de sécurité courante (à ne pas confondre avec la session classique, disponible elle via$request->getSession()). Ce token vautnullsi vous êtes hors d'un pare-feu. Et si vous êtes derrière un pare-feu, alors vous pouvez récupérer l'utilisateur courant grâce à$token->getUser().

								Depuis le contrôleur ou un service

									Voici concrètement comment l'utiliser :

										<?php

										// On récupère le service
										$security = $container->get('security.token_storage');

										// On récupère le token
										$token = $security->getToken();

										// Si la requête courante n'est pas derrière un pare-feu, $token est null

										// Sinon, on récupère l'utilisateur
										$user = $token->getUser();

										// Si l'utilisateur courant est anonyme, $user vaut « anon. »

										// Sinon, c'est une instance de notre entité User, on peut l'utiliser normalement
										$user->getUsername();

									Comme vous pouvez le voir, il y a pas mal de vérifications à faire, suivant les différents cas possibles. Heureusement, en pratique, le contrôleur dispose d'un raccourci permettant d'automatiser cela, il s'agit de la méthode$this->getUser(). Cette méthode retourne :

										null si la requête n'est pas derrière un pare-feu, ou si l'utilisateur courant est anonyme ;

										Une instance deUserle reste du temps (utilisateur authentifié derrière un pare-feu et non-anonyme).

									Du coup, voici le code simplifié depuis un contrôleur :

										<?php
										// Depuis un contrôleur

										$user = $this->getUser();

										if (null === $user) {
										  // Ici, l'utilisateur est anonyme ou l'URL n'est pas derrière un pare-feu
										} else {
										  // Ici, $user est une instance de notre classe User
										}

								Depuis une vue Twig

									Vous avez accès plus facilement à l'utilisateur directement depuis Twig. Vous savez que Twig dispose de quelques variables globales via la variable{{ app }}; eh bien, l'utilisateur courant en fait partie, via{{ app.user }}:

										Bonjour {{ app.user.username }} - {{ app.user.email }}

									Au même titre que dans un contrôleur, attention à ne pas utiliser{{ app.user }}lorsque l'utilisateur n'est pas authentifié, car il vautnull.

						Gestion des autorisations avec les rôles

							La section précédente nous a amenés à réaliser une authentification opérationnelle. Vous avez un pare-feu, une méthode d'authentification par formulaire HTML, et deux utilisateurs. La couche authentification est complète !

							Dans cette section, nous allons nous occuper de la deuxième couche de la sécurité : l'autorisation. C'est une phase bien plus simple à gérer heureusement, il suffit juste de demander tel(s) droit(s) à l'utilisateur courant (identifié ou non).

							Définition des rôles

								Rappelez-vous, on a croisé les rôles dans le fichiersecurity.yml. La notion de rôle et autorisation est très simple : pour limiter l'accès à certaines pages, on va se baser sur les rôles de l'utilisateur. Ainsi, limiter l'accès au panel d'administration revient à limiter cet accès aux utilisateurs disposant du rôleROLE_ADMIN(par exemple).

								Tout d'abord, essayons d'imaginer les rôles dont on aura besoin dans notre application de plateforme d'annonce. Je pense à :

									ROLE_AUTEUR: pour ceux qui ont le droit d'écrire des annonces ;
									
									ROLE_MODERATEUR: pour ceux qui peuvent modérer les annonces ;
									
									ROLE_ADMIN: pour ceux qui peuvent tout faire.

								Maintenant l'idée est de créer une hiérarchie entre ces rôles. On va dire que les auteurs et les modérateurs sont bien différents, et que les admins ont les droits cumulés des auteurs et des modérateurs. Ainsi, pour limiter l'accès à certaines pages, on ne va pas faire « si l'utilisateur aROLE_AUTEURou s'il aROLE_ADMIN, alors il peut écrire une annonce ». Grâce à la définition de la hiérarchie, on peut faire simplement « si l'utilisateur aROLE_AUTEUR». Car un utilisateur qui dispose deROLE_ADMINdispose également deROLE_AUTEUR, c'est une inclusion.

								Ce sont ces relations, et uniquement ces relations, que nous allons inscrire dans le fichiersecurity.yml. Voici donc comment décrire dans la configuration la hiérarchie qu'on vient de définir :

									# app/config/security.yml

									security:
										role_hierarchy:
											# Un admin hérite des droits d'auteur et de modérateur
											ROLE_ADMIN:       [ROLE_AUTEUR, ROLE_MODERATEUR]
											# On garde ce rôle superadmin, il nous resservira par la suite
											ROLE_SUPER_ADMIN: [ROLE_ADMIN, ROLE_ALLOWED_TO_SWITCH]

								Remarquez que je n'ai pas utilisé le rôleROLE_USER, qui n'est pas toujours utile. Avec cette hiérarchie, voici des exemples de tests que l'on peut faire :

									Si l'utilisateur a le rôleROLE_AUTEUR, alors il peut écrire une annonce. Les auteurs et les admins peuvent donc le faire.
									
									Si l'utilisateur a le rôleROLE_ADMIN, alors il peut supprimer une annonce. Seuls les admins peuvent donc le faire.

								Tous ces tests nous permettront de limiter l'accès à nos différentes pages.

									J'insiste sur le fait qu'on définit ici uniquement la hiérarchie entre les rôles, et non l'exhaustivité des rôles. Ainsi, on pourrait tout à fait avoir un rôleROLE_TRUCdans notre application, mais que les administrateurs n'héritent pas.

						Tester les rôles de l'utilisateur

							Il est temps maintenant de tester concrètement si l'utilisateur courant dispose de tel ou tel rôle. Cela nous permettra de lui donner accès à la page, de lui afficher ou non un certain lien, etc. Laissez libre cours à votre imagination. ;)

							Il existe quatre méthodes pour faire ce test : les annotations, le servicesecurity.authorization_checker, Twig, et les contrôles d'accès. Ce sont quatre façons de faire exactement la même chose.

							Utiliser directement le servicesecurity.authorization_checker

								Ce n'est pas le moyen le plus court, mais c'est celui par lequel passent les trois autres méthodes. Il faut donc que je vous en parle en premier !

								Depuis votre contrôleur ou n'importe quel autre service, il vous faut accéder au service  security.authorization_checker et appeler la méthodeisGranted, tout simplement. Par exemple dans notre contrôleur :

									<?php
									// src/OC/PlatformBundle/Controller/AdvertController.php

									namespace OC\PlatformBundle\Controller;

									use Symfony\Bundle\FrameworkBundle\Controller\Controller;
									use Symfony\Component\HttpFoundation\Request;
									use Symfony\Component\Security\Core\Exception\AccessDeniedException;

									class AdvertController extends Controller
									{
									  public function addAction(Request $request)
									  {
										// On vérifie que l'utilisateur dispose bien du rôle ROLE_AUTEUR
										if (!$this->get('security.authorization_checker')->isGranted('ROLE_AUTEUR')) {
										  // Sinon on déclenche une exception « Accès interdit »
										  throw new AccessDeniedException('Accès limité aux auteurs.');
										}

										// Ici l'utilisateur a les droits suffisant,
										// on peut ajouter une annonce
									  }
									}

								C'est tout ! Vous pouvez aller sur /platform, mais impossible d'atteindre la page d'ajout d'une annonce sur /platform/add, car vous ne disposez pas (encore !) du rôleROLE_AUTEUR, comme le montre la figure suivante.

									L'accès est interdit

							Utiliser les annotations dans un contrôleur

								Pour faire exactement ce qu'on vient de faire avec le servicesecurity.authorization_checker, il existe un moyen bien plus rapide et joli : les annotations !

								L'annotation@Security que nous allons utiliser ici provient du bundleSensioFrameworkExtraBundle, c'est un bundle qui apporte quelques petits plus au framework. Pas besoin d'explication, son utilisation basique est assez simple ; regardez le code :

									<?php
									// src/OC/PlatformBundle/Controller/AdvertController.php

									namespace OC\PlatformBundle\Controller;

									use Symfony\Bundle\FrameworkBundle\Controller\Controller;
									use Symfony\Component\HttpFoundation\Request;
									// N'oubliez pas ce use pour l'annotation
									use Sensio\Bundle\FrameworkExtraBundle\Configuration\Security;

									class AdvertController extends Controller
									{
									  /**
									   * @Security("has_role('ROLE_AUTEUR')")
									   */
									  public function addAction(Request $request)
									  {
										// Plus besoin du if avec le security.context, l'annotation s'occupe de tout !
										// Dans cette méthode, vous êtes sûrs que l'utilisateur courant dispose du rôle ROLE_AUTEUR
									  }
									}

								Et voilà ! Grâce à l'annotation@Security, on a sécurisé notre méthode en une seule ligne, vraiment pratique.

								La valeur de l'option par défaut de l'annotation est en fait une expression, dans laquelle vous pouvez utiliser plusieurs variables et fonctions (dont has_role qu'on a utilisé ici). Si vous voulez vérifier que l'utilisateur a deux rôles, vous pouvez faire comme ceci :

									<?php
									/**
									 * @Security("has_role('ROLE_AUTEUR') and has_role('ROLE_AUTRE')")
									 * /
									 
								Le détail des variables et fonctions disponibles est dans la documentation.

								Pour vérifier simplement que l'utilisateur est authentifié, et donc qu'il n'est pas anonyme, vous pouvez utiliser le rôle spécialIS_AUTHENTICATED_REMEMBERED.

							Depuis une vue Twig

								Cette méthode est très pratique pour afficher du contenu différent selon les rôles de vos utilisateurs. Typiquement, le lien pour ajouter une annonce ne doit être visible que pour les membres qui disposent du rôleROLE_AUTEUR(car c'est la contrainte que nous avons mise sur la méthodeaddAction()).

								Pour cela, Twig dispose d'une fonctionis_granted()qui est en réalité un raccourci pour exécuter la méthodeisGranted()du servicesecurity.authorization_checker. La voici en application :

								{# On n'affiche le lien « Ajouter une annonce » qu'aux auteurs
								  (et admins, qui héritent du rôle auteur) #}
								{% if is_granted('ROLE_AUTEUR') %}
								  <li><a href="{{ path('oc_platform_add') }}">Ajouter une annonce</a></li>
								{% endif %}

							Utiliser les contrôles d'accès

								La méthode de l'annotation permet de sécuriser une méthode de contrôleur. La méthode avec Twig permet de sécuriser l'affichage. La méthode des contrôles d'accès permet de sécuriser des URL. Elle se configure dans le fichier de configuration de la sécurité, c'est la dernière section. Voici par exemple comment sécuriser tout un panel d'administration (toutes les pages dont l'URL commence par/admin) en une seule ligne :

									# app/config/security.yml

									security:
										access_control:
											- { path: ^/admin, roles: ROLE_ADMIN }

								Ainsi, toutes les URL qui correspondent aupath(ici, toutes celles qui commencent par/admin) requièrent le rôleROLE_ADMIN.

								C'est une méthode complémentaire des autres. Elle permet également de sécuriser vos URL par IP ou par canal (http ou https), grâce à des options :

									# app/config/security.yml

									security:
										access_control:
											- { path: ^/admin, ip: 127.0.0.1, requires_channel: https }

							Pour conclure sur les méthodes de sécurisation

								Symfony offre plusieurs moyens de sécuriser vos ressources (méthode de contrôleur, affichage, URL). N'hésitez pas à vous servir de la méthode la plus appropriée pour chacun de vos besoins. C'est la complémentarité des méthodes qui fait l'efficacité de la sécurité avec Symfony.

									Pour tester les sécurités qu'on met en place, n'hésitez pas à charger vos pages avec les deux utilisateurs « user » et « admin ». L'utilisateur admin ayant le rôleROLE_ADMIN, il a les droits pour ajouter une annonce et voir le lien d'ajout. Pour vous déconnecter d'un utilisateur, allez sur/logout.


					Utiliser des utilisateurs de la base de données

						Pour l'instant, nous n'avons fait qu'utiliser les deux pauvres utilisateurs définis dans le fichier de configuration. C'était pratique pour faire nos premiers tests, car ils ne nécessitent aucun paramétrage particulier. Mais maintenant, passons à la vitesse supérieure et enregistrons nos utilisateurs en base de données !

						Qui sont les utilisateurs ?

							Dans Symfony, un utilisateur est un objet qui implémente l'interface UserInterface, c'est tout. N'hésitez pas à aller voir à quoi ressemble cette interface, il n'y a en fait que cinq méthodes obligatoires, ce n'est pas grand-chose.

							Heureusement il existe également une classeUserqui implémente cette interface. Les utilisateurs que nous avons actuellement sont des instances de cette classe.

						Créons notre classe d'utilisateurs

							En vue d'enregistrer nos utilisateurs en base de données, il nous faut créer notre propre classe utilisateur, qui sera également une entité pour être persistée. Je vous invite donc à générer directement une entitéUserau sein du bundleOCUserBundle, grâce au générateur de Doctrine (php bin/console doctrine:generate:entity), avec les attributs minimum suivants (tirés de l'interface) :

								username: c'est l'identifiant de l'utilisateur au sein de la couche sécurité. Cela ne nous empêchera pas d'utiliser également un id numérique pour notre entité, c'est plus simple pour nous ;

								password: le mot de passe ;

								salt: le sel, pour encoder le mot de passe, on en reparle plus loin ;

								roles: un tableau (attention à bien le définir comme tel lors de la génération) contenant les rôles de l'utilisateur.

							Voici la classe que j'obtiens :

								<?php

								namespace OC\UserBundle\Entity;

								use Doctrine\ORM\Mapping as ORM;

								/**
								 * @ORM\Table(name="oc_user")
								 * @ORM\Entity(repositoryClass="OC\UserBundle\Entity\UserRepository")
								 */
								class User
								{
								  /**
								   * @ORM\Column(name="id", type="integer")
								   * @ORM\Id
								   * @ORM\GeneratedValue(strategy="AUTO")
								   */
								  private $id;

								  /**
								   * @ORM\Column(name="username", type="string", length=255, unique=true)
								   */
								  private $username;

								  /**
								   * @ORM\Column(name="password", type="string", length=255)
								   */
								  private $password;

								  /**
								   * @ORM\Column(name="salt", type="string", length=255)
								   */
								  private $salt;

								  /**
								   * @ORM\Column(name="roles", type="array")
								   */
								  private $roles = array();

								  // Les getters et setters

								  public function eraseCredentials()
								  {
								  }
								}

								J'ai défini une valeur par défaut (array()) à l'attribut$roles. J'ai également défini l'attributusernamecomme étant unique, car c'est l'identifiant qu'utilise la couche sécurité, il est donc obligatoire qu'il soit unique. Enfin, j'ai ajouté la méthodeeraseCredentials(), vide pour l'instant mais obligatoire de par l'interface suivante.

							Et pour que Symfony l'accepte comme classe utilisateur de la couche sécurité, il faut qu'on implémente l'interfaceUserInterface:

								<?php
								// src/OC/UserBundle/Entity/User.php

								use Symfony\Component\Security\Core\User\UserInterface;

								class User implements UserInterface
								{
								  // …
								}

							Et voilà, nous avons une classe prête à être utilisée !

								Et bien sûr, exécutez un petitphp bin/console doctrine:schema:updatepour mettre à jour la base de données avec cette nouvelle entité.

					Créons quelques utilisateurs de test

						Pour s'amuser avec notre nouvelle entitéUser, il faut créer quelques instances dans la base de données. Réutilisons ici les fixtures, voici ce que je vous propose :

							<?php
							// src/OC/UserBundle/DataFixtures/ORM/LoadUser.php

							namespace OC\UserBundle\DataFixtures\ORM;

							use Doctrine\Common\DataFixtures\FixtureInterface;
							use Doctrine\Common\Persistence\ObjectManager;
							use OC\UserBundle\Entity\User;

							class LoadUser implements FixtureInterface
							{
							  public function load(ObjectManager $manager)
							  {
								// Les noms d'utilisateurs à créer
								$listNames = array('Alexandre', 'Marine', 'Anna');

								foreach ($listNames as $name) {
								  // On crée l'utilisateur
								  $user = new User;

								  // Le nom d'utilisateur et le mot de passe sont identiques pour l'instant
								  $user->setUsername($name);
								  $user->setPassword($name);

								  // On ne se sert pas du sel pour l'instant
								  $user->setSalt('');
								  // On définit uniquement le role ROLE_USER qui est le role de base
								  $user->setRoles(array('ROLE_USER'));

								  // On le persiste
								  $manager->persist($user);
								}

								// On déclenche l'enregistrement
								$manager->flush();
							  }
							}

						Exécutez cette fois la commande :

							php bin/console doctrine:fixtures:load

						Et voilà, nous avons maintenant trois utilisateurs dans la base de données.

					Définissons l'encodeur pour notre nouvelle classe d'utilisateurs

						Ce n'est pas un piège mais presque, rappelez-vous, l'encodeur défini pour nos précédents utilisateurs spécifiait la classeUserutilisée. Or maintenant nous allons nous servir d'une autre classe, il s'agit deOC\UserBundle\Entity\User. Il est donc obligatoire de définir quel encodeur utiliser pour notre nouvelle classe. Comme nous avons mis les mots de passe en clair dans les fixtures, nous devons également utiliser l'encodeurplaintext, qui n'encode pas les mots de passe mais les laisse en clair, c'est plus simple pour nos tests.

						Ajoutez donc cet encodeur dans la configuration, juste en dessous de celui existant :

							# app/config/security.yml

							security:
								encoders:
									Symfony\Component\Security\Core\User\User: plaintext
									OC\UserBundle\Entity\User: plaintext

					Définissons le fournisseur d'utilisateurs

						On en a parlé plus haut, il faut définir un fournisseur (provider) pour que le pare-feu puisse identifier et récupérer les utilisateurs.

						Qu'est-ce qu'un fournisseur d'utilisateurs, concrètement ?

							Un fournisseur d'utilisateurs est une classe qui implémente l'interfaceUserProviderInterface, qui contient juste trois méthodes :

								loadUserByUsername($username), qui charge un utilisateur à partir d'un nom d'utilisateur ;

								refreshUser($user), qui rafraîchit un utilisateur avec les valeurs d'origine ;

								supportsClass(), qui détermine quelle classe d'utilisateurs gère le fournisseur.

							Vous pouvez le constater, un fournisseur ne fait finalement pas grand-chose, à part charger ou rafraîchir les utilisateurs.

							Symfony dispose déjà de trois types de fournisseurs, qui implémentent tous l'interface précédente évidemment, les voici :

								memoryutilise les utilisateurs définis dans la configuration, c'est celui qu'on a utilisé jusqu'à maintenant ;
								
								entityutilise de façon simple une entité pour fournir les utilisateurs, c'est celui qu'on va utiliser ;
								
								idpermet d'utiliser un service quelconque en tant que fournisseur, en précisant le nom du service.
						
						Créer notre fournisseurentity

							Il est temps de créer le fournisseurentitypour notre entité User. Celui-ci existe déjà dans Symfony, nous n'avons donc pas de code à faire, juste un peu de configuration. On va l'appeler « main », un nom arbitraire. Voici comment le déclarer :

								# app/config/security.yml

								security:
								  providers:
									# … vous pouvez supprimer le fournisseur « in_memory »
									# Et voici notre nouveau fournisseur :
									main:
									  entity:
										class:    OC\UserBundle\Entity\User
										property: username

							Il y a deux paramètres à préciser pour le fournisseur :

								La classe de l'entité à utiliser évidemment, il s'agit pour le fournisseur de savoir quel repository Doctrine utiliser pour ensuite charger nos entités. Vous pouvez également  utiliser le nom logique de l'entité, iciOCUserBundle:User ;

								L'attribut de la classe qui sert d'identifiant, on utiliseusername, donc on le lui dit.

							Dans la configuration, faites bien la différence entre "main" et "entity" :
			
								"main" est le nom du provider, totalement arbitraire. On aurait pu utiliser "mon_super_provider", attention juste à bien utiliser le même dans la configuration du par-feu.

								"entity" est le type de provider, c'est un nom fixe, définit dans symfony.
			
						Dire au pare-feu d'utiliser le nouveau fournisseur

							Maintenant que notre fournisseur existe, il faut demander au pare-feu de l'utiliser lui, et non l'ancien fournisseurin_memory. Pour cela, modifions simplement la valeur du paramètreprovider, comme ceci :

								# app/config/security.yml

								security:
								  firewalls:
									main:
									  pattern:   ^/
									  anonymous: true
									  provider:  main # On change cette valeur
									  # … reste de la configuration du pare-feu

							Vous trouverez encore plus d'informations sur ce type de fournisseur dans la documentation.

					Manipuler vos utilisateurs

						La couche sécurité est maintenant pleinement opérationnelle et utilise des utilisateurs stockés en base de données. Testez-le dès maintenant en vous identifiant avec le nom d'utilisateur et mot de passe définis dans le fichier de fixtures (vous aurez peut-être besoin de faire uncache:clear  d'abord). C'est parfait !

							Vous voulez faire un formulaire d'inscription ? Modifier vos utilisateurs ? Changer leurs rôles ?

						Je pourrais vous expliquer comment le faire, mais en réalité vous savez déjà le faire !

						L'entitéUserque nous avons créée est une entité tout à fait comme les autres. À ce stade du cours vous savez ajouter, modifier et supprimer des annonces, alors il en va de même pour cette nouvelle entité qui représente vos utilisateurs.

						Bref, faites-vous confiance, vous avez toutes les clés en main pour manipuler entièrement vos utilisateurs.

						Cependant, toutes les pages d'un espace membres sont assez classiques : inscription, mot de passe perdu, modification du profil, etc. Tout cela est du déjà-vu. Et si c'est déjà vu, il existe déjà certainement un bundle pour cela. Et je vous le confirme, il existe même un excellent bundle, il s'agit deFOSUserBundleet je vous propose de l'installer !

				Utiliser FOSUserBundle

					Comme vous avez pu le voir, la sécurité fait intervenir de nombreux acteurs et demande pas mal de travail de mise en place. C'est normal, c'est un point sensible d'un site internet. Heureusement, d'autres développeurs talentueux ont réussi à nous faciliter la tâche en créant un bundle qui gère une partie de la sécurité !

					Ce bundle s'appelleFOSUserBundle, il est très utilisé par la communauté Symfony car vraiment bien fait, et surtout répondant à un besoin vraiment basique d'un site Internet : l'authentification des membres.

					Je vous propose donc d'installer ce bundle dans la suite de cette section. Cela n'est en rien obligatoire, vous pouvez tout à fait continuer avec leUserqu'on vient de développer, cela fonctionne tout aussi bien !

					Installation deFOSUserBundle

						Télécharger le bundle

						Le bundleFOSUserBundleest hébergé sur GitHub, comme beaucoup de bundles et projets Symfony. Sa page est ici :https://github.com/FriendsOfSymfony/FOSUserBundle.

						Mais pour ajouter ce bundle, vous l'avez compris, il faut utiliser Composer ! Commencez par déclarer cette nouvelle dépendance dans votre fichiercomposer.json:

							// composer.json

							{
							  // …

							  "require": {
								// …
								"friendsofsymfony/user-bundle": "dev-master"
							  }

							  // …
							}

							À l'heure où j'écris ces lignes, les mainteneurs de ce bundle n'ont pas sorti de version stable du bundle compatible avec Symfony3. C'est pourquoi il faut utiliser la versiondev-master pour le moment.

						Ensuite, il faut dire à Composer d'installer cette nouvelle dépendance :

							php composer.phar update friendsofsymfony/user-bundle

						L'argument après la commandeupdatepermet de dire à Composer de ne mettre à jour que cette dépendance. Ici, cela permet de ne mettre à jour queFOSUserBundle, et pas les autres dépendances. C'est plus rapide, mais si vous vouliez tout mettre à jour, supprimez simplement ce paramètre. 

					Activer le bundle

						Si vos souvenirs sont bons, vous devriez savoir qu'un bundle ne s'active pas tout seul, il faut aller l'enregistrer dans le noyau de Symfony. Pour cela, ouvrez le fichierapp/AppKernel.phppour enregistrer le bundle :

							<?php
							// app/AppKernel.php

							public function registerBundles()
							{
							  $bundles = array(
								// …
								new FOS\UserBundle\FOSUserBundle(),
							  );
							}

						C'est bon, le bundle est bien enregistré. Mais inutile d'essayer d'accéder à votre application Symfony maintenant, elle ne marchera pas. Il faut en effet faire un peu de configuration et de personnalisation avant de pouvoir tout remettre en marche.

					HériterFOSUserBundledepuis notreOCUserBundle

						FOSUserBundleest un bundle générique évidemment, car il doit pouvoir s'adapter à tout type d'utilisateur de n'importe quel site internet. Vous imaginez bien que, du coup, ce n'est pas un bundle prêt à l'emploi directement après son installation ! Il faut donc s'atteler à le personnaliser afin de faire correspondre le bundle à nos besoins. Cette personnalisation passe par l'héritage de bundle.

						C'est une fonctionnalité intéressante qui va nous permettre de personnaliser facilement et proprement le bundle que l'on vient d'installer. L'héritage de bundle est même très simple à réaliser. Prenez le fichierOCUserBundle.phpqui représente notre bundle, et modifiez-le comme suit :

							<?php
							// src/OC/UserBundle/OCUserBundle.php

							namespace OC\UserBundle;

							use Symfony\Component\HttpKernel\Bundle\Bundle;

							class OCUserBundle extends Bundle
							{
							  public function getParent()
							  {
								return 'FOSUserBundle';
							  }
							}

						Et c'est tout ! On a juste rajouté cette méthodegetParent(), et Symfony va savoir gérer le reste. ;)

						Lorsque qu'un bundle A (notre OCUserBundle) hérite d'un bundle B (FOSUserBundle), cela signifie entre autre que :

							si une vue du bundle A a le même nom qu'une vue du bundle B, c'est la vue du bundle A qui sera utilisée lorsque vous faites "BundleB::myView.html.twig", alors que vous mentionnez bien "BundleB" dans le nom de la vue ;

							si un contrôleur du bundle A a le même nom qu'un contrôleur du bundle B, c'est le contrôleur du bundle A qui sera utilisé lorsque vous faites "BundleB:myController:myAction", alors que vous mentionnez bien "BundleB" dans le nom du contrôleur.

					Modifier notre entitéUser

						Bien que nous ayons déjà créé une entitéUser, ce nouveau bundle en contient une plus complète, qu'on va utiliser avec plaisir plutôt que de tout recoder nous-mêmes. On va donc hériter l'entité User de FOSUserBundle depuis notre entité User de notre OCUserBundle. Notre entité ne contiendra que les attributs que l'on souhaite avoir et qui ne sont pas dans celle de FOSUserBundle. En fait, notre entité ne contient plus grand-chose au final, voici ce que cela donne :

							<?php
							// src/OC/UserBundle/Entity/User.php

							namespace OC\UserBundle\Entity;

							use Doctrine\ORM\Mapping as ORM;
							use FOS\UserBundle\Model\User as BaseUser;

							/**
							 * @ORM\Table(name="oc_user")
							 * @ORM\Entity(repositoryClass="OC\UserBundle\Repository\UserRepository")
							 */
							class User extends BaseUser
							{
							  /**
							   * @ORM\Column(name="id", type="integer")
							   * @ORM\Id
							   * @ORM\GeneratedValue(strategy="AUTO")
							   */
							  protected $id;
							}

							Plus besoin d'implémenterUserInterface, car on hérite de l'entitéUserdu bundleFOSUB, qui, elle, implémente cette interface. Pas besoin non plus d'écrire tous les setters et getters, ils sont tous hérités, même le getter getId !

						Alors c'est joli, mais pourquoi est-ce que l'on a fait cela ? En fait, le bundleFOSUserBundlene définit pas vraiment l'entitéUser, il définit une mapped superclass ! Un nom un peu barbare, juste pour dire que c'est une entité abstraite, et qu'il faut en hériter pour en faire une vraie entité. C'est donc ce que nous venons juste de faire.

						Cela permet en fait de garder la main sur notre entité. On peut ainsi lui ajouter des attributs (selon vos besoins), en plus de ceux déjà définis. Pour information, les attributs qui existent déjà sont :

							username: nom d'utilisateur avec lequel l'utilisateur va s'identifier ;
							
							email: l'adresse e-mail ;
							
							enabled:trueoufalsesuivant que l'inscription de l'utilisateur a été validée ou non (dans le cas d'une confirmation par e-mail par exemple) ;
							
							password: le mot de passe de l'utilisateur ;
							
							lastLogin: la date de la dernière connexion ;
							
							locked: si vous voulez désactiver des comptes ;
							
							expired: si vous voulez que les comptes expirent au-delà d'une certaine durée.

						Je vous en passe certains qui sont plus à un usage interne. Sachez tout de même que vous pouvez tous les retrouver dans la définition Doctrine de la mapped superclass. C'est un fichier de mapping XML, l'équivalent des annotations qu'on utilise de notre côté.

						Vous pouvez rajouter dès maintenant des attributs à votre entitéUser, comme vous savez le faire depuis la partie Doctrine.

					Configurer le bundle

						Ensuite, nous devons définir certains paramètres obligatoires au fonctionnement deFOSUserBundle. Ouvrez votreconfig.ymlet ajoutez la section suivante :

							# app/config/config.yml

							# …

							fos_user:
								db_driver:     orm                       # Le type de BDD à utiliser, nous utilisons l'ORM Doctrine depuis le début
								firewall_name: main                      # Le nom du firewall derrière lequel on utilisera ces utilisateurs
								user_class:    OC\UserBundle\Entity\User # La classe de l'entité User que nous utilisons

						Et voilà, on a bien installéFOSUserBundle! Avant d'aller plus loin, créons la tableUseret ajoutons quelques membres pour les tests.

					Mise à jour de la tableUser

						Il faut maintenant mettre à jour la table des utilisateurs, vu les modifications que l'on vient de faire. D'abord, allez la vider depuis phpMyAdmin, puis exécutez la commandephp bin/console doctrine:schema:update --force. Et voilà, votre table est créée !

						On a fini d'initialiser le bundle. Bon, bien sûr pour l'instant Symfony ne l'utilise pas encore, il manque un peu de configuration, attaquons-la.

				Configuration de la sécurité pour utiliser le bundle

						Maintenant on va reprendre notre configuration de la sécurité, pour utiliser tous les outils fournis par le bundle dès que l'on peut. Reprenez lesecurity.ymlsous la main, et c'est parti !

						L'encodeur

							Il est temps d'utiliser un vrai encodeur pour nos utilisateurs, car il est bien sûr hors de question de stocker leur mot de passe en clair ! On utilise couramment la méthode sha512. Modifiez donc l'encodeur de notre classe comme ceci (vous pouvez supprimer la ligne par défaut) :

								# app/config/security.yml

								security:
								  encoders:
									OC\UserBundle\Entity\User: sha512

						Le fournisseur

							Le bundle inclut son propre fournisseur en tant que service, qui utilise notre entitéUsermais avec ses propres outils. Vous pouvez donc modifier notre fournisseurmaincomme suit :

								# app/config/security.yml

								security:

								# …

								  providers:
									main:
									  id: fos_user.user_provider.username

							Dans cette configuration,fos_user.user_managerest le nom du service fourni par le bundleFOSUB.

						Le pare-feu

							Notre pare-feu était déjà pleinement opérationnel. Étant donné que nous n'avons pas changé le nom du fournisseur associé, la configuration du pare-feu est déjà à jour. Nous n'avons donc rien à modifier ici.

							On va juste en profiter pour activer la possibilité de « Se souvenir de moi » à la connexion. Cela permet aux utilisateurs de ne pas s'authentifier manuellement à chaque fois qu'ils accèdent à notre site. Ajoutez donc l'optionremember_medans la configuration. Voici ce que cela donne :

								# app/config/security.yml

								security:

								# …

								  firewalls:
									# … le pare-feu « dev »
									
									# Firewall principal pour le reste de notre site
									main:
									  pattern:      ^/
									  anonymous:    true
									  provider:     main
									  form_login:
										login_path: login
										check_path: login_check
									  logout:
										path:       logout
										target:     login
									  remember_me:
										secret:     %secret% # %secret% est un paramètre de parameter

							J'ai juste ajouté le dernier paramètreremember_me.

						Configuration de la sécurité : check !

							Et voilà, votre site est prêt à être sécurisé ! En effet, on a fini de configurer la sécurité pour utiliser tout ce qu'offre le bundle à ce niveau.

							Pour tester à nouveau si tout fonctionne, il faut ajouter des utilisateurs à notre base de données. Pour cela, on ne va pas réutiliser nos fixtures précédentes, mais on va utiliser une commande très sympa proposée parFOSUserBundle. Exécutez la commande suivante et laissez-vous guider :

								php bin/console fos:user:create

							Vous l'aurez deviné, c'est une commande très pratique qui permet de créer des utilisateurs facilement. Laissez-vous guider, elle vous demande le nom d'utilisateur, l'e-mail et le mot de passe, et hop !, elle crée l'utilisateur. Vous pouvez aller vérifier le résultat dans phpMyAdmin. Notez au passage que le mot de passe a bien été encodé, en sha512 comme on l'a demandé.

							FOSUserBundleoffre bien plus que seulement de la sécurité. Du coup, maintenant que la sécurité est bien configurée, passons au reste de la configuration du bundle.

					Configuration du bundleFOSUserBundle

						Configuration des routes

							En plus de gérer la sécurité, le bundleFOSUserBundlegère aussi les pages classiques comme la page de connexion, celle d'inscription, etc. Pour toutes ces pages, il faut évidemment enregistrer les routes correspondantes. Les développeurs du bundle ont volontairement éclaté toutes les routes dans plusieurs fichiers pour pouvoir personnaliser facilement toutes ces pages. Pour l'instant, on veut juste les rendre disponibles, on les personnalisera plus tard. Ajoutez donc dans votrerouting.ymlles imports suivants à la suite du nôtre :

								# app/config/routing.yml

								# …

								fos_user_security:
									resource: "@FOSUserBundle/Resources/config/routing/security.xml"

								fos_user_profile:
									resource: "@FOSUserBundle/Resources/config/routing/profile.xml"
									prefix: /profile

								fos_user_register:
									resource: "@FOSUserBundle/Resources/config/routing/registration.xml"
									prefix: /register

								fos_user_resetting:
									resource: "@FOSUserBundle/Resources/config/routing/resetting.xml"
									prefix: /resetting

								fos_user_change_password:
									resource: "@FOSUserBundle/Resources/config/routing/change_password.xml"
									prefix: /profile

							Vous remarquez que les routes sont définies en XML et non en YML comme on en a l'habitude dans ce cours. En effet, je vous en avais parlé tout au début, Symfony permet d'utiliser plusieurs méthodes pour les fichiers de configuration : YML, XML et même PHP, au choix du développeur. Ouvrez ces fichiers de routes pour voir à quoi ressemblent des routes en XML. C'est quand même moins lisible qu'en YML, c'est pour cela qu'on a choisi YML au début. ;)

							Ouvrez vraiment ces fichiers pour connaître toutes les routes qu'ils contiennent. Vous saurez ainsi faire des liens vers toutes les pages qu'offre le bundle : inscription, mot de passe perdu, etc. Inutile de réinventer la roue ! Voici quand même un extrait de la commandephp bin/console debug:router pour les routes qui concernent ce bundle :

								fos_user_security_login           ANY      ANY  /login
								fos_user_security_check           ANY      ANY  /login_check
								fos_user_security_logout          ANY      ANY  /logout
								fos_user_profile_show             GET      ANY  /profile/
								fos_user_profile_edit             ANY      ANY  /profile/edit
								fos_user_registration_register    ANY      ANY  /register/
								fos_user_registration_check_email GET      ANY  /register/check-email
								fos_user_registration_confirm     GET      ANY  /register/confirm/{token}
								fos_user_registration_confirmed   GET      ANY  /register/confirmed
								fos_user_resetting_request        GET      ANY  /resetting/request
								fos_user_resetting_send_email     POST     ANY  /resetting/send-email
								fos_user_resetting_check_email    GET      ANY  /resetting/check-email
								fos_user_resetting_reset          GET|POST ANY  /resetting/reset/{token}
								fos_user_change_password          GET|POST ANY  /profile/change-password

							Vous notez que le bundle définit également les routes de sécurité/loginet autres. Du coup, je vous propose de laisser le bundle gérer cela, supprimez donc les trois routeslogin,login_checketlogoutqu'on avait déjà définies et qui ne servent plus. De plus, il faut adapter la configuration du pare-feu, car le nom de ces routes a changé, voici ce que cela donne :

								# app/config/security.yml

								security:
								  firewalls:
									main:
									  pattern:      ^/
									  anonymous:    true
									  provider:     main
									  form_login:
										login_path: fos_user_security_login
										check_path: fos_user_security_check
									  logout:
										path:       fos_user_security_logout
										target:     fos_user_security_login
									  remember_me:
										secret:     %secret%
			
								Comme notre bundleOCUserBundlehérite deFOSUserBundle, c'est notre contrôleur et donc notre vue qui sont utilisés sur la routeloginpour l'instant, car les noms que nous avions utilisés sont les mêmes que ceux deFOSUserBundle. Étant donné que le contrôleur deFOSUserBundleapporte un petit plus (protection CSRF notamment), je vous propose de supprimer notre contrôleurSecurityControlleret notre vueSecurity/login.html.twigpour laisser ceux deFOSUserBundleprendre la main.

							Il reste quelques petits détails à gérer comme la page de login qui n'est plus la plus sexy, sa traduction, et aussi un bouton « Déconnexion », parce que changer manuellement l'adresse en/logout, c'est pas super user-friendly !

					Personnalisation esthétique du bundle

						Heureusement tout cela est assez simple.

							Attention, la personnalisation esthétique que nous allons faire ne concerne en rien la couche sécurité à proprement parler. Soyez bien conscients de la différence !

						Intégrer les pages du bundle dans notre layout

							FOSUserBundleutilise un layout volontairement simpliste, parce qu'il a vocation à être remplacé par le nôtre. Le layout actuel est le suivant : https://github.com/FriendsOfSymfony/FO [...] out.html.twig

							On va donc tout simplement le remplacer par une vue Twig qui va étendre notre layout à nous. Pour « remplacer » le layout du bundle, on va utiliser l'un des avantages d'avoir hérité de ce bundle dans le nôtre, en créant une vue du même nom dans notre bundle. Créez-donc la vuelayout.html.twigsuivante :

								{# src/OC/UserBundle/Resources/views/layout.html.twig #}

								{# On étend notre layout #}
								{% extends "OCCoreBundle::layout.html.twig" %}

								{# Dans notre layout, il faut définir le block body #}
								{% block body %}

								  {# On affiche les messages flash que définissent les contrôleurs du bundle #}
								  {% for key, messages in app.session.flashbag.all() %}
									{% for message in messages %}
									  <div class="alert alert-{{ key }}">
										{{ message|trans({}, 'FOSUserBundle') }}
									  </div>
									{% endfor %}
								  {% endfor %}

								  {# On définit ce block, dans lequel vont venir s'insérer les autres vues du bundle #}
								  {% block fos_user_content %}
								  {% endblock fos_user_content %}

								{% endblock %}

								Pour créer ce layout je me suis simplement inspiré de celui fourni parFOSUserBundle, en l'adaptant à notre cas.
					
							Et voilà, si vous actualisez la page/login(après vous être déconnectés via/logoutévidemment), vous verrez que le formulaire de connexion est parfaitement intégré dans notre design ! Vous pouvez également tester la page d'inscription sur/register, qui est bien intégrée aussi.

							Votre layout n'est pas pris en compte ? N'oubliez jamais d'exécuter la commandephp bin/console cache:clearlorsque vous avez des erreurs qui vous étonnent !


						Traduire les messages

							FOSUBétant un bundle international, le texte est géré par le composant de traduction de Symfony. Par défaut, celui-ci est désactivé. Pour traduire le texte, il suffit donc de l'activer (direction le fichierconfig.yml) et de décommenter une des premières lignes dansframework:

								# app/config/config.yml

								framework:
									translator:      { fallbacks: ["%locale%"] }

							Où%locale%est un paramètre défini un peu plus haut dans le fichier de config. et que vous pouvez mettre à « fr » si ce n'est pas déjà fait. Ainsi, tous les messages utilisés parFOSUserBundleseront traduits en français !

						Afficher une barre utilisateur

							Il est intéressant d'afficher dans le layout si le visiteur est connecté ou non, et d'afficher des liens vers les pages de connexion ou de déconnexion. Cela se fait facilement, je vous invite à insérer ceci dans votre layout, où vous voulez :

								{% if is_granted("IS_AUTHENTICATED_REMEMBERED") %}
									Connecté en tant que {{ app.user.username }}
									-
									<a href="{{ path('fos_user_security_logout') }}">Déconnexion</a>
								{% else %}
									<a href="{{ path('fos_user_security_login') }}">Connexion</a>
								{% endif %}

							Adaptez et mettez ce code dans votre layout, effet garanti. ;)

								Le rôleIS_AUTHENTICATED_REMEMBEREDest donné à un utilisateur qui s'est authentifié soit automatiquement grâce au cookieremember_me, soit en utilisant le formulaire de connexion. Le rôleIS_AUTHENTICATED_FULLYest donné à un utilisateur qui s'est obligatoirement authentifié manuellement, en rentrant son mot de passe dans le formulaire de connexion. C'est utile pour protéger les opérations sensibles comme le changement de mot de passe ou d'adresse e-mail.

					Manipuler les utilisateurs avecFOSUserBundle

						Nous allons voir les moyens pour manipuler vos utilisateurs au quotidien.

						Si les utilisateurs sont gérés parFOSUserBundle, ils ne restent que des entités Doctrine2 des plus classiques. Ainsi, vous pourriez très bien vous créer un repository comme vous savez le faire. Cependant, profitons du fait que le bundle intègre unUserManager(c'est une sorte de repository avancé). Ainsi, voici les principales manipulations que vous pouvez faire avec :

							<?php
							// Dans un contrôleur :

							// Pour récupérer le service UserManager du bundle
							$userManager = $this->get('fos_user.user_manager');

							// Pour charger un utilisateur
							$user = $userManager->findUserBy(array('username' => 'winzou'));

							// Pour modifier un utilisateur
							$user->setEmail('cetemail@nexiste.pas');
							$userManager->updateUser($user); // Pas besoin de faire un flush avec l'EntityManager, cette méthode le fait toute seule !

							// Pour supprimer un utilisateur
							$userManager->deleteUser($user);

							// Pour récupérer la liste de tous les utilisateurs
							$users = $userManager->findUsers();

						Si vous avez besoin de plus de fonctions, vous pouvez parfaitement faire un repository personnel, et le récupérer comme d'habitude via$this->getDoctrine()->getManager()->getRepository('OCUserBundle:User'). Et si vous voulez en savoir plus sur ce que fait le bundle dans les coulisses, n'hésitez pas à aller voir le code des contrôleurs du bundle.

				Pour conclure

					Ce chapitre touche à sa fin. Vous avez maintenant tous les outils en main pour construire votre espace membres, avec un système d'authentification performant et sécurisé, et des accès limités pour vos pages suivant des droits précis.

					Sachez que tout ceci n'est qu'une introduction à la sécurité sous Symfony. Les processus complets sont très puissants mais évidemment plus complexes. Si vous souhaitez aller plus loin pour faire des opérations plus précises (authentification Facebook, LDAP, etc.), n'hésitez pas à vous référer à la documentation officielle sur la sécurité. Allez jeter un œil également à la documentation deFOSUserBundle, qui explique comment personnaliser au maximum le bundle, ainsi que l'utilisation des groupes.

					Pour information, il existe également un système d'ACL, qui vous permet de définir des droits bien plus finement que les rôles. Par exemple, pour autoriser l'édition d'une annonce si on est admin ou si on en est l'auteur. Je ne traiterai pas ce point dans ce cours, mais n'hésitez pas à vous référer à la documentation à ce sujet.

						La sécurité se compose de deux couches :
							L'authentification, qui définit qui est le visiteur ;
							L'autorisation, qui définit si le visiteur a accès à la ressource demandée.
						Le fichiersecurity.ymlpermet de configurer finement chaque acteur de la sécurité :
							La configuration de l'authentification passe surtout par le paramétrage d'un ou plusieurs pare-feu ;
							La configuration de l'autorisation se fait au cas par cas suivant les ressources : on peut sécuriser une méthode de contrôleur, un affichage ou une URL.
						Les rôles associés aux utilisateurs définissent les droits dont ils disposent ;
						On peut configurer la sécurité pour utiliserFOSUserBundle, un bundle qui offre un espace membres presque clé en main.
						Le code du cours tel qu'il doit être à ce stade est disponible sur la branche iteration-16 du dépot Github.
			
					- https://symfony.com/doc/current/security.html
					- https://symfony.com/doc/master/bundles/FOSUserBundle/index.html
					- https://symfony.com/doc/master/bundles/FOSUserBundle/groups.html
					
					
		
		4. Les services, utilisation poussée
		
			Les tags sur les services
			
				Les tags ?

					Les tags sont une fonctionnalité très importante des services. Cela permet d'ajouter des fonctionnalités à un composant sans en modifier le code. On les a déjà rapidement évoqués lorsqu'on traitait les évènements Doctrine, voici maintenant l'occasion de les théoriser un peu.

					Concrètement, un tag est une information que l'on appose à un ou plusieurs services afin que le conteneur de services les identifie comme tels. Ainsi, il devient possible de récupérer tous les services qui possèdent un certain tag.

					Pour bien comprendre en quoi cela permet d'ajouter des fonctionnalités à un composant existant, prenons l'exemple de Twig.

				Comprendre les tags à travers Twig

					Le moteur de templates Twig dispose nativement de plusieurs fonctions pratiques pour vos vues. Seulement, il serait intéressant de pouvoir ajouter nos propres fonctions qu'on pourra utiliser dans nos vues, et ce sans modifier le code meme de Twig. Vous l'aurez compris, c'est possible grâce au mécanisme des tags.

					L'idée est que Twig définit un tag, dans notre cas twig.extension, et une interface, dans notre cas\Twig_ExtensionInterface. Ensuite, Twig récupère tous les services qui ont ce tag, et sait les utiliser car ils implémentent tous la même interface (ils ont donc des méthodes connues).

					Construisons notre propre fonction Twig pour se rendre compte du mécanisme.

					Appliquer un tag à un service

						Pour que Twig puisse récupérer tous les services qui vont définir des fonctions supplémentaires utilisables dans nos vues, il faut appliquer un tag à ces services. Pour l'exemple, nous allons rendre disponible la méthode pour détecter le spam que nous avions créée dans le serviceoc_platform.antispam. L'objectif est donc d'avoir dans nos vues une fonction{{ checkIfSpam("mon message") }}  (le nom étant arbitraire !).

						Nous n'allons pas taguer le serviceoc_platform.antispam en lui-même, car ce service a déjà une mission : vérifier si un message est du spam ou pas. Ce n'est pas son rôle de se rendre disponible depuis une vue Twig. Créons donc d'abord ce mini-service tout simple :

							<?php
							// src/OC/PlatformBundle/Twig/AntispamExtension.php

							namespace OC\PlatformBundle\Twig;

							use OC\PlatformBundle\Antispam\OCAntispam;

							class AntispamExtension
							{
							  /**
							   * @var OCAntispam
							   */
							  private $ocAntispam;

							  public function __construct(OCAntispam $ocAntispam)
							  {
								$this->ocAntispam = $ocAntispam;
							  }

							  public function checkIfArgumentIsSpam($text)
							  {
								return $this->ocAntispam->isSpam($text);
							  }
							}
					 

							Ici, notre petit service intermédiaire ne fait effectivement pas grand chose. Mais il est tout de même important de respecter le principe « 1 service = 1 mission ». Ce petit service a comme mission d'être une extension Twig concernant le spam, ce que nous définissons juste après. Dans ce cadre, il pourrait très bien faire appel à d'autres services de spam et donc grossir un peu : ne vous laissez pas avoir par son apparente simplicité ;)
					
						Ainsi que sa configuration de base :

							# src/OC/PlatformBundle/Resources/config/services.yml

							services:
							  oc_platform.twig.antispam_extension:
								class: OC\PlatformBundle\Twig\AntispamExtension
								arguments:
								  - "@oc_platform.antispam"
						
						Voilà, nous pouvons maintenant travailler sur ce service.

						Commençons donc par ajouter le tag dans sa configuration.

							# src/OC/PlatformBundle/Resources/config/services.yml

							services:
							  oc_platform.twig.antispam_extension:
								class: OC\PlatformBundle\Twig\AntispamExtension
								arguments:
								  - "@oc_platform.antispam"
								tags:
								  -  { name: twig.extension }
								  
						Vous voyez, on a simplement rajouté un attributtagsà la configuration de notre service. Cet attribut contient un tableau de tags, d'où le retour à la ligne et le tiret « - ». En effet, il est tout à fait possible d'associer plusieurs tags à un même service.

						Dans ce tableau de tags, on a ajouté une ligne avec un attributname, qui est le nom du tag. C'est grâce à ce nom que Twig va pouvoir récupérer tous les services avec ce tag. Icitwig.extensionest donc le tag qu'on utilise. Lorsque vous utilisez le système de tags pour votre propre fonctionnalité, vous pouvez choisir le nom de tag que vous souhaitez il n'y a pas de contrainte.

						Bien entendu, maintenant que Twig peut récupérer tous les services tagués, il faut qu'il sache un peu comment votre service fonctionne, pour que tout le monde puisse se comprendre : cela passe par l'interface.

					Une classe qui implémente une interface

						Celui qui va récupérer les services d'un certain tag attend un certain comportement de la part des services qui ont ce tag. Il faut donc les faire implémenter une interface ou étendre une classe de base.

						En particulier, Twig attend que votre service implémente l'interfaceTwig_ExtensionInterface. Encore plus simple, Twig propose une classe abstraite à hériter par notre service, il s'agit de Twig_Extension, qui implémente elle-même l'interface. Je vous invite donc à modifier notre classeAntispamExtension pour qu'elle hérite deTwig_Extension:

							<?php
							// src/OC/PlatformBundle/Twig/AntispamExtension.php

							namespace OC\PlatformBundle\Twig;

							use OC\PlatformBundle\Antispam\OCAntispam;

							class AntispamExtension extends \Twig_Extension
							{
							  // …
							}
					
						Notre service est prêt à fonctionner avec Twig, il ne reste plus qu'à écrire au moins une des méthodes de la classe abstraiteTwig_Extension.

					Écrire le code qui sera exécuté

						Cette section est propre à chaque tag, où celui qui récupère les services d'un certain tag va exécuter telle ou telle méthode des services tagués. En l'occurrence, Twig va exécuter les méthodes suivantes :

							getFilters(), qui retourne un tableau contenant les filtres que le service ajoute à Twig ;
							
							getTests(), qui retourne les tests ;
							
							getFunctions(), qui retourne les fonctions ;
							
							getOperators(), qui retourne les opérateurs.
					
						Pour notre exemple, nous allons juste ajouter une fonction accessible dans nos vues via{{ checkIfSpam('le message') }}. Elle vérifie si son argument est un spam. Pour cela, écrivons la méthodegetFunctions()suivante dans notre service :

							<?php
							// src/OC/PlatformBundle/Twig/AntispamExtension.php

							namespace OC\PlatformBundle\Twig;

							use OC\PlatformBundle\Antispam\OCAntispam;

							class AntispamExtension extends \Twig_Extension
							{
							  // ...

							  // Twig va exécuter cette méthode pour savoir quelle(s) fonction(s) ajoute notre service
							  public function getFunctions()
							  {
								return array(
								  new \Twig_SimpleFunction('checkIfSpam', array($this, 'checkIfArgumentIsSpam')),
								);
							  }

							  // La méthode getName() identifie votre extension Twig, elle est obligatoire
							  public function getName()
							  {
								return 'OCAntispam';
							  }
							}

						Dans cette méthodegetFunctions() , il faut retourner un tableau d'objet\Twig_SimpleFunction, dont :

							Le premier argument, icicheckIfSpam, est le nom de la fonction qui sera disponible dans nos vues Twig ;
							
							Le deuxième argument, iciarray($this, 'checkIfArgumentIsSpam') est un callable PHP. Dans notre cas, on appelle la méthode de l'extension Twig même, mais en réalité on pourrait également définir le callable àarray($this->ocAntispam, 'isSpam') pour qu'il appelle directement la méthode de notre serviceOCAntispam. Les deux méthodes sont possibles ici.
					
						Au final, {{ checkIfSpam(var) }} côté Twig exécute$this->isSpam($var) côtéOCAntispam.

						On a également ajouté la méthodegetName()qui identifie votre service de manière unique parmi les extensions Twig, elle est obligatoire, ne l'oubliez pas.

						Et voilà ! Vous pouvez dès à présent utiliser la fonction{{ checkIfSpam() }}dans vos vues. Comment Twig est-il au courant de notre nouvelle fonction ? Grâce au tag justement !

					Méthodologie

						Ce qu'on vient de faire pour transformer notre simple service en extension Twig est la méthodologie à appliquer systématiquement lorsque vous taguez un service. Sachez que tous les tags ne nécessitent pas forcément que votre service implémente une certaine interface, mais c'est assez fréquent.

						Pour connaître tous les services implémentant un certain tag, vous pouvez exécuter la commande suivante :

							C:\wamp\www\Symfony> php bin/console debug:container --tag=twig.extension

							Symfony Container Public Services Tagged with "twig.extension" Tag
							==================================================================

							 ------------------------------------- ------------------------------------------
							 Service ID Class name
							 ------------------------------------- ------------------------------------------
							 oc_platform.twig.antispam_extension   OC\PlatformBundle\Twig\AntispamExtension
							 ------------------------------------- ------------------------------------------
					‌
						Récupérer tous ces services tagués, c'est exactement ce que fait Twig lorsqu'il s'initialise. De cette façon, il peut ajouter nos fonctions à son comportement.

							Vous trouverez plus d'informations sur la création d'extensions Twig dans la documentation de Twig.
					
				Les principaux tags

					Il existe pas mal de tags prédéfinis dans Symfony, qui permettent d'ajouter des fonctionnalités à droite et à gauche. Je ne vais vous présenter ici que deux des principaux tags. Mais sachez que l'ensemble des tags est expliqué dans la documentation.

					Les évènements du cœur

						Les services peuvent être utilisés avec le gestionnaire d'évènements, via le tagkernel.event_listener. Je ne le détaille pas plus ici car le gestionnaire d'évènements est un composant très intéressant, et fait l'objet d'un prochain chapitre dédié.

					Les types de champ de formulaire

						Le tagform.typepermet de définir un nouveau type de champ de formulaire. Par exemple, si vous souhaitez utiliser l'éditeur WYSIWYG (What you see is what you get) ckeditor pour certains de vos champs texte, il est facile de créer un champckeditorau lieu detextarea. Pour cela, disons que vous avez ajouté le JavaScript nécessaire pour activer cet éditeur sur les<textarea>qui possèdent la classeckeditor. Il ne reste plus qu'à automatiser l'apparition de cette classe.

						Commençons par créer la classe du type de champ :

							<?php
							// src/OC/PlatformBundle/Form/CkeditorType.php

							namespace OC\PlatformBundle\Form;

							use Symfony\Component\Form\AbstractType;
							use Symfony\Component\Form\Extension\Core\Type\TextareaType;
							use Symfony\Component\OptionsResolver\OptionsResolver;

							class CkeditorType extends AbstractType
							{
							  public function configureOptions(OptionsResolver $resolver)
							  {
								$resolver->setDefaults(array(
								  'attr' => array('class' => 'ckeditor') // On ajoute la classe CSS
								));
							  }

							  public function getParent() // On utilise l'héritage de formulaire
							  {
								return TextareaType::class;
							  }
							}

						Ce type de champ hérite de toutes les fonctionnalités d'untextarea(grâce à la méthodegetParent()) tout en disposant de la classe CSSckeditor(définie dans la méthodesetDefaultOptions()) vous permettant, en ajoutantckeditorà votre site, de transformer vos<textarea>en éditeur WYSIWYG.

						Puis, déclarons cette classe en tant que service, en lui ajoutant le tagform.type:

							# src/OC/PlatformBundle/Resources/config/services.yml

							services:
							  oc_platform.form.ckeditor:
								class: OC\PlatformBundle\Form\CkeditorType
								tags:
								  - { name: form.type, alias: ckeditor }

							On a ajouté l'attributaliasdans le tag, qui représente le nom sous lequel on pourra utiliser ce nouveau type. Pour l'utiliser, c'est très simple, modifiez vos formulaires pour utiliserckeditorà la place detextarea. Par exemple, dans notreAdvertType:

							<?php
							// src/OC/PlatformBundle/Form/ArticleType.php

							namespace OC\PlatformBundle\Form;

							class AdvertType extends AbstractType
							{
							  public function buildForm(FormBuilderInterface $builder, array $options)
							  {
								$builder
								  // …
								  ->add('content', CkeditorType::class)
								;
							  }

							  // …
							}
							
						Et voilà, votre champ a maintenant automatiquement la classe CSSckeditor, ce qui permet d'activer l'éditeur (si vous l'avez ajouté à votre site bien sûr).

						C'était un exemple pour vous montrer comment utiliser les tags dans ce contexte.

							Pour plus d'informations sur la création de type de champ que l'on vient à peine de survoler, je vous invite à lire la documentation à ce sujet.
				
				
			Dépendances optionnelles : les appels de méthodes (ou calls en anglais)
				
				Les dépendances optionnelles

					L'injection de dépendances dans le constructeur, comme on l'a fait dans le précédent chapitre sur les services, est un très bon moyen de s'assurer que la dépendance sera bien disponible. Mais parfois vous pouvez avoir des dépendances optionnelles. Ce sont des dépendances qui peuvent être rajoutées au milieu de l'exécution de la page, grâce à des setters. Reprenons par exemple notre service d'antispam, et choisissons de définir l'argument$locale comme optionnel. L'idée est de supprimer ce dernier des arguments du constructeur, et d'ajouter le setter correspondant :

						<?php
						// src/OC/PlatformBundle/Antispam/OCAntispam.php

						namespace OC\PlatformBundle\Antispam;

						class OCAntispam
						{
						  private $mailer;
						  private $locale;
						  private $minLength;

						  public function __construct(\Swift_Mailer $mailer, $minLength)
						  {
							$this->mailer    = $mailer;
							$this->minLength = (int) $minLength;
						  }

						  public function setLocale($locale)
						  {
							$this->locale = $locale;
						  }

						  // …
						}
						
					N'oubliez pas de supprimer l'argument%locale% de la définition du service. Rappelez-vous : si vous modifiez le constructeur d'un service, vous devez adapter sa configuration, et inversement.

					Avec cette modification, notre service est créé sans renseigné l'attribut locale du service. Celui-ci vaut donc null, tant qu'il n'a pas été renseigné. Pour venir la renseigner, les calls interviennent.

				Les calls

					Les calls (que l'on traduirait en français par « les appels de méthodes ») sont un moyen d'exécuter des méthodes de votre service juste après sa création. Ainsi, on peut exécuter la méthodesetLocale() avec notre paramètre%locale%, qui sera une valeur par défaut pour ce service. Elle pourra tout à fait être écrasée par une autre valeur au cours de l'exécution de la page (à chaque appel de la méthodesetLocale).

					Je vous invite donc à rajouter l'attribut calls à la définition du service, comme ceci :

						# src/OC/PlatformBundle/Resources/config/services.yml

						services:
						  oc_platform.antispam:
							class: OC\PlatformBundle\Antispam\OCAntispam
							arguments:
							  - "@mailer"
							  - 50
							calls:
							  - [ setLocale, [%locale%] ]
							  
					Comme avec les tags, vous pouvez définir plusieurs calls, en rajoutant des lignes qui commencent par un tiret. Chaque ligne de call est un tableau qui se décompose comme suit :

						Le premier index, icisetLocale, est le nom de la méthode à exécuter ;
						
						Le deuxième index, ici[ %locale% ], est le tableau des arguments à transmettre à la méthode exécutée. Ici nous avons un seul argument, mais il est tout à fait possible d'en définir plusieurs.
						
					Concrètement, dans notre cas le code équivalent du conteneur serait celui-ci :

						<?php

						$antispam = new \OC\PlatformBundle\Antispam\OCAntispam($mailer, 50);
						$antispam->setLocale($locale);
				
					Ce code n'existe pas, c'est un code fictif pour vous représenter l'équivalent de ce que fait le conteneur de services dans son coin lorsque vous demandez le serviceoc_platform.antispam.

				L'utilité des calls

					En plus du principe de dépendance optionnelle, l'utilité des calls est également remarquable pour l'intégration des bibliothèques externes (Zend Framework, GeSHI, etc.), qui ont besoin d'exécuter quelques méthodes en plus du constructeur. Vous pourrez donc le faire grâce aux calls.

					Attention lorsque vous construisez un service en vous basant sur les calls. Pensez votre service en gardant en tête que la valeur de l'attribut définit par le calls peut changer au cours de l'exécution. Cela peut avoir un impact. En fait, ce dynamisme est l'une des raisons qui peut vous pousser à utiliser un call plutôt qu'un simple argument dans le constructeur.
			
			Les services courants de Symfony
				
				Maintenant que vous savez bien utiliser les services, il vous faut les connaître tous afin d'utiliser la puissance de chacun. Il est important de bien savoir quels sont les services existants afin de bien pouvoir injecter ceux qu'il faut dans les services.

				Je vous propose donc une liste des services par défaut de Symfony les plus utilisés. Gardez-la en tête !

					Identifiant
						
						Description
						
					doctrine.orm.entity_manager
					
						Ce service est l'instance de l'EntityManagerde Doctrine ORM. On l'a rapidement évoqué dans la partie sur Doctrine, l'EntityManagerest bien enregistré en tant que service dans Symfony. Ainsi, lorsque dans un contrôleur vous faites$this->getDoctrine()->getManager(), vous récupérez en réalité le servicedoctrine.orm.entity_manager. Ayez bien ce nom en tête, car vous aurez très souvent besoin de l'injecter dans vos propres services : il vous offre l'accès à la base de données, ce n'est pas rien !
					
					event_dispatcher
						
						Ce service donne accès au gestionnaire d'évènements. Le décrire en quelques lignes serait trop réducteur, je vous propose donc d'être patients, car le prochain chapitre lui est entièrement dédié. ;)
					
					kernel
						
						Ce service vous donne accès au noyau de Symfony. Grâce à lui, vous pouvez localiser des bundles, récupérer le chemin de base du site, etc. Voyez le fichierKernel.phppour connaître toutes les possibilités. Nous nous en servirons très peu en réalité.
					
					logger
						
						Ce service gère les logs de votre application. Grâce à lui, vous pouvez utiliser des fichiers de logs très simplement. Symfony utilise la classeMonologpar défaut pour gérer ses logs. La documentation à ce sujet vous expliquera comment vous en servir si vous avez besoin d'enregistrer des logs pour votre propre application ; c'est intéressant, n'hésitez pas à vous renseigner.
					
					mailer
					
						Ce service vous renvoie par défaut une instance deSwift_Mailer, une classe permettant d'envoyer des e-mails facilement. Encore une fois, la documentation deSwiftMailer et la documentation de son intégration dans Symfony vous seront d'une grande aide si vous souhaitez envoyer des e-mails.
					
					request_stack
						
						Ce service est très important : il vous donne un objet qui vous permet de récupérer la requêteRequest courante via sa méthode getCurrentRequest. Je vous réfère au chapitre sur les contrôleurs, sectionRequest pour plus d'informations sur comment récupérer la session, l'IP du visiteur, la méthode de la requête, etc.

						Ce service utiliser les calls pour définir la requête justement, car la requête peut changer au cours de son exécution (lors d'une sous-requête).
					
					router
					
						Ce service vous donne accès au routeur (Symfony\Component\Routing\Router). On l'a déjà abordé dans le chapitre sur les routes, c'est le service qui permet de générer des routes.
					
					security.token_storage
					
						Ce service permet de gérer l'authentification sur votre site internet. On l'utilise notamment pour récupérer l'utilisateur courant. Le raccourci du contrôleur$this->getUser()exécute en réalité$this->container->get('security.token_storage')->getToken()->getUser()!
					
					service_container
					
						Ce service vous renvoie le conteneur de services lui-même. On ne l'utilise que très rarement, car, comme je vous l'ai déjà mentionné, il est bien plus propre de n'injecter que les services dont on a besoin, et non pas tout le conteneur. Mais dans certains cas il est nécessaire de s'en servir, sachez donc qu'il existe.
					
					twig
					
						Ce service représente une instance deTwig_Environment. Il permet d'afficher ou de retourner une vue. Vous pouvez en savoir plus en lisant la documentation de Twig. Ce service peut être utile pour modifier l'environnement de Twig depuis l’extérieur (lui ajouter des extensions, etc.).
					
					templating
						
						Ce service représente le moteur de templates de Symfony. Par défaut il s'agit de Twig, mais cela peut également être PHP ou tout autre moteur intégré dans un bundle tiers. Ce service montre l'intérêt de l'injection de dépendances : en injectanttemplatinget nontwigdans votre service, vous faites un code valide pour plusieurs moteurs de templates ! Et si l'utilisateur de votre bundle utilise un moteur de templates à lui, votre bundle continuera de fonctionner. Sachez également que le raccourci du contrôleur$this->render()exécute en réalité$this->container->get('templating')->renderResponse().
				
				En résumé

					Les tags permettent de récupérer tous les services qui remplissent une même fonction : cela ouvre les possibilités pour les extensions Twig, les évènements, etc.
					
					Les calls permettent les dépendances optionnelles, et facilitent l'intégration de bibliothèques tierces.
					
					Les principaux noms de services sont à connaître par cœur afin d'injecter ceux nécessaires dans les services que vous créerez !
					
					Le code du cours tel qu'il doit être à ce stade est disponible sur la branche iteration-17 du dépot Github.
				
			
		
		5. Le gestionnaire d'évènements de Symfony
		
			
			Des évènements ? Pour quoi faire ?
			
				Qu'est-ce qu'un évènement ?

					Un évènement correspond à un moment clé dans l'exécution d'une page. Il en existe plusieurs, par exemple l'évènementkernel.requestqui est déclenché avant que le contrôleur ne soit exécuté. Cet évènement est déclenché à chaque page, mais il en existe d'autres qui ne le sont que lors d'actions particulières, par exemple l'évènementsecurity.interactive_login, qui correspond à l'identification d'un utilisateur.

					Tous les évènements sont déclenchés à des endroits stratégiques de l'exécution d'une page Symfony, et vont nous permettre de réaliser nos rêves de façon classe et surtout découplée.

					Si vous avez déjà fait un peu de JavaScript, alors vous avez sûrement déjà traité des évènements. Par exemple, l'évènementonClickdoit vous parler. Il s'agit d'un évènement qui est déclenché lorsque l’utilisateur clique quelque part, et on y associe une action (quelque chose à faire). Bien sûr, en PHP vous ne serez pas capables de détecter le clic utilisateur, c'est un langage serveur ! Mais l'idée est exactement la même.

				Qu'est-ce que le gestionnaire d'évènements ?

					J'ai parlé à l'instant de découplage. C'est la principale raison de l'utilisation d'un gestionnaire d'évènements ! Par code découplé, j'entends que celui qui écoute l'évènement ne dépend pas du tout de celui qui déclenche l'évènement. Je m'explique :

						On parle de déclencher un évènement lorsqu'on signale au gestionnaire d'évènements : « Tel évènement vient de se produire, préviens tout le monde, s'il-te-plaît. » Pour reprendre l'exemple de l'évènementkernel.request, c'est, vous l'aurez deviné, le Kernel qui déclenche l'évènement.
						
						On parle d'écouter un évènement lorsqu'on signale au gestionnaire d'évènements : « Je veux que tu me préviennes dès que tel évènement se produira, s'il-te-plaît. »
						Ainsi, lorsqu'on écoute un évènement que le Kernel va déclencher, on ne touche pas au Kernel, on ne vient pas perturber son fonctionnement. On se contente d'exécuter du code de notre côté, en ne comptant que sur le déclenchement de l'évènement ; c'est le rôle du gestionnaire d'évènements de nous prévenir. Le code est donc totalement découplé, et en tant que bons développeurs, on aime ce genre de code !

					Au niveau du vocabulaire, un service qui écoute un évènement s'appelle un listener (personne qui écoute, en français).
						
					Pour bien comprendre le mécanisme, je vous propose un schéma sur la figure suivante montrant les deux étapes :

						Dans un premier temps, des services se font connaître du gestionnaire d'évènements pour écouter tel ou tel évènement. Ils deviennent des listeners ;
						
						Dans un deuxième temps, quelqu'un (qui que ce soit) déclenche un évènement, c'est-à-dire qu'il prévient le gestionnaire d'évènements qu'un certain évènement vient de se produire. À partir de là, le gestionnaire d'évènement exécute chaque service qui s'est préalablement inscrit pour écouter cet évènement précis.
				
							Fonctionnement du gestionnaire d'évènements
				
							Certains d'entre vous auront peut-être reconnu le pattern Observer. En effet, le gestionnaire d'évènements de Symfony n'est qu'une implémentation de ce pattern.
			
			Écouter les évènements
				
				Notre exemple

					Dans un premier temps, nous allons apprendre à écouter des évènements. Pour cela, je vais me servir d'un exemple simple : l'ajout d'une bannière « bêta » sur notre site, qui est encore en bêta car nous n'avons pas fini son développement ! L'objectif est donc de modifier chaque page retournée au visiteur pour ajouter cette balise.

					L'exemple est simpliste bien sûr, mais vous montre déjà le code découplé qu'il est possible de faire. En effet, pour afficher une mention « bêta » sur chaque page, il suffirait d'ajouter un ou plusieurs petitsifdans la vue. Mais ce ne serait pas très joli, et le jour où votre site passe en stable il ne faudra pas oublier de retirer l'ensemble de cesif, bref, il y a un risque. Avec la technique d'un listener unique, il suffira de désactiver celui-ci.

				Créer un service et son listener

					Nous voulons effectuer une certaine action lors d'un certain évènement. Dans ce que nous voulons, il y a deux choses à distinguer :

						D'une part, l'action à réaliser effectivement. Dans notre cas, il s'agit d'ajouter une mention beta à une réponse contenant du HTML. C'est une action certes simple, mais une action quand même, qui mérite son propre objet : un simple service. Appelons-leBetaHTMLAdder car il ajoute la mention beta à du HTML.
				
						D'autre part, le fait d'exécuter l'action précédente à un certain moment, avec certains paramètres. C'est une autre action, qui mérite donc un autre objet : le listener. Appelons-leBetaListener.
				
					C'est pourquoi nous allons créer deux objets différents.

					Attaquons le premier objet, celui qui contient la logique de ce qu'il y a à faire : ajouter la mention beta à une réponse.

					Pour savoir où placer ce service dans notre bundle, il faut se poser la question suivante : « À quelle fonction répond mon service ? » La réponse est « À définir la version bêta », on va donc placer l'objet dans le répertoireBeta, tout simplement. Pour l'instant il sera tout seul dans ce répertoire, mais on y ajoutera plus tard le listener.

					Je vous invite donc à créer cette classe :

						<?php
						// src/OC/PlatformBundle/Beta/BetaHTMLAdder.php

						namespace OC\PlatformBundle\Beta;

						use Symfony\Component\HttpFoundation\Response;

						class BetaHTMLAdder
						{
						  // Méthode pour ajouter le « bêta » à une réponse
						  public function addBeta(Response $response, $remainingDays)
						  {
							$content = $response->getContent();

							// Code à rajouter
							// (Je mets ici du CSS en ligne, mais il faudrait utiliser un fichier CSS bien sûr !)
							$html = '<div style="position: absolute; top: 0; background: orange; width: 100%; text-align: center; padding: 0.5em;">Beta J-'.(int) $remainingDays.' !</div>';

							// Insertion du code dans la page, au début du <body>
							$content = str_replace(
							  '<body>',
							  '<body> '.$html,
							  $content
							);

							// Modification du contenu dans la réponse
							$response->setContent($content);

							return $response;
						  }
						}
						
					Ainsi que la configuration du service correspondant :

						# src/OC/PlatformBundle/Resources/config/services.yml

						services:
						  oc_platform.beta.html_adder:
							class: OC\PlatformBundle\Beta\BetaHTMLAdder
					
					Pour l'instant, c'est un service tout simple, qui n'écoute personne. On dispose d'une méthodeaddBetaprête à l'emploi pour modifier la réponse lorsqu'on la lui donnera.

					Passons maintenant à la création du listener à proprement parler. Il nous faut donc une autre classe, qui contient une méthode pour ajouter si besoin (en fonction de la date) la mention beta à la réponse courante. Voici pour l'instant le squelette de cette classe, on n'a pas encore tout le contenu de cette méthode :

						<?php
						// src/OC/PlatformBundle/Beta/BetaListener.php

						namespace OC\PlatformBundle\Beta;

						use Symfony\Component\HttpFoundation\Response;

						class BetaListener
						{
						  // Notre processeur
						  protected $betaHTML;

						  // La date de fin de la version bêta :
						  // - Avant cette date, on affichera un compte à rebours (J-3 par exemple)
						  // - Après cette date, on n'affichera plus le « bêta »
						  protected $endDate;

						  public function __construct(BetaHTMLAdder $betaHTML, $endDate)
						  {
							$this->betaHTML = $betaHTML;
							$this->endDate  = new \Datetime($endDate);
						  }

						  public function processBeta()
						  {
							$remainingDays = $this->endDate->diff(new \Datetime())->days;

							if ($remainingDays <= 0) {
							  // Si la date est dépassée, on ne fait rien
							  return;
							}
							
							// Ici on appelera la méthode
							// $this->betaHTML->addBeta()
						  }
						}
						
						Je mets ici le listener dans le répertoire de la fonctionnalité, Beta. Il est aussi possible de regrouper tous les listeners dans un même répertoire, EventListener par exemple. Cela permet ainsi d'avoir tous les listeners d'un seul coup d'oeil, pour mieux voir ce qu'il se passe dans votre application. Les deux méthodes sont tout à fait valable, ma préférence va même à la seconde :)
				
					Voici donc le rôle de tout listener : un objet capable de décider s'il faut ou non appeler un autre objet qui remplira une certaine fonction. La fonction du listener n'est que de décider quand appeler l'autre objet. Parfois, il faut l'appeler à chaque fois qu'un évènement est déclenché ; parfois cela dépend d'autres conditions comme ce qu'on fait ici.

					Dans notre cas, la décision ou non d'appeler le BetaHTMLAdder repose sur la date courante : si elle est antérieure à la date définie dans le constructeur, on exécute BetaHTMLAdder. Sinon, on ne fait rien.

				Écouter un évènement

					Vous le savez maintenant, pour que notre classe précédente écoute quelque chose, il faut la présenter au gestionnaire d'évènements. Il existe deux manières de le faire : manipuler directement le gestionnaire d'évènements, ou passer par les services.

					Je ne vous cache pas qu'on utilisera très rarement la première méthode, mais je vais vous la présenter en premier, car elle permet de bien comprendre ce qu'il se passe dans la deuxième.

						Vu que nous avons besoin de modifier la réponse retournée par les contrôleurs, nous allons écouter l'évènementkernel.response. Je vous dresse plus loin une liste complète des évènements avec les informations clés pour déterminer lequel écouter. Pour le moment, suivons notre exemple.
				
					Méthode 1 : Manipuler directement le gestionnaire d'évènements

						Cette première méthode, un peu brute, consiste à passer notre objetBetaListenerau gestionnaire d'évènements. Ce gestionnaire existe en tant que service sous Symfony, il s'agit de l'EventDispatcher. Concrètement, voici comment faire :

							<?php
							// Depuis un contrôleur

							use OC\PlatformBundle\Beta\BetaListener;

							// …

							// On instancie notre listener
							$betaListener = new BetaListener('2016-06-01');

							// On récupère le gestionnaire d'évènements, qui heureusement est un service !
							$dispatcher = $this->get('event_dispatcher');

							// On dit au gestionnaire d'exécuter la méthode onKernelResponse de notre listener
							// lorsque l'évènement kernel.response est déclenché
							$dispatcher->addListener(
							  'kernel.response',
							  array($betaListener, 'processBeta')
							);
				
						À partir de maintenant, dès que l'évènementkernel.responseest déclenché, le gestionnaire d'évènements exécutera la méthode $betaListener->processBeta().

							Bien évidemment, avec cette méthode, le moment où vous exécutez ce code est important ! En effet, si vous prévenez le gestionnaire d'évènements après que l'évènement qui vous intéresse se soit produit, votre listener ne sera pas exécuté ! C'est pourquoi ce n'est que rarement que l'on fera comme ça.
				
					Méthode 2 : Définir son listener comme service

						Comme je vous l'ai dit, c'est cette méthode qu'on utilisera 99 % du temps. Elle est beaucoup plus simple et permet d'éviter le problème de l'évènement qui se produit avant l'enregistrement de votre listener dans le gestionnaire d'évènements.

						Mettons en place cette méthode pas à pas. Tout d'abord, définissez votre listener en tant que service, comme ceci :

							# src/OC/PlatformBundle/Resources/config/services.yml

							services:
							  oc_platform.beta.listener:
								class: OC\PlatformBundle\Beta\BetaListener
								arguments:
								  - "@oc_platform.beta.html_adder"
								  - "2017-06-01"
				
						À partir de maintenant, votre listener est accessible via le conteneur de services, en tant que service tout simple. Pour aller plus loin, il faut définir le tagkernel.event_listenersur ce service. Le processus est le suivant : une fois le gestionnaire d'évènements instancié par le conteneur de services, il va récupérer tous les services qui ont ce tag, et exécuter le code de la méthode 1 qu'on vient de voir afin d'enregistrer les listeners dans lui-même. Tout se fait automatiquement !

						Voici donc le tag en question à rajouter à notre service :

							# src/OC/PlatformBundle/Resources/config/services.yml

							services:
							  oc_platform.beta.listener:
								class: OC\PlatformBundle\Beta\BetaListener
								arguments:
								  - "@oc_platform.beta.html_adder"
								  - "2017-06-01"
								tags:
								  - { name: kernel.event_listener, event: kernel.response, method: processBeta }
								  
						Il y a deux paramètres à définir dans le tag, qui sont les deux paramètres qu'on a utilisés précédemment dans la méthode$dispatcher->addListener():

							event: c'est le nom de l'évènement que le listener veut écouter ;
							
							method: c'est le nom de la méthode du listener à exécuter lorsque l'évènement est déclenché.
				
						C'est tout ! Avec uniquement cette définition de service et le bon tag associé, votre listener sera exécuté à chaque déclenchement de l'évènementkernel.response!

						Bien entendu, votre listener peut tout à fait écouter plusieurs évènements. Il suffit pour cela d'ajouter un autre tag avec des paramètres différents. Voici ce que cela donnerait si on voulait écouter l'évènementkernel.controller:

							# src/OC/PlatformBundle/Resources/config/services.yml

							services:
							  oc_platform.beta.listener:
								class: OC\PlatformBundle\Beta\BetaListener
								arguments:
								  - "@oc_platform.beta.html_adder"
								  - "2017-06-01"
								tags:
								  - { name: kernel.event_listener, event: kernel.response,   method: processBeta }
								  - { name: kernel.event_listener, event: kernel.controller, method: ignoreBeta }
				
						Maintenant, passons à cette fameuse méthodeprocessBeta (que l'on avait laissé incomplète dans notre listener).

							Au passage, notez la puissance des tags vus au chapitre précédent !
				
					Création de la méthode à exécuter du listener

						Vous distinguez bien les deux points dont je vous parlais. D'un côté, on a notre serviceBetaHTMLAdder qui réalise la fonction "ajouter une mention beta". Il remplit parfaitement sa fonction. Notez que son rôle n'est pas de décider quand ajouter une mention, il le fait si on le lui dit. De l'autre côté, on a la solution technique pour exécuter la fonction précédente lorsqu'on le veut, c'est notre listenerBetaListener. C'est lui qui est enregistré dans le gestionnaire d'évènements grâce au tag, et c'est lui qui décide quand exé cuter la fonction (c'est son rôle à lui).

							Le mantra à garder en tête : « 1 service = 1 fonction » !
				
						Le listener permet également de passer les bons arguments à notre service BetaHTMLAdder. En effet, lorsque le gestionnaire d'évènements exécute ses listeners, il ne se préoccupe pas de leurs arguments ! Le premier argument qu'il leur donne est un objet Symfony\Component\EventDispatcher\Event, représentant l'évènement en cours.

						Dans notre cas de l'évènementkernel.response, on a le droit à un objetSymfony\Component\HttpKernel\Event\FilterResponseEvent, qui hérite bien évidemment du premier.

							Pas d'inquiétude : je vous dresse plus loin une liste des évènements Symfony ainsi que les types d'argument que le gestionnaire d'évènements transmet. Vous n'avez pas à jouer aux devinettes !
				
						Dans notre cas, l'évènementFilterResponseEventdispose des méthodes suivantes :

							<?php
							class FilterResponseEvent
							{
							  public function getResponse();
							  public function setResponse(Response $response);
							  public function getKernel();
							  public function getRequest();
							  public function getRequestType();
							  public function isPropagationStopped();
							  public function stopPropagation();
							}
				
						Ce sont surtout les méthodesgetResponse()etsetResponsequi vont nous être utiles pour notre BetaListener : elles permettent respectivement de récupérer la réponse et de la modifier, c'est exactement ce que l'on veut !

						On a maintenant toutes les informations nécessaires, il est temps de construire réellement la méthodeprocessBeta de notre listener. Tout d'abord, voici le principe général pour ce type de listener qui vient modifier une partie de l'évènement (ici, la réponse) :

							<?php
							// src/OC/PlatformBundle/Beta/BetaListener.php

							namespace OC\PlatformBundle\Beta;

							use Symfony\Component\HttpFoundation\Response;
							use Symfony\Component\HttpKernel\Event\FilterResponseEvent;

							class BetaListener
							{
							  // L'argument de la méthode est un FilterResponseEvent
							  public function processBeta(FilterResponseEvent $event)
							  {
								// On teste si la requête est bien la requête principale (et non une sous-requête)
								if (!$event->isMasterRequest()) {
								  return;
								}

								// On récupère la réponse que le gestionnaire a insérée dans l'évènement
								$response = $event->getResponse();

								// Ici on modifie comme on veut la réponse…

								// Puis on insère la réponse modifiée dans l'évènement
								$event->setResponse($response);
							  }
							}
							
							Le premierifteste si la requête courante est bien la requête principale. En effet, souvenez-vous, on peut effectuer des sous-requêtes via la fonction{{ render }}de Twig ou alors la méthode$this->forward()d'un contrôleur. Cette condition permet de ne pas réexécuter le code lors d'une sous-requête (on ne va pas mettre des mentions « bêta » sur chaque sous-requête !). Bien entendu, si vous souhaitez que votre comportement s'applique même aux sous-requêtes, ne mettez pas cette condition.
				
							Le gestionnaire d'évènements passe, en plus de l'objet$event, deux autres arguments aux listeners qu'il exécute : le nom de l'évènement courant, ainsi que lui-même (l'objet EventDispatcher). Ce dernier argument permet à un listener qui écoute un évènement A de dire au gestionnaire qu'il souhaite également écouter un autre évènement B. Cela peut être utile dans certains cas, gardez-le en tête.
				
						Adaptons maintenant cette base à notre exemple, il suffit juste de rajouter l'appel à notre service BetaHTMLAdder, voyez par vous-mêmes :

							<?php
							// src/OC/PlatformBundle/Beta/BetaListener.php

							namespace OC\PlatformBundle\Beta;

							use Symfony\Component\HttpKernel\Event\FilterResponseEvent;

							class BetaListener
							{
							  public function processBeta(FilterResponseEvent $event)
							  {
								if (!$event->isMasterRequest()) {
								  return;
								}

								$remainingDays = $this->endDate->diff(new \Datetime())->days;

								// Si la date est dépassée, on ne fait rien
								if ($remainingDays <= 0) {
								  return;
								}

								// On utilise notre BetaHRML
								$response = $this->betaHTML->addBeta($event->getResponse(), $remainingDays);
								
								// On met à jour la réponse avec la nouvelle valeur
								$event->setResponse($response);
							  }
							}
							
							N'oubliez pas de rajouter leuse Symfony\Component\HttpKernel\Event\FilterResponseEvent;en début de fichier.
				
						Voilà, votre listener est maintenant opérationnel ! Actualisez n'importe quelle page de votre site et vous verrez la mention « bêta » apparaître comme sur la figure suivante.

							La mention « bêta » apparaît
				
						Ici la bonne exécution de votre listener est évidente, car on a modifié l'affichage, mais parfois rien n'est moins sûr. Pour vérifier que votre listener est bien exécuté, allez dans l'ongletEventsdu Profiler, vous devez l'apercevoir dans le tableau visible à la figure suivante.

							Notre listener figure dans la liste des listeners exécutés
				
				Méthodologie

					Vous connaissez maintenant la syntaxe pour créer un listener qui va écouter un évènement. Vous avez pu constater que le process est simple, mais précis. Pour résumer, voici la méthode à appliquer lorsque vous souhaitez écouter un évènement :

						Tout d'abord, créez un service qui va remplir la fonction que vous souhaitez. Si vous avez un service déjà existant, cela va très bien.
				
						Ensuite, choisissez bien l'évènement que vous devez écouter. On a pris directement l'évènementkernel.responsepour l'exemple, mais vous devez choisir correctement le vôtre dans la liste que je dresse plus loin.
				
						Puis créez une classe (le future listener) qui contient une méthode qui va faire le lien entre le déclenchement de l'évènement et le code que vous voulez exécuter (le service précédent). Il s'agit de la méthodeprocessBeta que nous avons utilisée.
				
						Enfin, définissez votre classe comme un service (sauf si c'en était déjà un), et ajoutez à la définition du service le bon tag pour que le gestionnaire d'évènements retrouve votre listener.
				
				
			Les évènements Symfony… et les nôtres !
				
				Symfony déclenche déjà quelques évènements dans son processus interne. Mais il sera bien évidemment possible de créer puis déclencher nos propres évènements !

				Les évènements Symfony
	
					L'évènementkernel.request

						Cet évènement est déclenché très tôt dans l'exécution d'une page, avant même que le choix du contrôleur à exécuter ne soit fait. Son objectif est de permettre à un listener de retourner immédiatement une réponse, sans même passer par l'exécution d'un contrôleur donc. Il est également possible de modifier la requête, en y rajoutant de attributs par exemple. Dans le cas où un listener définit une réponse, alors les listeners suivants ne seront pas exécutés ; on reparle de la priorité des listeners plus loin.

						La classe de l'évènement donné en argument par le gestionnaire d'évènements estGetResponseEvent, dont les méthodes sont les suivantes :

							<?php

							class GetResponseEvent
							{
							  public function getResponse();
							  public function setResponse(Response $response);
							  public function hasResponse();
							  public function getKernel();
							  public function getRequest();
							  public function getRequestType();
							  public function isMasterRequest();
							  public function isPropagationStopped();
							  public function stopPropagation();
							}
				
							Savez-vous comment est appelé le Routeur ? Il écoute en réalité cet évènementkernel.request ! C'est comme cela que les composants Router et Kernel de Symfony fonctionnent de façon totalement indépendante ! Le Routeur ne fait qu'écouter un évènement, et s'il trouve une route, il modifie la requête (objetRequest) en lui ajoutant l'attribut_controller. Le Kernel, lui, ne fait que regarder cet attribut_controller pour savoir quel contrôleur appeler, mais il ne sait en réalité pas qui a défini cet attribut.
				
					L'évènementkernel.controller

						Cet évènement est déclenché après que le contrôleur à exécuter ait été défini, mais avant de l'exécuter effectivement. Son objectif est de permettre à un listener de modifier le contrôleur à exécuter.

						Généralement, c'est l'évènement utilisé pour exécuter du code sur chaque page. En effet, l'évènement précédentkernel.request est déclenché avant qu'une route n'ait été trouvée : autrement dit, il est déclenché même lors d'une erreur 404 (page non trouvée).

						La classe de l'évènement donné en argument par le gestionnaire d'évènements estFilterControllerEvent, dont les méthodes sont les suivantes :

							<?php

							class FilterControllerEvent
							{
							  public function getController();
							  public function setController($controller);
							  public function getKernel();
							  public function getRequest();
							  public function getRequestType();
							  public function isMasterRequest();
							  public function isPropagationStopped();
							  public function stopPropagation();
							}
				
						Voici comment utiliser cet évènement depuis un listener pour modifier le contrôleur à exécuter sur la page en cours :

							<?php

							use Symfony\Component\HttpKernel\Event\FilterControllerEvent;

							public function onKernelController(FilterControllerEvent $event)
							{
							  // Vous pouvez récupérer le contrôleur que le noyau avait l'intention d'exécuter
							  $controller = $event->getController();

							  // Ici vous pouvez modifier la variable $controller, etc.
							  // $controller doit être de type PHP callable

							  // Si vous avez modifié le contrôleur, prévenez le noyau qu'il faut exécuter le vôtre :
							  $event->setController($controller);
							}
				
					L'évènementkernel.view

						Cet évènement est déclenché lorsqu'un contrôleur n'a pas retourné d'objetResponse. Son objectif est de permettre à un listener d'attraper le retour du contrôleur (s'il y en a un) pour soit construire une réponse lui-même, soit personnaliser l'erreur levée.

						La classe de l'évènement donné en argument par le gestionnaire d'évènements estGetResponseForControllerResultEvent(rien que ça !), dont les méthodes sont les suivantes :

							<?php

							class GetResponseForControllerResultEvent
							{
							  public function getControllerResult();
							  public function getResponse();
							  public function setResponse(Response $response);
							  public function hasResponse();
							  public function getKernel();
							  public function getRequest();
							  public function getRequestType();
							  public function isMasterRequest();
							  public function isPropagationStopped();
							  public function stopPropagation();
							}
				
						Voici comment utiliser cet évènement depuis un listener pour construire une réponse à partir du retour du contrôleur de la page en cours :

							<?php

							use Symfony\Component\HttpKernel\Event\GetResponseForControllerResultEvent;
							use Symfony\Component\HttpFoundation\Response;

							public function onKernelView(GetResponseForControllerResultEvent $event)
							{
							  // Récupérez le retour du contrôleur (ce qu'il a mis dans son « return »)
							  $val = $event->getControllerResult();

							  // Créez une nouvelle réponse
							  $response = new Response();

							  // Construisez votre réponse comme bon vous semble…

							  // Définissez la réponse dans l'évènement, qui la donnera au noyau qui, finalement, l'affichera
							  $event->setResponse($response);
							}
				
					L'évènementkernel.response

						Cet évènement est déclenché après qu'un contrôleur a retourné un objetResponse; c'est celui que nous avons utilisé dans notre exempleBetaListener. Son objectif, comme vous avez pu vous en rendre compte, est de permettre à un listener de modifier la réponse générée par le contrôleur avant de l'envoyer à l'internaute.

						La classe de l'évènement donné en argument par le gestionnaire d'évènements estFilterResponseEvent, dont les méthodes sont les suivantes :

							<?php

							class FilterResponseEvent
							{
							  public function getControllerResult();
							  public function getResponse();
							  public function setResponse(Response $response);
							  public function hasResponse();
							  public function getKernel();
							  public function getRequest();
							  public function getRequestType();
							  public function isMasterRequest();
							  public function isPropagationStopped();
							  public function stopPropagation();
							}
							
						C'est également cet évènement qui est écouté parWebDebugToolbarListener, le listener (situé dans leWebProfilterBundle ) qui ajoute la toolbar en bas des pages en mode dev.
				
					L'évènementkernel.exception

						Cet évènement est déclenché lorsqu'une exception est levée. Son objectif est de permettre à un listener de modifier la réponse à renvoyer à l'internaute, ou bien de modifier l'exception.

						La classe de l'évènement donné en argument par le gestionnaire d'évènements estGetResponseForExceptionEvent, dont les méthodes sont les suivantes :

							<?php

							class GetResponseForExceptionEvent
							{
							  public function getException();
							  public function setException(\Exception $exception);
							  public function getResponse();
							  public function setResponse(Response $response);
							  public function hasResponse();
							  public function getKernel();
							  public function getRequest();
							  public function getRequestType();
							  public function isMasterRequest();
							  public function isPropagationStopped();
							  public function stopPropagation();
							}
							
					L'évènementsecurity.interactive_login

						Cet évènement est déclenché lorsqu'un utilisateur s'identifie via le formulaire de connexion. Son objectif est de permettre à un listener d'archiver une trace de l'identification, par exemple.

						La classe de l'évènement donné en argument par le gestionnaire d'évènements estSymfony\Component\Security\Http\Event\InteractiveLoginEvent, dont les méthodes sont les suivantes :

							<?php

							class InteractiveLoginEvent
							{
							  public function getAuthenticationToken();
							  public function getRequest();
							  public function isPropagationStopped();
							  public function stopPropagation();
							}
				
					L'évènementsecurity.authentication.success

						Cet évènement est déclenché lorsqu'un utilisateur s'identifie avec succès, quelque soit le moyen utilisé (formulaire de connexion, cookiesremember_me). Son objectif est de permettre à un listener d'archiver une trace de l'identification, par exemple.

						La classe de l'évènement donné en argument par le gestionnaire d'évènements estSymfony\Component\Security\Core\Event\AuthenticationEvent, dont les méthodes sont les suivantes :

							<?php

							class AuthenticationEvent
							{
							  public function getAuthenticationToken();
							  public function getRequest();
							  public function isPropagationStopped();
							  public function stopPropagation();
							}
				
					L'évènementsecurity.authentication.failure

						Cet évènement est déclenché lorsqu'un utilisateur effectue une tentative d'identification échouée, quelque soit le moyen utilisé (formulaire de connexion, cookiesremember_me). Son objectif est de permettre à un listener d'archiver une trace de la mauvaise identification, par exemple.

						La classe de l'évènement donné en argument par le gestionnaire d'évènements estSymfony\Component\Security\Core\Event\AuthenticationFailureEvent, dont les méthodes sont les suivantes :

							<?php

							class AuthenticationFailureEvent
							{
							  public function getAuthenticationException();
							  public function getRequest();
							  public function isPropagationStopped();
							  public function stopPropagation();
							}
				
				Créer nos propres évènements

					Les évènements Symfony couvrent la majeure partie du processus d'exécution d'une page, ou de l'identification d'un utilisateur. Cependant, on aura parfois besoin d'appliquer cette conception par évènement à notre propre code, notre propre logique. Cela permet, au même titre que les composants de Symfony, de bien découpler les différentes fonctions de notre site.

					La logique d'un évènement est la suivante : j'ai une fonctionnalité, par exemple l'ajout de messages (d'une annonce, d'une candidature, etc.) et je souhaite pouvoir l'étendre de façon découplée. Sur l'ajout de message, on pourrait par exemple :

						déléguer l'indexation dans un moteur de recherche (pour ensuite faire des recherches textuelle),
						
						vérifier si le message est un spam (méthode différente de notre contrainte précédente),
						
						ou encore recevoir des notifications à chaque message posté, etc.
				
					Toutes ces extensions autour de la fonctionnalité cœur qu'est l'ajout de message n'ont quasiment rien à voir avec elle, elles doivent donc être 100% découplées et c'est ce qu'offrent les évènements. Dans ce cas, l'évènement serait "Ajout d'un message".

					Pour la suite de l'exemple, nous restons sur cet évènement d'ajout de message, et la fonctionnalité que nous allons lier est un outil de surveillance ces message, qu'on appellera Bigbrother. L'idée est d'avoir un outil qui permette de censurer les messages de certains utilisateurs et/ou de nous envoyer une notification lorsqu'ils postent des messages.

					Pour reproduire le comportement des évènements, il nous faut trois étapes :

						D'abord, définir la liste de nos évènements possibles. Il peut bien entendu y en avoir qu'un seul.
				
						Ensuite, construire la classe de l'évènement. Il faut pour cela définir les informations qui peuvent être échangées entre celui qui émet l'évènement et celui ou ceux qui l'écoute(nt).
				
						Enfin, déclencher l'évènement bien entendu.
				
							Pour l'exemple, je vais placer tous les fichiers de la fonctionnalité BigBrother dans le répertoireBigbrotherdu bundle Platform. Mais en réalité, comme c'est une fonctionnalité qui s'appliquera à plusieurs bundles (la plateforme d'annonces, le forum, et d'autres si vous en avez), il faudrait le mettre dans un bundle séparé. Soit un bundle commun dans votre site, du genreCoreBundlesi vous en avez un, soit carrément dans son bundle à lui, du genreBigbrotherBundle, vu que c'est une fonctionnalité que vous pouvez tout à fait partager avec d'autres sites !
				
					Définir la liste de nos évènements

						Nous allons définir une classe avec juste des constantes qui contiennent le nom de nos évènements. Cette classe est facultative en soi, mais c'est une bonne pratique qui nous évitera d'écrire directement le nom de l'évènement. On utilisera ainsi le nom de la constante, défini à un seul endroit, dans cette classe. J'appelle cette classePlatformEvents, mais c'est totalement arbitraire, voici son code :

							<?php
							// src/OC/PlatformBundle/Event/PlatformEvents.php

							namespace OC\PlatformBundle\Event;

							final class PlatformEvents
							{
							  const POST_MESSAGE = 'oc_platform.post_message';
							  // Vos autres évènements…
							}
				
						Cette classe ne fait donc rien, elle ne sert qu'à faire la correspondance entrePlatformEvents::POST_MESSAGE qu'on utilisera pour déclencher l'évènement et le nom de l'évènement en lui mêmeoc_platform.post_message.

							Pourquoi l'avoir nomméPlatformEventset nonBigbrotherEvents?

							Faites bien la différence entre les évènements déclenchés et les listeners qui écoutent ces évènements. L'évènement ici est juste le fait qu'un message a été posté (dans le cadre d'une annonce, ou d'une candidature), il est donc lié à la plateforme d'annonces de façon générale. La fonctionnalité Bigbrother, qui écoute cet évènement, est totalement découplée ! Comme on en parlait au dessus, il pourrait y avoir une autre fonctionnalité, d’indexation par exemple, qui pourrait écouter le même évènement.
				
					Construire la classe de l'évènement

						La classe de l'évènement, c'est, rappelez-vous, la classe de l'objet que le gestionnaire d'évènements va transmettre aux listeners. En réalité on ne l'a pas encore vu, mais c'est celui qui déclenche l'évènement qui crée une instance de cette classe. Le gestionnaire d'évènements ne fait que la transmettre, il ne la crée pas.

						Voici dans un premier temps le squelette commun à tous les évènements. On va appeler le nôtreMessagePostEvent:

							<?php
							// src/OC/PlatformBundle/Event/MessagePostEvent.php

							namespace OC\PlatformBundle\Event;

							use Symfony\Component\EventDispatcher\Event;

							class MessagePostEvent extends Event
							{
							}
				
						C'est tout simplement une classe vide qui étend la classeEventdu composantEventDispatcher.

							Au même titre que la classe des noms des évènements, la classe de l'évènement en lui-même n'est pas spécifique à notre Bigbrother ou autre, on la place donc dans le namespace général Event.
				
						Ensuite, il faut rajouter la spécificité de notre évènement. On considère que l'évènement porte à la fois sur le contenu du message, et sur son auteur. Tous nos listeners pourront avoir accès à ces informations sur l'évènement. On doit donc rajouter ces deux attributs à l'évènement :

							<?php
							// src/OC/PlatformBundle/Event/MessagePostEvent.php

							namespace OC\PlatformBundle\Event;

							use Symfony\Component\EventDispatcher\Event;
							use Symfony\Component\Security\Core\User\UserInterface;

							class MessagePostEvent extends Event
							{
							  protected $message;
							  protected $user;

							  public function __construct($message, UserInterface $user)
							  {
								$this->message = $message;
								$this->user    = $user;
							  }

							  // Le listener doit avoir accès au message
							  public function getMessage()
							  {
								return $this->message;
							  }

							  // Le listener doit pouvoir modifier le message
							  public function setMessage($message)
							  {
								return $this->message = $message;
							  }

							  // Le listener doit avoir accès à l'utilisateur
							  public function getUser()
							  {
								return $this->user;
							  }

							  // Pas de setUser, les listeners ne peuvent pas modifier l'auteur du message !
							}

						Faites attention aux getters et setters, vous devez les définir soigneusement en fonction de la logique de votre évènement :

							Un getter doit tout le temps être défini sur vos attributs. Car si vos listeners n'ont pas besoin d'un attribut (ce qui justifierait l'absence de getter), alors l'attribut ne sert à rien !
							
							Un setter ne doit être défini que si les listeners peuvent modifier la valeur de l'attribut. Ici c'est le cas du message. Cependant, on interdit au listener de modifier l'auteur du message, cela n'aurait pas de sens.
							
					Déclencher l'évènement

						Déclencher et utiliser un évènement se fait assez naturellement lorsqu'on a bien défini l'évènement et ses attributs. Reprenons le code de l'action du contrôleurAdvertControllerqui permet d'ajouter une annonce. Voici comment on l'adapterait pour déclencher l'évènement avant l'enregistrement effectif de l'annonce :

							<?php
							// src/OC/PlatformBundle/Controller/AdvertController.php

							namespace OC\PlatformBundle\Controller;

							use OC\PlatformBundle\Event\PlatformEvents;
							use OC\PlatformBundle\Event\MessagePostEvent;
							use Symfony\Bundle\FrameworkBundle\Controller\Controller;

							class AdvertController extends Controller
							{
							  public function addAction(Request $request)
							  {
								// …

								if ($form->handleRequest($request)->isValid()) {
								  // On crée l'évènement avec ses 2 arguments
								  $event = new MessagePostEvent($advert->getContent(), $advert->getUser());

								  // On déclenche l'évènement
								  $this->get('event_dispatcher')->dispatch(PlatformEvents::POST_MESSAGE, $event);

								  // On récupère ce qui a été modifié par le ou les listeners, ici le message
								  $advert->setContent($event->getMessage());

								  $em = $this->getDoctrine()->getManager();
								  $em->persist($advert);
								  $em->flush();

								  // …
								}
							  }
							}
				
							Attention j'ai utilisé ici la méthode$advert->getUser() mais on ne l'a pas créée dans le cours. Si vous l'avez, c'est parfait vous pouvez tester le code tel quel. Si vous ne l'avez pas c'est un bon exercice de l'ajouter.
				
						Pour déclencher un évènement à proprement parler, il faut d'abord créer une instance dudit évènement, puis appeler la méthodedispatchde l'EventDispatcher :

							Le premier argument est le nom de l'évènement déclenché, ici la constancePlatformEvents::POST_MESSAGE,
				
							Le deuxième argument est l'instance de l'évènement, ici notre instance$event.
				
						C'est tout pour déclencher un évènement ! Vous n'avez plus qu'à reproduire ce comportement la prochaine fois que vous créerez une action qui permet aux utilisateurs d'ajouter un nouveau message (livre d'or, messagerie interne, etc.).

					Écouter l'évènement

						Comme vous avez pu le voir, on a déclenché l'évènement alors qu'il n'y a pas encore de listener. Cela ne pose pas de problème, bien au contraire : cela va nous permettre par la suite d'ajouter un ou plusieurs listeners qui seront alors exécutés au milieu de notre code. Ça, c'est du découplage !

						Pour aller jusqu'au bout de l'exemple, voici ma proposition pour un listener. C'est juste un exemple, ne le prenez pas pour argent comptant. Voici d'abord le service qui agit :

							<?php
							// src/OC/PlatformBundle/Bigbrother/MessageNotificator.php

							namespace OC\PlatformBundle\Bigbrother;

							use Symfony\Component\Security\Core\User\UserInterface;

							class MessageNotificator
							{
							  protected $mailer;

							  public function __construct(\Swift_Mailer $mailer)
							  {
								$this->mailer = $mailer;
							  }

							  // Méthode pour notifier par e-mail un administrateur
							  public function notifyByEmail($message, UserInterface $user)
							  {
								$message = \Swift_Message::newInstance()
								  ->setSubject("Nouveau message d'un utilisateur surveillé")
								  ->setFrom('admin@votresite.com')
								  ->setTo('admin@votresite.com')
								  ->setBody("L'utilisateur surveillé '".$user->getUsername()."' a posté le message suivant : '".$message."'")
								;

								$this->mailer->send($message);
							  }
							}

						Ainsi que le listener à proprement parler, qui vient exécuter cette fonction seulement lorsque l'auteur du message est dans une liste pré-définie (ici, je la passe en argument du constructeur) :

							<?php
							// src/OC/PlatformBundle/Bigbrother/MessageListener.php

							namespace OC\PlatformBundle\Bigbrother;

							use OC\PlatformBundle\Event\MessagePostEvent;

							class MessageListener
							{
							  protected $notificator;
							  protected $listUsers = array();

							  public function __construct(MessageNotificator $notificator, $listUsers)
							  {
								$this->notificator = $notificator;
								$this->listUsers   = $listUsers;
							  }

							  public function processMessage(MessagePostEvent $event)
							  {
								// On active la surveillance si l'auteur du message est dans la liste
								if (in_array($event->getUser()->getUsername(), $this->listUsers)) {
								  // On envoie un e-mail à l'administrateur
								  $this->notificator->notifyByEmail($event->getMessage(), $event->getUser());
								}
							  }
							}
				
						Et bien sûr, la définition des services correspondants :

							# src/OC/PlatformBundle/Resources/config/services.yml

							services:
							  oc_platform.bigbrother.message_notificator:
								class: OC\PlatformBundle\Bigbrother\MessageNotificator
								arguments:
								  - "@mailer"

							  oc_platform.bigbrother.message_listener:
								class: OC\PlatformBundle\Bigbrother\MessageListener
								arguments:
								  - "@oc_platform.bigbrother.message_notificator"
								  - ["alexandre", "marine", "pierre"]
								tags:
								  - { name: kernel.event_listener, event: oc_platform.post_message, method: processMessage }
				
						J'ai mis ici arbitrairement une liste["alexandre", "marine", "pierre"]pour les noms d'utilisateur à surveiller, mais vous pouvez personnaliser cette liste ou même la rendre dynamique.

							Dans ce MessageListener exemple, je n'ai pas utilisé la possibilité de modifier le contenu du message. Rappelez-vous, dans la classe de l'évènement on a implémenté une méthodesetMessage, qui permet au listener de changer la valeur du message qui sera enregistré. Gardez en tête que c'est possible !
				
			
			Allons un peu plus loin
				
				Le gestionnaire d'évènements est assez simple à utiliser, et vous connaissez en réalité déjà tout ce qu'il faut savoir. Mais je ne pouvais pas vous laisser sans vous parler de trois points supplémentaires, qui peuvent être utiles.

				Étudions donc les souscripteurs d'évènements, qui peuvent se mettre à écouter un évènement de façon dynamique, l'ordre d'exécution des listeners, ainsi que la propagation des évènements.

				Les souscripteurs d'évènements

					Les souscripteurs sont assez semblables aux listeners. La seule différence est la suivante : au lieu d'écouter toujours le même évènement défini dans un fichier de configuration, un souscripteur peut écouter dynamiquement un ou plusieurs évènements.

					Concrètement, c'est l'objet souscripteur lui-même qui va dire au gestionnaire d'évènements les différents évènements qu'il veut écouter. Pour cela, un souscripteur doit implémenter l'interfaceEventSubscriberInterface, qui ne contient qu'une seule méthode :getSubscribedEvents(). Vous l'avez compris, cette méthode doit retourner les évènements que le souscripteur veut écouter.

					Voici par exemple comment on pourrait transformer notreMessageListener en un souscripteur :

						<?php
						// src/OC/PlatformBundle/Bigbrother/CensorshipListener.php

						namespace OC\PlatformBundle\Bigbrother;

						use OC\PlatformBundle\Event\PlatformEvents;
						use Symfony\Component\EventDispatcher\EventSubscriberInterface;

						class MessageListener implements EventSubscriberInterface
						{
						  // La méthode de l'interface que l'on doit implémenter, à définir en static
						  static public function getSubscribedEvents()
						  {
							// On retourne un tableau « nom de l'évènement » => « méthode à exécuter »
							return array(
							  PlatformEvents::POST_MESSAGE    => 'processMessage',
							  PlatformEvents::AUTRE_EVENEMENT => 'autreMethode',
							  // ...
							);
						  }

						  public function processMessage(MessagePostEvent $event)
						  {
							// ...
						  }

						  public function autreMethode()
						  {
							// ...
						  }
						}
				
					Bien sûr, il faut ensuite déclarer ce souscripteur au gestionnaire d'évènements. Pour cela, ce n'est plus le tagkernel.event_listener qu'il faut utiliser, mais :kernel.event_subscriber. Avec ce tag, le gestionnaire d'évènement récupère tous les souscripteurs d'évènements et les enregistre.

					Pas besoin d'ajouter les attributs event et method sur le tag, car c'est la méthodegetSubscribedEvents qui retourne ces informations :

						# src/OC/PlatformBundle/Resources/config/services.yml

						services:
						  oc_platform.bigbrother.message_listener:
							class: OC\PlatformBundle\Bigbrother\MessageListener
							arguments:
							  - "@oc_platform.bigbrother.message_notificator"
							  - ["alexandre", "marine", "pierre"]
							tags:
							  - { name: kernel.event_subscriber }
				
					L'ordre d'exécution des listeners

						On peut définir l'ordre d'exécution des listeners grâce à un indicepriority. Cet ordre aura ainsi une importance lorsqu'on verra comment stopper la propagation d'un évènement.

					La priorité des listeners

						Vous pouvez ajouter un indice de priorité à vos listeners, ce qui permet de personnaliser leur ordre d'exécution sur un même évènement. Plus cet indice de priorité est élevé, plus le listener sera exécuté tôt, c'est-à-dire avant les autres. Par défaut, si vous ne précisez pas la priorité, elle est de 0.

						Vous pouvez la définir très simplement dans le tag de la définition du service. Voici comment la définir à2:

							# src/OC/PlatformBundle/Resources/config/services.yml

							services:
							  oc_platform.beta.listener:
								class: OC\PlatformBundle\Beta\BetaListener
								arguments:
								  - "@oc_platform.beta.html_adder"
								  - "2017-06-01"
								tags:
								  - { name: kernel.event_listener, event: kernel.response, method: processBeta, priority: 2 }
							Et pour les souscripteurs, voici comment adapter la méthodegetSubscribedEvents pour y ajouter l'information de la priorité. Ici j'ai mis une priorité de 2 également :

							<?php
							// Dans un souscripteur :

							  static public function getSubscribedEvents()
							  {
								return array(
								  PlatformEvents::POST_MESSAGE => array('processMessage' => 2)
								);
							  }
				
						Vous pouvez également définir une priorité négative, ce qui aura pour effet d'exécuter votre listener relativement tard dans l'évènement. Je dis bien relativement, car s'il existe un autre listener avec une priorité de -128 alors que le vôtre est à -64, alors c'est lui qui sera exécuté après le vôtre.

				La propagation des évènements

					Si vous avez l'œil bien ouvert, vous avez pu remarquer que tous les évènements qu'on a vus précédemment avaient deux méthodes en commun :stopPropagation()etisPropagationStopped(). Eh bien, vous ne devinerez jamais, mais la première méthode permet à un listener de stopper la propagation de l'évènement en cours !

					La conséquence est donc directe : tous les autres listeners qui écoutaient l'évènement et qui ont une priorité plus faible ne seront pas exécutés. D'où l'importance de l'indice de priorité que nous venons juste de voir !

					Pour visualiser ce comportement, je vous propose de modifier légèrement notreBetaListener. Rajoutez cette ligne à la fin de sa méthodeonKernelResponse:

						<?php
						// src/OC/PlatformBundle/Beta/BetaListener.php

						namespace OC\PlatformBundle\Beta;

						use Symfony\Component\HttpKernel\Event\FilterResponseEvent;

						class BetaListener
						{
						  public function processBeta(FilterResponseEvent $event)
						  {
							// ...
							
							// On stoppe la propagation de l'évènement en cours (ici, kernel.response)
							$event->stopPropagation();
						  }
						}
				
					Actualisez une page. Vous voyez une différence ? La barre d'outils a disparu du bas de la page ! En effet, cette barre est ajoutée avec un listener sur l'évènementkernel.response, exactement comme notre mention « bêta ». Or comme notre listener a une priorité plus élevé, et qu'il a stoppé la propagation de l'évènement, le listener de la barre d'outils n'a pas été exécuté. Pour votre culture, il s'agit deSymfony\Bundle\WebProfilerBundle\EventListener\WebDebugToolbarListener.

						La deuxième méthode,isPropagationStopped(), permet de tester si la propagation a été stoppée dans le listener qui a stoppé l'évènement, ou alors là où l'évènement a été créé (AdvertControllerdans notre cas). Les autres listeners n'étant pas exécutés du tout, il est évidemment inutile de tester la propagation dans leur code (à moins qu'eux-mêmes ne stoppent la propagation bien sûr).
				
				En résumé

					Un évènement correspond à un moment clé dans l'exécution d'une page ou d'une action.
					On parle de déclencher un évènement lorsqu'on signale au gestionnaire d'évènements qu'un certain évènement vient de se produire.
					On dit qu'un listener écoute un évènement lorsqu'on signale au gestionnaire d'évènements qu'il faut exécuter ce listener dès qu'un certain évènement se produit.
					Un listener est une classe qui remplit une fonction, et qui écoute un ou plusieurs évènements pour savoir quand exécuter sa fonction.
					On définit les évènements à écouter via les tags du service listener.
					Il existe plusieurs évènements de base dans Symfony, et il est possible de créer les nôtres.
					Le code du cours tel qu'il doit être à ce stade est disponible sur la branche iteration-18 du dépot Github.
			
		
		6. Traduire son site
		
			Introduction à la traduction

				Le principe

					Si demain on vous demande de traduire un document du français vers une langue étrangère, de quoi auriez-vous besoin ? En plus de votre courage, il vous faut impérativement ces trois informations :

						Ce qu'il faut traduire ;

						La langue dans laquelle traduire ;

						Ainsi qu'un dictionnaire si besoin.

					Ensuite, la méthodologie est plutôt classique : on prend le texte original pour d'abord traduire les mots inconnus, puis on traduit les phrases en respectant la syntaxe de la langue cible.

					En effet, quand nous commençons l'apprentissage d'une langue étrangère, nous cherchons le mot exact dans notre dictionnaire, sans imaginer qu'il s'agisse d'un adjectif accordé ou d'un verbe conjugué. On ne risque donc pas de trouver cette orthographe exacte. Symfony n'ayant pas d'intelligence artificielle, il va reproduire ce comportement systématiquement.

					Ce qu'il en est avec Symfony

						Le service de traduction ne va donc pas s'embarrasser de considérations de syntaxe ou de grammaire ; c'est dû au fait qu'il ne s'agit pas d'un traducteur sémantique. Il n'analyse pas le contenu de la phrase — ni même ne regarde si ce qu'on lui fournit en est une. Il se chargera de traduire une chaîne de caractères d'une langue à l'autre, en la comparant avec un ensemble de possibilités. Notez bien cependant que la casse, tout comme les accents, sont importants. Symfony va vraiment chercher une correspondance exacte de la chaîne à traduire. C'est pourquoi on ne parle pas de dictionnaire, mais de catalogue.

						Si d'un côté c'est plutôt rassurant car il ne peut pas faire d'erreur, l'autre côté implique évidemment que cette responsabilité vous incombe, car c'est vous qui allez écrire le catalogue pour Symfony ! Donc autant vous assurer que vous connaissez bien la langue dans laquelle vous allez traduire.

						La langue source, c'est celle que vous avez déjà utilisée dans vos templates jusqu'à maintenant, donc probablement le français. Comme on l'a vu juste avant, Symfony n'allant chercher que la correspondance exacte, il n'y a pas réellement besoin de la spécifier.

						Quant à la langue cible, elle est en général demandée par l'utilisateur, parfois sciemment (quand il clique sur un lien qui traduit la page sur laquelle il se trouve), parfois implicitement (quand il suit un lien depuis un moteur de recherche, lien qui est dans sa langue), et parfois à son insu (les navigateurs envoient, dans l'en-tête des requêtes, la ou les locale(s) préférée(s) de l'utilisateur ; la locale utilisée sur un site est souvent stockée dans la session, liée à un cookie, qui voyage donc aussi à chaque requête).

							On parle de locale pour désigner non seulement la langue de l'utilisateur, mais aussi d'autres paramètres régionaux, comme le format d'affichage de montants d'argent (et donc la devise), de dates, etc. La locale contient un code de langue ainsi qu'une éventuelle indication du pays. Exemples :frpour le français,fr_CHpour le français de Suisse,zh_Hant_TWpour le chinois traditionnel de Taïwan, etc.
				
						Les locales sont composées de codes de langue, au format ISO639-1, puis éventuellement d'un sous-tiret (_) et du code du pays au format ISO3166-2 Alpha-2.

							Et s'il n'y a pas de traduction dans la locale demandée ?
				
						Symfony possède un mécanisme qui permet d'afficher quelque chose par défaut. Imaginons que vous arriviez sur un site principalement anglophone géré par des Québecois, et ceux-ci, par égard aux Français, sont en train de préparer une version spéciale en « français de France ». Cependant, tout le site n'est pas encore traduit.

						Vous, en tant que visiteur, demandez la traduction pour votre localefr_FRdu texte « site.devise » :

							Ce qui est déjà traduit dans la localefr_FRvous sera retourné ;
							
							Ce qui n'est pas encore traduitenfr_FR, mais existe en « français général » (localefr) : c'est cette version qui sera envoyée ;
							
							Ce qui n'est pas du tout traduit en français, mais l'est en anglais, est affiché en anglais ;
							
							Ce qui ne possède aucune traduction est affiché tel quel, ici « site.devise ». 

							Dans ce cas, quand c'est le texte original qui est affiché, c'est que vous avez oublié la traduction de ce terme.
				
						Ainsi, il n'y aura jamais de vide là où vous avez spécifié du texte à traduire.

				Prérequis

					Avant de partir dans la traduction de son site, il faut vérifier que Symfony travaillera correctement avec les langues, et notamment celle qui est utilisée par défaut. Comme nous sommes sur un site francophone, je vais partir du principe que la langue par défaut de votre site est le français, et la localefr.

					Configuration

						Pour savoir quelle est la langue par défaut sur le site (au cas où il ne serait pas possible d'afficher celle que le client souhaite), Symfony utilise un paramètre appelélocale, comme nous l'avons vu plus haut. La locale pour le français estfr, en minuscules, et il nous faut la définir comme locale par défaut dans le fichierapp/config/config.yml. Ouvrez donc ce fichier et effectuez-y la manipulation mentionnée.

							# app/config/config.yml

							parameters:
								locale: fr # Mettez « fr » ici si ce n'est pas déjà le cas
							
						Si ce paramètre n'est pas renseigné, le framework considérera qu'il travaille en anglais.
						
						On va ensuite utiliser ce paramètrelocaledans la configuration :

							# app/config/config.yml

							framework:
								# On définit la langue par défaut pour le service de traduction
								# Décommenter la ligne, et vérifier qu'elle est bien ainsi
								translator:      { fallbacks: ["%locale%"] }

							# …

								# Vérifier cette ligne aussi, pour la langue par défaut de l'utilisateur
								# C'est celle qui sera utilisée si l'internaute ne demande rien
								default_locale: %locale%
				
						Votre application sait maintenant que vous travaillez sur un site qui, à la base, est en français.

					Mise en place d'une page de test

						Pour la suite du chapitre, nous avons besoin d'une page sur laquelle réaliser nos tests. Je vous invite donc à créer la même que moi, afin qu'on s'y retrouve.

						Tout d'abord voici la route, à rajouter au fichier de routes de l'application. On va la mettre dans lerouting_dev.yml, car d'une part c'est une route de test (pas destinée à nos futurs visiteurs !), et d'autre part le fichier de routes de notre bundle est préfixé par/platform qu'on ne veut pas forcément ici. Voici donc la route en question :

							# app/config/routing_dev.yml

							oc_platform_translation:
							  path:     /traduction/{name}
							  defaults:
								_controller: OCPlatformBundle:Advert:translation
							Pour que la route fonctionne, il nous faut aussi créer l'action qui lui correspond, dans le contrôleur Advert. Une fois de plus, je vous mets le code, rien de bien sorcier :

							<?php
							// src/OC/PlatformBundle/Controller/AdvertController.php

							  public function translationAction($name)
							  {
								return $this->render('OCPlatformBundle:Advert:translation.html.twig', array(
								  'name' => $name
								));
							  }
				
						Et comme indiqué dans le contrôleur, il nous faut la vuetraduction.html.twig, la voici :

							{# src/OC/PlatformBundle/Resources/views/Advert/translation.html.twig #}

							<html>
							  <body>
								Hello {{ name }}!
							  </body>
							</html>
				
						C'est bon, on va pouvoir mettre la main à la pâte !

				Bonjour le monde
				
					Actuellement, quand vous accédez à/traduction/winzou, la page qui s'affiche ne contient que « Hello winzou! », et ce quelle que soit la langue. Nous allons faire en sorte qu'en français nous ayons « Bonjour winzou! », c'est-à-dire que le « Hello » soit traduit en « Bonjour ».

					Dire à Symfony « Traduis-moi cela »

						La traduction est possible dans Symfony à deux endroits : dans les contrôleurs (ou services) et dans la vue. Cette dernière option est la plus conseillée, car c'est dans les vues que se situe l'affichage et donc bien souvent le texte à traduire.

						Le filtre Twig{{ 'string'|trans }}

							Un filtre est, dans le langage Twig, une fonction destinée à formater/modifier une valeur. C'est donc tout à fait adapté à la traduction de texte, car modifier le texte pour qu'il soit dans une autre langue est une transformation comme une autre !

							Plus précisément dans notre cas, c'est le filtretransque l'on va utiliser. La syntaxe est la suivante :{{ 'ma chaîne'|trans }}ou encore{{ ma_variable|trans }}. Ce filtre est prévu pour s'appliquer sur des variables ou des courtes chaînes, voici un exemple dans un contexte :

								<div>
								  <p>{{ message|trans }}</p>
								  <button>{{ 'cancel'|trans }}</button>
								  <button>{{ 'validate'|trans }}</button>
								</div>
				
						La balise de bloc Twig{% trans %}

							Une autre possibilité de traduction depuis la vue consiste à encadrer tous les textes dans des blocs{% trans %} … {% endtrans %}. Ce bloc permet de traduire du texte brut, mais attention il est impossible d'y mettre autre chose que du texte. Balises HTML, code Twig, etc. sont interdits ici. Une des utilisations les plus parlantes est pour les conditions générales d'utilisation d'un site, où il y a de gros paragraphes avec du texte brut, voici un exemple :

								<p>
								  {% trans %}Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur
								  quam nisi, sollicitudin ut rhoncus semper, viverra in augue. Suspendisse
								  potenti. Fusce sit amet eros tortor. Class aptent taciti sociosqu ad litora
								  torquent per conubia nostra, per inceptos himenaeos. Ut arcu justo, tempus sit
								  amet condimentum vel, rhoncus et ipsum. Mauris nec dui nec purus euismod
								  imperdiet. Cum sociis natoque penatibus et magnis dis parturient montes,
								  nascetur ridiculus mus. Mauris ultricies euismod dolor, at hendrerit nulla
								  placerat et. Aenean tincidunt enim quam. Aliquam cursus lobortis odio, et
								  commodo diam pulvinar ut. Nunc a odio lorem, in euismod eros. Donec viverra
								  rutrum ipsum quis consectetur. Etiam cursus aliquam sem eget gravida. Sed id
								  metus nulla. Cras sit amet magna quam, sed consectetur odio. Vestibulum feugiat
								  justo at orci luctus cursus.{% endtrans %}
								</p>
								<p>
								  {% trans %}Vestibulum sollicitudin euismod tellus sed rhoncus. Pellentesque
								  habitant morbi tristique senectus et netus et malesuada fames ac turpis
								  egestas. Duis mattis feugiat varius. Aenean sed rutrum purus. Nam eget libero
								  lorem, ut varius purus. Etiam nec nulla vitae lacus varius fermentum. Mauris
								  hendrerit, enim nec posuere tempus, diam nisi porttitor lacus, at placerat
								  elit nulla in urna. In id nisi sapien.{% endtrans %}
								</p>
								
							D'accord, l'exemple n'est pas vraiment bon, mais cela illustre l'utilisation. On a de gros pavés de texte, et je vous laisse regarder et réfléchir à ce que cela aurait représenté avec la solution précédente du filtre. ;)

						Le servicetranslator

							Parfois, vous devrez malgré tout réaliser quelques traductions depuis un contrôleur ou un service, dans le cas d'inscriptions dans un fichier de log, par exemple. Dans ce cas il faut faire appel au servicetranslator, qui est le service de traduction que la balise et le filtre Twig utilisent en réalité. Son utilisation directe est très aisée, voyez par vous-mêmes :

								<?php
								// Depuis un contrôleur

								// On récupère le service translator
								$translator = $this->get('translator');

								// Pour traduire dans la locale de l'utilisateur :
								$texteTraduit = $translator->trans('Mon message à inscrire dans les logs');
								
					Notre vue

						Bon, et on fait comment, finalement, pour traduire notre « Hello » en « Bonjour » ?
								
						C'est vrai, revenons-en à nos moutons. Adaptons donc le code de notre vue en rajoutant le filtretransde Twig pour qu'il traduise notre « Hello » :

							{# src/OC/PlatformBundle/Resources/views/Advert/translation.html.twig #}

							<html>
							  <body>
								{{ 'Hello'|trans }} {{ name }}!
							  </body>
							</html>
				
						Accédez à nouveau à/traduction/winzouvia l'environnement de développement.

						Eh, mais… c'est encore « Hello » qui s'affiche ! Pourtant on s'est bien mis en français, non ?
				
						C'est exact ! Mais rappelez-vous la méthode pour faire une traduction. Il faut savoir quoi traduire, ça c'est OK, il faut savoir dans quelle langue le traduire, ça c'est OK, la locale de l'utilisateur est automatiquement définie par Symfony. Il nous manque donc… le dictionnaire !

						En effet, on n'a pas encore renseigné Symfony sur comment dire « Hello » en français. Les fichiers qui vont le lui dire s'appellent des catalogues, nous y venons.

				Le catalogue
				
					Vous l'aurez compris, le catalogue est l'endroit où l'on va associer la chaîne à traduire avec sa version en langue étrangère. Si vous avez créé votre bundle grâce à la commandegenerate:bundle, alors Symfony vous a créé automatiquement un catalogue exemple, c'est le fichier enregistré dans le dossierResources/translationsdu bundle, et qui contiendra par la suite les paires de type'Ma chaîne en français' <=> 'My string in English'.

					Les formats de catalogue

						Les exemples sont pour traduire de l'anglais au français, et non l'inverse.
				
						Le format XLIFF

							Symfony recommande le XLIFF, une application du XML. C'est pourquoi, dans les bundles générés avec la ligne de commande, vous trouvez ce fichierResources/translations/messages.fr.xlfqui contient l'exemple suivant que je commente :

								<!-- src/OC/PlatformBundle/Resources/translations/messages.fr.xlf -->

								<?xml version="1.0"?>
								<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2">
								  <file source-language="en" datatype="plaintext" original="file.ext">
									<body>
									  <trans-unit id="1">
										<!-- La chaîne source, à traduire. C'est celle que l'on utilisera :
										{% trans %}Symfony is great{% endtrans %}
										ou
										{{ 'Symfony is great'|trans }}
										ou
										$translator->trans('Symfony is great')) -->
										<source>Symfony is great</source>

										<!-- La chaîne cible, traduction de la chaîne ci-dessus -->
										<target>J'aime Symfony</target>
									  </trans-unit>
									</body>
								  </file>
								</xliff>
				
							L'avantage du XLIFF est qu'il s'agit d'un format officiel, dont vous pouvez faire valider la structure en plus de la syntaxe. De plus, du fait du support natif de XML par PHP, il est facile de le modifier via PHP, donc de créer une interface dans votre site pour modifier les traductions. En revanche, le désavantage du XLIFF est celui du XML de façon générale : c'est très verbeux, c'est-à-dire que pour traduire une seule ligne il nous en faut vingt.

						Le format YAML

							Voici l'équivalent YAML du fichiermessages.fr.xlfprécédent :

								# src/OC/PlatformBundle/Resources/translations/messages.fr.yml

								# La syntaxe est : « la chaîne source: la chaîne cible »
								Symfony is great: J'aime Symfony
				
							Vous allez me dire que vu sa simplicité on se demande pourquoi le XLIFF existe. Disons qu'il existe des outils pour faciliter les traductions de gros catalogues pour le format XLIFF.

							Pour nos exemples dans ce cours, utilisons le format YAML qui est plus lisible et plus concis. Si c'est votre choix également, pensez à supprimer le fichiermessages.fr.xlfafin qu'il n'interfère pas. 

							Attention également lorsque vous avez des deux-points ( « : » ) dans votre chaîne source, vu la syntaxe utilisée dans le fichier YAML vous vous doutez qu'il ne va pas apprécier. Il faut dans ce cas encadrer la chaîne source par des guillemets, comme ceci :

								"Phone number:": Numéro de téléphone :
				
							Notez que vous pouvez ne pas encadrer la chaîne cible avec les guillemets, bien que celle-ci contienne également les deux-points. Cela est dû à la syntaxe du YAML lui-même : la fin de la chaîne cible est le retour à la ligne, donc impossible à confondre avec les deux-points. ;)

						Le format PHP

							Moins utilisé, ce format est néanmoins possible. La syntaxe est celle d'un simple tableau PHP, comme ceci :

								<?php
								// src/OC/PlatformBundle/Resources/translations/messages.fr.php

								return array(
									'Symfony is great' => 'J\'aime Symfony',
								);
				
						La mise en cache du catalogue

							Quelque soit le format que vous choisissez pour vos catalogues, ceux-ci seront mis en cache pour une utilisation plus rapide dans l'environnement de production. En effet, ne l'oubliez pas, si Symfony a la gentillesse de regénérer le cache du catalogue à chaque exécution dans l'environnement de développement, il ne le fait pas en production. Cela signifie que vous devez vider manuellement le cache pour que vos changements s'appliquent en production. Pensez-y avant de chercher des heures pourquoi votre modification n'apparaît pas.

							Vous pouvez choisir le format qui vous convient le mieux, mais dans la suite du cours je vais continuer avec le format YAML, qui possède quelques autres avantages intéressants dont je parle plus loin.

					Notre traduction

						Maintenant qu'on a vu comment s'organisait le catalogue, on va l'adapter à nos besoins. Créez le fichiermessages.fr.ymlnécessaire pour traduire notre « Hello » en français. Vous devriez arriver au résultat suivant sans trop de problèmes :

							# src/OC/PlatformBundle/Resources/translations/messages.fr.yml

							Hello: Bonjour
				
						Pour tester, videz votre cache et rechargez la page/traduction/winzou. Ça marche ! Vous lisez désormais « Bonjour winzou! ». Et si vous changez le paramètre dansapp/config/config.yml pour que la locale par défaut soit à nouveau l'anglais, vous avez à nouveau « Hello winzou! ».

						Chaque fois que vous créez un nouveau fichier de traduction, il vous faut rafraîchir votre cache avec la commandecache:clear, que vous soyez dans l'environnement de production ou de développement. En effet, si le mode dev permet de prendre en compte les modifications du catalogue sans vider le cache, ce n'est pas le cas pour la création d'un fichier de catalogue !
				
						Si vous avez une erreur du type «Input is not proper UTF-8, indicate encoding !», n'oubliez pas de bien encoder tous vos fichiers en UTF-8 sans BOM.
				
						Ajouter un nouveau message à traduire

							On se doute bien que l'on n'aura pas qu'une seule chaîne à traduire sur tout un site. Il va falloir que tout ce qu'on souhaite voir s'afficher dans la langue de l'utilisateur soit renseigné dans le catalogue. Pour chaque nouvelle chaîne, on ajoute une unité de traduction :

								# src/OC/PlatformBundle/Resources/translations/messages.fr.yml

								Hello: Bonjour
								Bye: Au revoir
				
							Ainsi, à chaque fois que vous avez une nouvelle traduction à ajouter, vous ajoutez une ligne.

						Extraire les chaînes sources d'un site existant

							Mais moi j'ai déjà un site tout prêt en français, je dois trouver toutes les chaînes sources et les copier dans le catalogue à la main ? :'(
				
							Justement, non. Vous allez devoir ajouter les balises et/ou filtres Twig de traduction dans vos vues, ça, c'est inévitable. Mais une fois que ce sera fait, les concepteurs de Symfony ont pensé aux personnes dans votre cas, et ont développé un outil permettant d'extraire toutes les chaînes entre balises{% trans %}et celles avec le filtre|trans.

							Cet outil se présente sous forme d'une commande, il s'agit detranslation:update. Sa version complète est la suivante :translation:update [--prefix[="..."]] [--output-format[="..."]] [--dump-messages] [--force] locale bundle. Cette commande va lire toutes les vues du bundle spécifié, et compilera toutes les chaînes sources dans un catalogue. Vous n'aurez plus qu'à définir les chaînes cibles.

							Si cela paraît être la commande miracle, elle ne fonctionne cependant pas pour extraire les chaînes sources des contrôleurs, donc utilisées avec$this->get('translator')->trans(/* ... */), ni sur le contenu des variables traduites avec{{ maVariable|trans }}(car il ne connaît pas la valeur de la variablemaVariable!). Et bien entendu, n'oubliez aucune balise/filtre Twig de traduction !
				
							La commandetranslation:updateest du même genre quedoctrine:schema:update, dans le sens où il vous faut choisir de donner (en plus des deux paramètres obligatoires) soit--dump-messages, soit--forcepour qu'elle fasse réellement quelque chose. Cela permet de vérifier le résultat avant qu'elle n'écrive effectivement dans le catalogue.

								La première option--dump-messagesaffiche tous les messages dans la console, plus ou moins tels qu'ils seront dans un catalogue en YAML (c'est pour cela que c'est le format de sortie par défaut). Elle tient compte des messages déjà traduits, donc pas de souci que votre précédent travail soit écrasé. Cela vous permet aussi de passer d'un format à l'autre si vous aviez commencé le travail en réutilisant le fichiermessages.fr.xlfdu bundle par exemple.
				
								La seconde option--forceeffectue la mise à jour des catalogues, tout en conservant une sauvegarde des versions précédentes.
				
							Par défaut, les extractions sont de typechaîne source: __chaîne source. En effet, Symfony ne peut deviner comment traduire la chaîne source, il la remet donc comme chaîne cible, mais en la préfixant avec__. Avec l'option--prefix="...", vous pouvez changer la partie__ par ce que vous voulez.

							Il est temps de passer à la pratique, exécutons cette commande pour extraire les messages de notre bundle, et regardez ce qu'il en sort :

								C:\wamp\www\Symfony> php bin/console translation:update --force fr OCPlatformBundle
								Translation Messages Extractor and Dumper
								=========================================

								 // Generating "fr" translation files for "OCPlatformBundle"

								 // Parsing templates...
								 // Loading translation files...
								 // Writing files...

								 [OK] Translation files were successfully updated.
				‌
							Comme je vous l'avais mentionné, les nouvelles chaînes cibles sont identiques aux chaînes sources mais avec un préfixe. À l'aide de votre éditeur préféré, cherchez les occurrences de__ (ou du préfixe que vous avez défini vous-mêmes) dans vos catalogues pour les mettre en surbrillance. Vous ciblerez ainsi très rapidement les nouveautés, c'est-à-dire ce que vous devez traduire !

							Enfin, vous noterez que les anciennes chaînes cibles ne sont pas préfixées, car nous les avions déjà traduites !

							Symfony s'occupe automatiquement des éventuels doublons, vous ne devriez normalement plus en avoir après avoir utilisé la commandetranslations:updateavec l'option--force.
				
						Traduire dans une nouvelle langue

							Pour conquérir le monde, ce qui reste notre but à tous, c'est bien de parler anglais, mais il ne faut pas s'arrêter là ! On souhaite maintenant traduire les messages également en allemand. Il faut alors tout simplement créer le catalogue adéquat, mais on peut se simplifier la vie : dupliquez le fichiermessages.fr.ymlet nommez la copiemessages.de.yml. Ensuite, vous n'avez plus qu'à y modifier les chaînes cibles :

								# src/OC/PlatformBundle/Resources/translations/messages.de.yml

								Hello: Guten Tag
				
							Vous pouvez dès à présent tester le bon fonctionnement de l'allemand en changeant le paramètre dansapp/config/config.yml, après avoir vidé votre cache bien entendu (nous avons ajouté un fichier dans le catalogue).

							Je vous conseille vivement de bien préparer — si ce n'est de terminer — les catalogues pour une locale, puis de les dupliquer pour les autres, et non de travailler sur toutes les locales à la fois. Vous éviterez ainsi les casse-têtes de traductions incomplètes (manque de chaînes sources surtout). La traduction est un processus qui doit se faire tout à la fin de la réalisation d'un site.
				
				Récupérer la locale de l'utilisateur
				
					Déterminer la locale

						Jusqu'à présent, pour changer la locale de notre site nous avons modifié à la main le fichier de configuration. Bien entendu, ce n'est pas une solution viable, vous n'allez pas rester derrière votre PC à changer la locale dès qu'un internaute étranger arrive sur votre site !

						La question se pose donc de savoir comment adapter la locale à l'utilisateur qui navigue sur votre site. Souvenez-vous, j'ai précisé un peu plus haut qu'il y avait plusieurs moyens de connaître la locale de l'utilisateur. Je vous les rappelle ici :

							L'utilisateur clique sur un lien qui traduit la page sur laquelle il se trouve ;
							
							L'utilisateur envoie ses préférences dans les en-têtes des requêtes ;
							
							Les paramètres par défaut.
				
						L'ordre correspond à la priorité observée par Symfony.

							La plupart des sites multilingues affichent la locale dans l'URL (exemple :http://www.site.com/fr). La locale ne dépend donc pas de l'utilisateur, mais de l'adresse à laquelle il se trouve.

					Routing et locale

						Vous l'avez peut-être déjà compris, pour que la locale apparaisse dans les URL, il va falloir ajouter un paramètre dans nos URL.

						Le paramètre d'URL

							Nous l'avons vu dans le chapitre sur le routeur : certains paramètres de route bénéficient d'un traitement spécial de la part de Symfony. Et devinez quoi ? Il y en a un prévu pour récupérer la locale ! Il s'agit du paramètre_locale, qui a déjà été mentionné dans le chapitre sur le routeur.

							Mais les paramètres, on doit les traiter dans les contrôleurs, normalement, non ? Donc on va devoir modifier toutes nos actions, en plus des routes ?
				
							Justement non, c'est en cela que le paramètre_locale(et d'autres) sont spéciaux. En effet, Symfony sait quoi faire avec ces paramètres, vous n'avez donc pas à les récupérer dans vos actions — sauf si le traitement diffère sensiblement en fonction de ce paramètre — ni le mettre vous-mêmes en session, ni quoi que ce soit.

								Voici ce que cela donne sur notre route de test :

								# app/config/routing_dev.yml

								oc_platform_translation:
								  path: /{_locale}/traduction/{name}
								  defaults:
									_controller: "OCPlatformBundle:Advert:translation"
									
							Les paramètres de route sont différents des variables que vous pouvez passer en GET. Ainsi, l'URL/traduction/winzou?_locale=urne traduira pas votre page (en ourdou dans le cas présent), car ici_localen'est pas un paramètre de route.
				
							Vous pouvez déjà tester en essayant/fr/traduction/winzouou/de/traduction/winzou, le contenu de la page est bien traduit.

							Attention par contre, si vous allez sur/en/traduction/winzou, vous avez toujours « Bonjour ». En effet, pour l'instant on n'a pas de catalogue pour l'anglais. Alors effectivement le « Hello » inscrit dans la vue est déjà en anglais, mais ça, Symfony ne le sait pas  ! Car on aurait pu mettre n'importe quoi à la place de « Hello », comme on le verra un peu plus loin. Bref, comme il n'y a pas de catalogue correspondant à la langue demandée, Symfony affiche la page dans la langue fallback (langue de repli en français), définie dans le fichier de configurationconfig.yml, qui est dans notre cas le français. ;)

							Mais cela veut dire qu'on va éditer tous nos fichiers de routing et prendre chaque route une à une ?
				
							Non, rassurez-vous ! Il y a au moins un moyen plus rapide de faire cela, qu'on a aussi vu dans le chapitre sur les routes… il s'agit de l'utilisation d'un préfixe ! Voyez par vous-mêmes comment rajouter le paramètre_localesur tout notre plateforme :

								# app/config/routing.yml

								oc_platform:
									resource: "@OCPlatformBundle/Resources/config/routing.yml"
									prefix:   /{_locale}/platform # Ici, on ajoute {_locale} au préfixe !
				
							Vous pouvez désormais demander vos pages en différentes langues selon l'URL : /fr/platform, /en/platform, etc. Bien entendu, pour que ce soit parfaitement opérationnel, vous devez généraliser l'utilisation du filtre ou de la balise Twigtrans, et traduire les textes dans les catalogues correspondants. Pas detrans, pas de traduction !

							Il y a actuellement un problème avec les routes de FOSUserBundle quand on utilise cette solution de préfixer depuisapp/config/routing.yml. La routefos_user_security, quand elle est préfixée, n'est plus liée à l'action. Ainsi, pour les routes de FOSUserBundle, il vaut mieux dupliquer le fichier de routing du bundle dans votre UserBundle et y préfixer les routes qui en ont besoin. Vous n'avez plus qu'à importer le routing de votre UserBundle à la place de celui de FOSUserBundle, et vous n'avez pas besoin de mettre la partie du préfixe/{_locale}à l'importation.
				
							Il manque cependant un garde-fou à notre solution : avec une locale ainsi apparente, un petit malin peut très bien changer à la main la locale dans une URL, et arriver sur un site dans une langue que vous ne pensiez pas être accessible. Veillez donc à limiter les locales disponibles en ajoutant les requirements pour ce paramètre. De fait, le routing final devrait ressembler à cela :

								# app/config/routing.yml

								oc_platform:
								  resource: "@OCPlatformBundle/Resources/config/routing.yml"
								  prefix:   /{_locale}/platform
								  requirements:
									_locale: en|fr # les locales disponibles, séparées par des pipes « | »
				
							Soyons clairs : si vous avez des routes qui contiennent la locale, vous n'avez rien d'autre à faire. Ni manipuler la session, ni l'objetrequest, ni quoi que ce soit d'autre. Symfony s'en charge.
				
					Les paramètres par défaut

						Ces paramètres sont prévus pour éviter que l'internaute ne trouve ni aucun contenu, ni un contenu incompréhensible. Mais ils sont aussi définis pour que Symfony puisse fonctionner. Nous avons vu l'ordre de priorité dans les possibilités de passer la locale au framework. En fait, Symfony ne se base que sur la session, mais la remplit selon cet ordre de priorité. Seulement, il y a toujours un moment où l'internaute arrive pour la toute première fois sur notre site (ou une nouvelle fois après avoir entièrement nettoyé son cache navigateur, ce qui, pour le serveur, revient au même). Du coup, il faut bien des paramètres par défaut.

						Au début de ce chapitre, nous avons vérifié et changé quelques paramètres dansapp/config/config.yml. Reprenons le code de ce fichier un peu plus en détail, afin de mieux comprendre à quoi il sert :

							# app/config/config.yml

							framework:
								# On définit la langue par défaut pour le service de traduction
								# Ce qui n'est pas disponible dans la locale de l'utilisateur
								# sera affiché dans celle spécifiée ici
								translator:      { fallbacks: [%locale%] }

								# …

								# On initialise la locale de requête, celle par défaut pour
								# l'internaute arrivant pour la toute première fois sur votre site
								default_locale: %locale%
				
				Organiser vos catalogues
				
					Quand il y a beaucoup de traductions, les fichiers deviennent vite difficiles à manipuler. Il faut parcourir beaucoup de lignes pour retrouver là où l'on souhaite faire une modification, et c'est contraire au mode de vie des informaticiens qui veut qu'on puisse se retrouver rapidement dans du code ou dans des fichiers. Je vais donc vous proposer des solutions pour organiser vos catalogues.

					Utiliser des mots-clés plutôt que du texte comme chaînes sources

						Voilà une solution intéressante, à vous de choisir de l'adopter pour toutes vos traductions ou juste les chaînes très longues. L'idée est d'utiliser, au lieu du texte dans la langue source, des mots-clés.

						Plutôt qu'un long discours, je vous propose un petit exemple. Prenons une page statique avec pas mal de texte, ce qui implique beaucoup de texte dans le catalogue, par exemple :

							# Dans un catalogue

							Le site où on apprend tout... à partir de zéro !: The website where you learn it all... from scratch!
				
						L'entrée du catalogue est composée de deux longues phrases, ce n'est pas terrible. Et je ne vous parle pas de son utilisation dans les vues :

							{# Dans une vue #}

							{% trans %}Le site où on apprend tout... à partir de zéro !{% endtrans %}
							{# ou #}
							{{ 'Le site où on apprend tout... à partir de zéro !'|trans }}
				
						Passons maintenant à l'utilisation d'un mot-clé, vous allez tout de suite comprendre. Voici d'abord le catalogue :

							# Dans un catalogue

							site.devise: The website where you learn it all... from scratch!
				
						Vous voyez déjà à quel point c'est plus léger !

							Bien entendu, si le catalogue est léger, il n'y a rien de magique : vous devez dans ce cas utiliser deux catalogues. L'un pour l'anglais et l'autre pour le français !
				
							Mais l'avantage se situe surtout dans les vues, où un mot-clé est plus synthétique qu'une longue phrase, utile pour ne pas se perdre au milieu du code HTML de votre vue. Voyez vous-mêmes :

								{# Dans une vue #}

								{% trans %}site.devise{% endtrans %}
								{# ou #}
								{{ 'site.devise'|trans }}
				
							Vous voyez : quelques mots-clés bien choisis pour résumer une phrase, séparés par des points, et vous avez déjà gagné en clarté dans vos vues et catalogues ! Cela est utilisable avec n'importe quel format de catalogue. N'hésitez pas à vous en servir copieusement.

							Un des avantages également est de voir très rapidement une chaîne non traduite : au lieu du joli texte en français, vous aurez un « xxx.yyy » au milieu de votre page. Cela saute mieux aux yeux, et évite les oublis !

							Enfin, un mot sur la création de deux catalogues au lieu d'un seul. C'est en réalité plutôt une bonne chose, car cela permet non seulement de séparer le texte de tout le code HTML, mais cela permet aussi de mutualiser ! En effet, si vous vous servez d'un mot ou d'une phrase de façon récurrente sur votre site (la devise par exemple), celui-ci ne sera stocké qu'à un seul endroit, dans votre catalogue. Vous pourrez alors le modifier à un unique endroit, et les répercussions s'appliqueront partout sur votre site.

					Nicher les traductions

						C'est une possibilité qui découle de l'utilisation des mots-clés.

						Cette possibilité n'est disponible que dans les catalogues au format YAML.
				
						Si vous optez pour l'utilisation des mots-clés, ce que je vous conseille, vous arriverez très certainement à un résultat de ce genre :

							# Dans un catalogue

							advert.edit.title: Édition d'une annonce
							advert.edit.submit_button: Valider
							advert.show.edit_button: Éditer l'annonce
							advert.show.create_button: Créer une nouvelle annonce
				
						Ce qui était très clair avec une seule ligne, le devient déjà moins lorsqu'il y en a quatre, alors imaginez avec plus !

						En bons développeurs avisés, vous avez tout de suite repéré les redondances, et votre envie de les factoriser est grande. Sachez que vous n'êtes pas seuls, les développeurs du YAML ont pensé à tout, voici comment optimiser votre catalogue :

							# Dans un catalogue

							advert:
								edit:
									title:         Édition d'une annonce
									submit_button: Valider
								show:
									edit_button:   Éditer l'annonce
									create_button: Créer une nouvelle annonce
				
						Quand Symfony va lire cette portion de YAML, il va remplacer chaque séquence « deux points − retour à la ligne − indentation » par un simple point, devenant ainsi l'équivalent de ce que vous aviez précédemment. Très pratique !

						Côté utilisation, dans les vues ou avec le servicetranslator, rien ne change. Vous utilisez toujours{{ 'advert.edit.title'|trans }}par exemple.

						Sachez que c'est une fonctionnalité du YAML, et non du service de traduction de Symfony. Vous pouvez voir cette utilisation dans votre fichier de configurationapp/config/config.ymlpar exemple !
				
						Pour en revenir à l'organisation du catalogue avec ces mots-clés, je vous propose de toujours respecter une structure de ce genre :

							oc:                       # Le namespace racine que vous utilisez
								platform:             # Le nom du bundle, sans la partie Bundle
									advert :          # Le nom de l'entité ou de la section
										list: liste   # Les différents messages, pages et/ou actions
										new:  nouveau # Etc.
				
				Permettre le retour à la ligne au milieu des chaînes cibles

					Certains éditeurs ne gèrent pas le retour à la ligne automatique, et du coup, ce ne sont pas les chaînes sources trop longues qui posent problème, mais les chaînes cibles. Le parseur YAML fourni avec Symfony supporte une syntaxe intéressante qui permet d'éviter d'avoir à faire défiler horizontalement le contenu des catalogues.

					Difficile d'expliquer cela sans un exemple, prenons la charte du site OpenClassrooms :

						# Dans un catalogue

						charte:
							titre: Mentions légales
							donnee:
								# Le chevron « > » en début de chaîne indique que la chaîne cible est sur
								# plusieurs lignes, mais les retours à la ligne ne seront pas présents
								# dans le code HTML, car ils seront remplacés par des espaces.
								# L'indentation doit être faite sur tout le paragraphe.
								premier_paragraphe: >
									OpenClassrooms recueille des informations (login, e-mail) lors de
									votre enregistrement en tant que membre du site. Lors de votre
									connexion au site, un fichier "log" stocke les actions effectuées
									par votre ordinateur (via son adresse IP) au serveur.

								# La pipe « | » permet la même chose, mais les retours à la ligne seront
								# présents dans le code HTML, et non remplacés par des espaces.
								# Vous pouvez utiliser nl2br() sur une telle chaîne, cela permet
								# d'avoir le code comme présenté ci-dessous (l'indendation en moins).
								deuxieme_paragraphe: |
									Lorsque que vous vous connectez en tant que membre de OpenClassrooms et
									que vous cochez la case correspondante, un cookie est envoyé à votre
									ordinateur afin qu'il se souvienne de votre login et de votre mot de
									passe. Ceci vous est proposé uniquement afin d'automatiser la
									procédure de connexion, et n'est en aucun cas utilisé par Simple IT à
									d'autres fins.
				
					Avec la pipe et le chevron, vous pouvez donc faire tenir votre catalogue sur 80 caractères de large, ou tout autre nombre qui vous convient.

				Utiliser des listes

					Encore une possibilité du language YAML qui peut s'avérer pratique dans le cas de catalogues !

					Reprenons l'exemple précédent de la charte pour en faire une liste. En effet, on rencontre souvent une série de paragraphes, dont certains seront supprimés, d'autres ajoutés, et il faut pouvoir le faire assez rapidement. Si vous n'utilisez pas de liste, et que vous supprimez la partie 2 sur 3, ou que vous ajoutez un nouveau paragraphe entre deux autres… vous devez soit adapter votre vue, soit renuméroter les parties et paragraphes. Bref, ce n'est clairement pas idéal.

					Heureusement, il y a un moyen d'éviter cela en YAML, et voici comment :

						# Dans un catalogue

						charte:
							titre: Mentions légales
							donnee:
								# les éléments de liste sont précédés d'un tiret en YAML
								- >
									OpenClassrooms recueille des informations (login, e-mail) lors de
									votre enregistrement en tant que membre du site. Lors de votre
									connexion au site, un fichier "log" stocke les actions effectuées
									par votre ordinateur (via son adresse IP) au serveur.
								- |
									Lorsque que vous vous connectez en tant que membre de OpenClassrooms et
									que vous cochez la case correspondante, un cookie est envoyé à votre
									ordinateur afin qu'il se souvienne de votre login et de votre mot de
									passe. Ceci vous est proposé uniquement afin d'automatiser la
									procédure de connexion, et n'est en aucun cas utilisé par Simple IT à
									d'autres fins.
								- Merci de votre attention.
						On va pouvoir utiliser cela dans une bouclefor?
				
					C'est justement l'idée, oui ! On peut utiliser une structure qui va générer une partie de votre page de conditions générales d'utilisation en bouclant sur les valeurs du catalogue, bien vu ! Cela va donner quelque chose comme cela :

						{# Dans une vue #}

						{% for i in 0..2 %}
							<p>{{ ('charte.donnee.' ~ i )|trans }}</p>
						{% endfor %}
				
					La notation0..2est une syntaxe Twig pour générer une séquence linéaire. Le nombre avant les deux points (..) est le début, celui après est la fin.

					Donc quand vous ajoutez un paragraphe, vous l'insérez à la bonne place dans le catalogue, sans vous préoccuper de son numéro. Vous n'avez qu'à incrémenter la fin de la séquence dans lefor. De même si vous supprimez un paragraphe, vous n'avez qu'à décrémenter la limite de la séquence.

					Comme en PHP, les tableaux récupérés depuis le YAML commencent à 0 et non 1.
				
				
				Utiliser les domaines

					Si vous avez commencé à bien remplir votre fichiermessages.fr.yml, vous pouvez vous rendre compte qu'il grossit assez vite. Et surtout, qu'il peut y avoir des conflits entre les noms des chaînes sources si vous ne faites pas assez attention.

					En fait, il est intéressant de regrouper les traductions par domaine. Le domaine par défaut estmessages, c'est pourquoi nous utilisons depuis le début le fichiermessages.XX.XXX. Un domaine correspond donc à un fichier.

					Vous pouvez donc créer autant de fichiers/domaines que vous voulez, la première partie représentant le nom du domaine de traduction que vous devrez utiliser.

					Mais comment définir le domaine à utiliser pour telle ou telle traduction ?
					
					C'est un argument à donner à la balise, au filtre ou à la fonctiontrans, tout simplement :

						Balise :{% trans from 'domaine' %}chaîne{% endtrans %}.
						
						Filtre :{{ 'chaîne'|trans({}, 'domaine') }}.
						
						Service :$translator->trans('chaîne', array(), 'domaine').
						
					C'est pour cette raison qu'il faut utiliser les domaines avec parcimonie. En effet, si vous décidez d'utiliser un domaine différent de celui par défaut (messages), alors il vous faudra le préciser dans chaque utilisation detrans! Attention donc à ne pas créer 50 domaines inutilement, le choix doit avoir un intérêt.

					Domaines et bundles

						Quelle est la différence entre un domaine et son bundle ? Est-ce qu'on peut avoir les mêmes domaines dans des bundles différents ?
				
						Autant de questions qui, je le sais, vous taraudent l'esprit. En fait, c'est plutôt simple : les domaines n'ont rien à voir avec les bundles. Voilà, c'est dit.

						Du coup, cela veut dire que vous pouvez tout à fait avoir un domaine « A » dans un bundle, et ce même domaine « A » dans un autre bundle. Le contenu de ces deux bouts de catalogue vont s'additionner pour former le catalogue complet du domaine « A ». C'est ce que nous faisons déjà avec le domaine « messages » en fait ! Une vue du bundle « A » pourra alors utiliser une traduction définie dans le bundle « B », et inversement, à condition que le domaine soit le même.

						Et si plusieurs fichiers d'un même domaine définissent la même chaîne source, alors c'est le fichier qui est chargé en dernier qui l'emporte (il écrase la valeur définie par les précédents). L'ordre de chargement des fichiers du catalogue est le même que celui de l'instanciation des bundles dans le Kernel. Il faut donc vérifier tout cela dans votre fichierapp/AppKernel.php.

					Un domaine spécial : validators

						Vous avez peut-être essayé de traduire les messages que vous affichez lors d'erreurs à la soumission de formulaires, et avez remarqué que vous ne pouviez pas les traduire comme tout le reste.

						Pourtant, les messages d'erreur fournis par le framework étaient traduits, eux !
				
						Oui, mais c'est parce que Symfony n'utilise pas le domaine « messages » pour traduire les messages d'erreur des formulaires. Le framework est prévu pour travailler avec le domaine « validators » dans ce contexte des messages de d'erreur de formulaires. Il vous suffit alors de placer vos traductions dans ce domaine (dans le fichiervalidators.fr.ymlpar exemple), et ce dans le bundle de votre choix comme nous venons de le voir.

						Nous reviendrons sur ce domaine spécial un peu plus loin.

				
			Traductions dépendantes de variables
				
				La traduction d'un texte n'est pas quelque chose d'automatique. En effet, toutes les langues ne se ressemblent pas, et il peut y avoir des différences qui ont des conséquences importantes sur notre façon de gérer les traductions.

				Prenons deux exemples qui vont vous faire comprendre tout de suite :

					En français, le point d'exclamation est précédé d'un espace, alors qu'en anglais non. Du coup, le «Hello {{ name }}!» que l'on a dans notre vue n'est pas bon, car sa traduction devient «Bonjour {{ name }}! », sans espace avant le point d'exclamation. La traduction n'est pas correcte !
				
					En anglais comme en français, mettre au pluriel un nom ne se limite pas toujours à rajouter un « s » à la fin. Comment faire unifdans notre vue pour prendre cela en compte ?
				
				Le composant de traduction a tout prévu, ne vous inquiétez pas et regardons cela tout de suite. ;)

				Les placeholders

					Pour mettre mon espace devant le point d'exclamation français, est-ce que je dois ajouter dans le catalogue la traduction de «!» en «!» ?
				
					Bien tenté, mais il y a heureusement une meilleure solution !

					La solution apportée par Symfony est relativement simple : on va utiliser un placeholder, sorte de paramètre dans une chaîne cible. Cela va nous permettre de régler ce problème d'espacement. Rajoutez ceci dans vos catalogues français et anglais :

						# src/OC/PlatformBundle/Resources/translations/messages.fr.yml

						hello: Bonjour %name% !
						Et

						# src/OC/PlatformBundle/Resources/translations/messages.en.yml

						hello: Hello %name%!
				
					Nous avons mis un placeholder nommé%name%dans chacune des traductions anglaise et française. La valeur de ce placeholder sera spécifiée lors du rendu de la vue, ce qui permet de traduire la phrase complète. Cela évite de découper les traductions avec une partie avant la variable et une partie après la variable, et heureusement lorsque vous avez plusieurs variables dans une même phrase !

					Bien entendu il faut adapter un peu notre vue, voici comment passer la valeur du placeholder de la vue au traducteur :

						{# src/OC/PlatformBundle/Resources/views/Advert/translation.html.twig #}

						{{ 'hello'|trans({'%name%': name}) }}
				
					Le premier paramètre donné ici au filtretransest un tableau, dont les index sont les placeholders avec les caractères%qui le délimitent, et les valeurs, celles par lesquelles le placeholder sera remplacé dans la chaîne cible. Nous venons de dire à Symfony que « quand tu traduis la chaîne source "hello", tu vas remplacer%name%qui se trouve dans la chaîne cible par le contenu de la variablename», qui contient ici le nom de l'utilisateur.

					Un placeholder doit être encadré par des%dans les vues, alors que ce n'est pas réellement nécessaire pour le service. Mais par convention, et pour mieux les voir dans les chaînes cibles lors de l'ajout d'une nouvelle langue par exemple, mieux vaut les utiliser partout.
				
					Du coup, ces caractères%doivent être présents dans l'index du tableau des placeholders donné au filtre.
				
					Testez donc l'affichage de cette page en français, puis en anglais. Le point d’exclamation est bien précédé d'un espace en français, mais pas en anglais, et le nom d'utilisateur s'affiche toujours !

					Parce qu'on n'utilise pas toujours le filtre, voici les syntaxes pour toutes les possibilités d'utilisation :

						Balise :{% trans with {'%name%': name} %}hello{% endtrans %}.
						
						Filtre :{{ 'hello'|trans({'%name%': name}) }}.
						
						Service :$translator->trans('hello', array('%name%' => $name)).
				
					Et dans le cas où le paramètre a une valeur fixe dans telle vue, vous pouvez bien évidemment utiliser du texte brut à la place du nom de la variablename, comme ceci :

						{{ 'hello'|trans({'%name%': 'moi-même'}) }}
				
					Les noms qu'on a utilisé,%name%  pour le placeholder et {{ name }}  pour la variable Twig, sont totalement indépendants. Vous auriez pu utilisernom pour l'un etusername pour l'autre par exemple !
				
					Les placeholders dans le domaine validators

						Les messages d'erreur de formulaires, qui sont donc dans le domaine validators, peuvent contenir des nombres, principalement quand on spécifie des contraintes de longueur. Ces nombres, il faut bien les afficher à l'utilisateur. Pour cela, vous allez me dire qu'il faut utiliser les placeholders.

						Raté ! Ce n'est pas du tout comme cela qu'il faut faire dans ce cas. Rassurez-vous, ce n'est que l'exception qui confirme la règle.

						Donc dans le cas des messages d'erreur générés par le composantValidator, et uniquement dans ce cas, il ne faut pas utiliser les placeholders, mais une syntaxe propre à la validation. Cette syntaxe est la même que celle de Twig en fait :{{ limit }}.

						Prenons le cas où vous avez utilisé la contrainteLength, vous avez envie de mentionner le nombre limite de caractères (que ce soit le maximum ou le minimum) et le nombre de caractères entrés par l'utilisateur. Ces valeurs sont fournies par le service de validation, dans les variableslimitetvaluerespectivement. Ce n'est donc pas%limit%qu'il faut utiliser dans votre traduction, mais{{ limit }}, comme ceci :

							# src/OC/PlatformBundle/Resources/translations/validators.fr.yml

							password:
							  length:
								short: "Vous avez entré {{ value }} caractères. Or, le mot de passe ne peut en comporter moins de {{ limit }}"
								long:  "Vous avez entré {{ value }} caractères. Or, le mot de passe ne peut en comporter plus de {{ limit }}"
				
						Notez les guillemets autour des chaînes cibles. Ils sont aussi à mettre obligatoirement — encore un détail qui vaut une séance chez le coiffeur.
				
						La raison de cette exception est que le validateur n'envoie pas les valeurs de ces variables au traducteur, il les garde pour lui et fait la substitution après le retour de la chaîne traduite par le traducteur. Pensez-y !

				Gestion des pluriels

					On va maintenant essayer d'afficher (et y réussir !) le nombre d'annonces correspondant à une catégorie, sous la forme « Il y a (nombre) annonces ». Il peut y en avoir une seule ou plusieurs, et comme on veut faire les choses bien, il faut que cela affiche « Il y a 1 annonce » et « Il y a (plus d'une) annonces », avec le « s » qui apparaît quand le nombre d'annonces dépasse 1.

					Si vous deviez le faire tout de suite, vous feriez sûrement un petit test dans la vue pour choisir quelle chaîne traduire, dans ce style-là :

						{# Dans une vue #}
						{# Attention, ceci est un mauvais exemple, à ne pas utiliser ! #}

						{% if nombre <= 1 %}
						  {{ 'advert.nombre.singulier'|trans({'%count%': nombre}) }}
						{% else %}
						  {{ 'advert.nombre.pluriel'|trans({'%count%': nombre}) }}
						{% endif %}
				
					Avec le catalogue associé :

						# src/OC/PlatformBundle/Resources/translations/messages.fr.yml
						# Attention, ceci est un mauvais exemple, à ne pas utiliser !

						advert:
							nombre:
								singulier: Il y a %count% annonce
								pluriel:   Il y a %count% annonces
				
					Eh bien, votre intention est louable, mais une fois de plus, les concepteurs de Twig et de Symfony ont déjà réfléchi à cela et ont tout prévu ! La nouvelle balise/filtre/fonction à utiliser s'appelletranschoice, et elle s'utilise avec en argument le nombre sur lequel faire la condition, voyez par vous-mêmes :

					Le filtre :

						{{ 'advert.nombre'|transchoice(nombre) }}
					
					La balise :

						{% transchoice nombre %}advert.nombre{% endtranschoice %}
					
					Le service :

						<?php

						$translator->transchoice('advert.nombre', $nombre);
					
					Le catalogue, quant à lui, contient donc les deux syntaxes dans une même chaîne source. Voici la syntaxe particulière à adopter :

						# src/OC/PlatformBundle/Resources/translations/messages.fr.yml

						advert:
							nombre: "[0,1]Il y a %count% annonce|[2,+Inf]Il y a %count% annonces"
				
					Avec cette syntaxe, Symfony pourra savoir que la première partie est pour 0 ou 1 annonce, et la seconde pour 2 ou plus. Je ne m'attarderai pas dessus, la documentation officielle est là si vous voulez absolument plus d'informations.

					Notez que le placeholder%count%est automatiquement remplacé par le paramètre donné à la nouvelle fonctiontranschoicepour qu'elle détermine la chaîne cible à utiliser. Il n'est donc pas nécessaire de passer manuellement le tableau de placeholders comme on a pu le faire précédemment. Par contre, le nom du placeholder est obligatoirement%count%, il vous faut donc l'utiliser dans la chaîne cible.
				
				Afficher des dates au format local

					J'affiche souvent des dates, et j'aimerais avoir les noms des jours/mois, mais comment les traduire ?
				
					Si vous n'avez pas les extensions ICU et intl installées et activées sur votre serveur, la lecture de ce paragraphe ne vous servira à rien.
				
					Vérifiez si votre serveur de production possède ces extensions en accédant auconfig.phpdisponible dans le répertoire/web. Si vous avez une recommandation qui vous parle d'intl, vous devez installer et/ou activer l'extension si vous avez un serveur dédié, et tenter de discuter avec l'hébergeur si vous êtes sur un serveur mutualisé.
				
					Pour afficher les dates sous la forme « vendredi 11 janvier 2016 », vous avez sûrement déjà utilisé le code{{ date|date('l j F Y') }}. Malheureusement, l'objetDatede PHP n'est pas très bon en langues… et quelque soit votre locale, les noms de jours et de mois sont en anglais. D'ailleurs, ils le sont même sur la page de la documentation en français.

					Je vous rassure tout de suite : il est bien possible de traduire ces dates ! Dans nos vues Twig, il va falloir pour cela utiliser le filtrelocalizeddateà la place de justedate. Son utilisation est la suivante :

						{{ date|localizeddate(dateFormat, timeFormat, locale) }}
				
					Les paramètres qu'on lui passe sont les suivants :

						dateFormat: le format pour la date ;
						
						timeFormat: le format pour l'heure ;
						
						locale: la locale dans laquelle afficher la date formatée. Pas besoin de la spécifier, elle est fournie dans le contexte.
				
					Mais pourquoi séparer les formats de date et d'heure ?
				
					Voilà, c'était trop beau pour être vrai, on ne peut pas utiliser la syntaxe habituelle pour le format de date/heure (du moins, pas encore). À la place, on a le choix entre quatre formats :full,long,mediumetshort, pour l'heure comme pour la date, correspondant aux affichages donnés dans le tableau suivant. Il n'est pas possible de les modifier, mais il est en revanche possible de les combiner (donc avoir la datelonget l'heureshort, par exemple). À défaut de pouvoir faire exactement comme vous voulez, vous avez au moins les mois et les jours traduits correctement, et dans un format tout de même convenable. ;)

						Format
							Date
								Heure
						
						full
							jeudi 15 novembre 2016
								14:22:15 Heure normale de l’Europe centrale
						
						long
							15 novembre 2016
								14:22:15 HNEC
						
						medium
							15 nov. 2016
								14:22:15
						
						short
							15/11/16
								14:22
						
						none
							(rien)
								(rien)
				
					Notez que si la locale est simplementfr, une virgule s'ajoute après le nom du jour (donnant « jeudi, 15 novembre 2012 ») ainsi qu'un « h » après la chaîne « H:m:s » (« 14:22:15 h Heure normale de l’Europe centrale ») pour le formatfull, et la date au formatshortaura pour séparateurs des points au lieu de slashes. On n'utilise que très rarement les formatsfulletlongpour l'heure. 
				
					J'ai précisé ici en dur la locale, mais dans votre code ne la mettez pas : elle est automatiquement définie à la locale courante. Votre utilisation sera ainsi aisée :

						Aujourd'hui nous sommes le {{ 'now'|localizeddate('full', 'none') }} et il est {{ 'now'|localizeddate('none', 'short') }}
				
					Et si vous l'exécutez en même temps que j'écris ces lignes (ce qui me paraît impossible…), vous obtiendrez :

					Citation : Résultat

						Aujourd'hui nous sommes le lundi 14 janvier 2016 et il est 20:02

					Attention, si vous rencontrez l'erreur suivante : «The filter "localizeddate" does not exist in ...», c'est que vous n'avez pas encore activé l'extension Twig qui fournit ce filtre.

					L'extension ne se trouve pas dans le coeur de Twig, il vous faut donc d'abord ajouter la bibliothèquetwig/extensions dans votrecomposer.json, puis faire uncomposer update :
	
						// composer.json

						"require": {
							// ...
							"twig/extensions": "~1.3"
						},
				
					Puis, il faut activer l'extension, en rajoutant simplement cette définition de service dans votre fichier de configuration, cela fonctionne exactement comme l'extension Twig qu'on a faite il y a quelques chapitres :

						# app/config/config.yml

						# …

						# Activation de l'extension Twig intl
						services:
						  twig.extension.intl:
							class: Twig_Extensions_Extension_Intl
							tags:
							  - { name: twig.extension }
				
					Pour information, les autres extensions Twig peuvent se trouver à l'adresse suivante : http://twig.sensiolabs.org/doc/extensions/index.html.
				
				Pour conclure

					Voici pour terminer un petit récapitulatif des différentes syntaxes complètes, sachant que la plupart des arguments sont facultatifs.

					Les balises :

						{# Texte simple #}
						{% trans with {'%placeholder%': placeholderValue} from 'domaine' into locale %}maChaîne{% endtrans %}

						{# Texte avec gestion de pluriels #}
						{% transchoice count with {'%placeholder%': placeholderValue} from 'domaine' into locale %}maChaîne{% endtranschoice %}
					
					Les filtres :

						{# Texte simple #}
						{{ 'maChaîne'|trans({'%placeholder%': placeholderValue}, 'domaine', locale) }}

						{# Texte avec gestion de pluriels #}
						{{ 'maChaîne'|transchoice (count,  {'%placeholder%': placeholderValue}, 'domaine', locale) }}
					
					Les méthodes du service :

						<?php
						$translator = $this->get('translator'); // depuis un contrôleur

						// Texte simple
						$translator->trans('maChaîne',  array('%placeholder%' => $placeholderValue) , 'domaine', $locale);

						// Texte avec gestion de pluriels
						$translator->transchoice($count, 'maChaîne',  array('%placeholder%' => $placeholderValue) , 'domaine', $locale)
					
					Vous savez maintenant comment créer les traductions dans les différentes langues que vous souhaitez gérer sur votre site !

					En résumé

						La méthodologie d'une traduction est la suivante :
							
							Détermination du texte à traduire : cela se fait grâce à la balise et au filtre Twig, ou directement grâce au service translator ;
							
							Détermination de la langue cible : cela s'obtient avec la locale, que Symfony définit soit à partir de l'URL, soit à partir des préférences de l'internaute.
						
						Traduction à l'aide d'un dictionnaire : cela correspond aux catalogues dans Symfony ;
						
						Il existe plusieurs formats possibles pour les catalogues, le YAML étant le plus simple ;
						
						Il existe différentes méthodes pour bien organiser ses catalogues, pensez-y !
						
						Il est possible de faire varier les traductions en fonction de paramètres et/ou de pluriels.
						
						Le code du cours tel qu'il doit être à ce stade est disponible sur la branche iteration-19 du dépot Github.
						
						Si vous avez des doutes sur votre code, vous pouvez aussi utiliser SensioLabsInsight, l'outil d'analyse de code de SensioLabs !
							
		
		 Quiz : Quiz 4
		
			
			
		
	 
	Partie 5 - Préparer la mise en ligne
	
		https://openclassrooms.com/courses/developpez-votre-site-web-avec-le-framework-symfony/convertir-les-parametres-de-requetes
		
		
		1. Convertir les paramètres de requêtes
		
			Théorie : pourquoi un ParamConverter ?
			
				Récupérer des entités Doctrine avant même le contrôleur

					Sur la page d'affichage d'une annonce par exemple, n'êtes-vous pas fatigués de toujours devoir vérifier l'existence de l'annonce demandée, et de l'instancier vous-mêmes ? N'avez-vous pas l'impression d'écrire toujours et encore les mêmes lignes ?

						<?php
						// src/OC/PlatformBundle/Controller/AdvertController.php

						// …

						public function viewAction($id)
						{
						  $em = $this->getDoctrine()->getManager();

						  $advert = $em->getRepository('OCPlatformBundle:Advert')->find($id);

						  if (null === $advert) {
							throw new NotFoundHttpException("L'annonce d'id ".$id." n'existe pas.");
						  }

						  // Ici seulement votre vrai code…

						  return $this->render('OCPlatformBundle:Advert:view.html.twig', array(
							  'advert' => $advert
						  ));
						}
			
					Pour enfin vous concentrer sur votre code métier, Symfony a évidemment tout prévu !

				Les ParamConverters

					Vous pouvez créer ou utiliser des ParamConverters qui vont agir juste avant l'appel du contrôleur. Comme son nom l'indique, un ParamConverter convertit les paramètres de votre route au format que vous préférez. En effet, depuis la route, vous ne pouvez pas tellement agir sur vos paramètres. Tout au plus, vous pouvez leur imposer des contraintes via des expressions régulières. Les ParamConverters pallient cette limitation en agissant après le routeur, mais avant le contrôleur, pour venir transformer à souhait ces paramètres.

					Le résultat des ParamConverters est stocké dans les attributs de requête, c'est-à-dire qu'on peut les injecter dans les arguments de l'action du contrôleur.

				Un ParamConverter utile : DoctrineParamConverter

					Vous l'aurez deviné, ce ParamConverter va nous convertir nos paramètres directement en entités Doctrine ! L'idée est la suivante : dans le contrôleur, au lieu de récupérer le paramètre de route {id} sous forme de variable $id, on va récupérer directement une entité Advert sous la forme d'une variable $advert, qui correspond à l'annonce portant l'id $id.

					Et un bonus en prime : on veut également que, s'il n'existe pas d'annonce portant l'id $id dans la base de données, alors une exception 404 soit levée. Après tout, c'est comme si l'on mettait dans la route : requirements: Advert exists !

				Un peu de théorie sur les ParamConverters

					Comment fonctionne un ParamConverter ?
			
				Un ParamConverter est en réalité un simple listener, qui écoute l'évènement kernel.controller.

					On l'a vu dans le chapitre sur les évènements, cet évènement est déclenché lorsque le noyau de Symfony sait quel contrôleur exécuter (après le routeur, donc), mais avant d'exécuter effectivement le contrôleur. Lors de cet évènement, les listeners ont la possibilité de modifier la Request. Ainsi, le ParamConverter va lire la signature de la méthode du contrôleur pour déterminer le type de variable que vous voulez. Cela lui permet de créer un attribut de requête du même type, à partir du paramètre de la route, que vous récupérez ensuite dans votre contrôleur.

					Pour déterminer le type de variable que vous voulez, le ParamConverter a deux solutions. La première consiste à regarder la signature de la méthode du contrôleur, c'est-à-dire le typage que vous définissez pour les arguments :

						<?php
						public function testAction(Advert $advert)
			
					Ici, le typage est Advert, devant le nom de la variable. Le ParamConverter sait alors qu'il doit créer une entité de classe Advert.

					La deuxième solution consiste à utiliser une annotation @ParamConverter, ce qui nous permet de définir nous-mêmes les informations dont il a besoin, cela permet plus de flexibilité.

					Au final, depuis votre contrôleur, vous avez en plus du paramètre original de la route ($id) un nouveau paramètre ($advert) créé par votre ParamConverter qui s'est exécuté avant votre contrôleur. Et bien entendu, il sera possible de créer vos propres ParamConverters ! ;)


			Pratique : utilisation des ParamConverters existants
			
				Utiliser le ParamConverter Doctrine

					Ce ParamConverter fait partie du bundle Sensio\FrameworkBundle. C'est un bundle activé par défaut avec la distribution standard de Symfony, que vous utilisez si vous suivez ce cours depuis le début.

					Vous pouvez donc vous servir du DoctrineParamConverter. Il existe plusieurs façon de l'utiliser, avec ou sans expliciter l'annotation. Voyons ensemble les différentes méthodes.

					1. S'appuyer sur l'id et le typage de l'argument

						C'est la méthode la plus simple, et peut-être la plus utilisée. Reprenons notre route pour afficher une vue :

							# src/OC/PlatformBundle/Resources/config/routing.yml

							oc_platform_view:
							  path:      /advert/{id}
							  defaults:
								_controller: OCPlatformBundle:Advert:view
							  requirements:
								id: \d+
			
						Une route somme toute classique, dans laquelle figure un paramètre {id}. On a mis une contrainte pour que cet id soit un nombre, très bien. Le seul point important est que le paramètre s'appelle « id », ce qui est aussi le nom d'un attribut de l'entité Advert.

						Maintenant, la seule chose à changer pour utiliser le DoctrineParamConverter est côté contrôleur, où il faut typer un argument de la méthode, comme ceci :

							<?php
							// src/OC/PlatformBundle/Controller/AdvertController.php

							namespace OC\PlatformBundle\Controller;

							use OC\PlatformBundle\Entity\Advert;
							use Symfony\Bundle\FrameworkBundle\Controller\Controller;

							class AdvertController extends Controller
							{
							  public function viewAction(Advert $advert, $id)
							  {
								// Ici, $advert est une instance de l'entité Advert, portant l'id $id
							  }
							}
			
						Faites le test ! Vous verrez que $advert est une entité pleinement opérationnelle. Vous pouvez l'afficher, créer un formulaire avec, etc. Bref, vous venez d'économiser le $em->find() nécessaire pour récupérer manuellement l'entité, ainsi que le if (null !== $advert) pour vérifier qu'elle existe bien !

						De plus, si vous mettez dans l'URL un id qui n'existe pas, alors le DoctrineParamConverter vous lèvera une exception, résultant en une page d'erreur 404 comme dans la figure suivante.

							J'ai tenté d'afficher une annonce qui n'existe pas, voici la page d'erreur 404
			
						Ici, j'ai laissé l'argument $id dans la définition de la méthode, mais vous pouvez tout à fait l'enlever. Vu qu'on a l'annonce dans la variable $advert, $id n'est plus utile, on peut (et on doit) utiliser $advert->getId(). C'était juste pour vous montrer que le ParamConverter crée un attribut de requête, sans toucher à ceux existants.
			
						Quand je parle d'attributs de requête, ce sont les attributs que vous pouvez récupérer de cette manière : $request->attributes->get('article'). Ce sont ces attributs que vous pouvez injecter dans le contrôleur en tant qu'arguments de la méthode (dans l'exemple précédent, il s'agit de $id et $advert). Mais ce n'est en rien obligatoire, si vous ne les injectez pas, ils seront tout de même attributs de la requête.
			
						Avec cette méthode, la seule information que le ParamConverter utilise est le typage de l'argument de la méthode, et non le nom de l'argument. Par exemple, vous pourriez tout à fait avoir ceci :

							<?php
							public function viewAction(Advert $bidule)
			
						Cela ne change en rien le comportement, et la variable $bidule contiendra une instance de l'entité Advert.

						Une dernière note sur cette méthode. Ici cela a fonctionné car le paramètre de la route s'appelle « id », et que l'entité Advert a un attribut id. En fait, cela fonctionne avec tous les attributs de l'entité Advert ! Appelez votre paramètre de route slug, et accédez à une URL de type /platform/advert/slug-existant, cela fonctionne exactement de la même manière ! Cependant, pour l'utilisation d'autres attributs que l'id, je vous conseille d'utiliser les méthodes suivantes.

					2. Utiliser l'annotation pour faire correspondre la route et l'entité

						Il s'agit maintenant d'utiliser explicitement l'annotation de DoctrineParamConverter, afin de personnaliser au mieux le comportement. Considérons maintenant que vous avez la route suivante :

							# src/OC/PlatformBundle/Resources/config/routing.yml

							oc_platform_view:
							  path: /advert/{advert_id}
							  defaults:
								_controller: OCPlatformBundle:Advert:view
							  requirements:
								advert_id: \d+
			
						La seule différence est que le paramètre de la route s'appelle maintenant « advert_id ». On aurait pu tout aussi bien l'appeler « bidule », l'important est que ce soit un nom qui n'est pas également un attribut de l'entité Advert. Le ParamConverter ne peut alors pas faire la correspondance automatiquement, il faut donc le lui dire.

						Cela ne nous fait pas peur ! Voici l'annotation à utiliser :

							<?php
							// src/OC/PlatformBundle/Controller/AdvertController.php

							use Sensio\Bundle\FrameworkExtraBundle\Configuration\ParamConverter;

							/**
							 * @ParamConverter("advert", options={"mapping": {"advert_id": "id"}})
							 */
							public function viewAction(Advert $advert)
			
						Il s'agit maintenant d'être un peu plus rigoureux. Dans l'annotation @ParamConverter, voici ce qu'il faut renseigner :

							Le premier argument de l'annotation correspond au nom de l'argument de la variable que l'on veut injecter. Le advert de l'annotation correspond donc au $advert de la méthode.
							
							Le deuxième argument correspond aux options à passer au ParamConverter. Ici, nous avons passé une seule option mapping. Cette option fait la correspondance « paramètre de route » => « attribut de l'entité ». Dans notre exemple, c'est ce qui permet de dire au ParamConverter : « le paramètre de route advert_id correspond à l'attribut id de l'Advert ».
			
						Le ParamConverter connaît le type d'entité à récupérer (Advert, Category, etc.) en lisant, comme précédemment, le typage de l'argument.

						Bien entendu, il est également possible de récupérer une entité grâce à plusieurs attributs. Prenons notre entité AdvertSkill par exemple, qui est identifiée par deux attributs : advert et skill. Il suffit pour cela de passer les deux attributs dans l'option mapping de l'annotation, comme suit :

							<?php
							// src/OC/PlatformBundle/Controller/AdvertController.php

							use Sensio\Bundle\FrameworkExtraBundle\Configuration\ParamConverter;

							// La route serait par exemple :
							// /platform/advert/{advert_id}/{skill_id}

							/**
							 * @ParamConverter("advertSkill", options={"mapping": {"advert_id": "advert", "skill_id": "skill"}})
							 */
							public function viewAction(AdvertSkill $advertSkill)
			
					3. Utiliser les annotations sur plusieurs arguments

						Grâce à l'annotation, il est alors possible d'appliquer plusieurs ParamConverters à plusieurs arguments. Prenez la route suivante :

							# src/OC/PlatformBundle/Resources/config/routing.yml

							oc_platform_view:
							  path: /advert/{advert_id}/applications/{application_id}
							  defaults:
								_controller: OCPlatformBundle:Advert:view
			
						L'idée ici est d'avoir deux paramètres dans la route, qui vont nous permettre de récupérer deux entités différentes grâce au ParamConverter.

						Avec deux paramètres à convertir il vaut mieux tout expliciter grâce aux annotations, plutôt que de reposer sur une devinette. La mise en application est très simple, il suffit de définir deux annotations, chacune comme on l'a déjà vu. Voici comment le faire :

							<?php
							/**
							 * @ParamConverter("advert",      options={"mapping": {"advert_id": "id"})
							 * @ParamConverter("application", options={"mapping": {"application_id": "id"})
							 */
							public function viewAction(Advert $advert, Application $application)
			
				Utiliser le ParamConverter Datetime

					Ce ParamConverter est plus simple : il se contente de convertir une date d'un format défini en un objet de type Datetime. Très pratique !

					Partons donc de cette route par exemple :

						# src/OC/PlatformBundle/Resources/config/routing.yml

						oc_platform_list:
						  path: /list/{date}
						  defaults:
							_controller: OCPlatformBundle:Advert:viewList
			
					Et voici comment utiliser le convertisseur sur la méthode du contrôleur :

						<?php
						// src/OC/PlatformBundle/Controller/AdvertController.php

						use Sensio\Bundle\FrameworkExtraBundle\Configuration\ParamConverter;

						/**
						 * @ParamConverter("date", options={"format": "Y-m-d"})
						 */
						public function viewListAction(\Datetime $date)
			
					Ainsi, au lieu de simplement recevoir l'argument $date qui vaut la chaîne de caractères « 2014-09-20 » par exemple, vous récupérez directement un objet Datetime à cette date, vraiment sympa.

					Attention, ce ParamConverter fonctionne différemment de celui de Doctrine. En l'occurrence, il ne crée pas un nouvel attribut de requête, mais remplace l'existant. La conséquence est que le nom de l'argument (ici, $date) doit correspondre au nom du paramètre dans la route (ici, {date}).
			
			
			Aller plus loin : créer ses propres ParamConverters
			
				Comment sont exécutés les ParamConverters ?

					Avant de pouvoir créer notre ParamConverter, étudions comment ils sont réellement exécutés.

					À l'origine de tout, il y a un listener, il s'agit de Sensio\Bundle\FrameworkExtraBundle\EventListener\ParamConverterListener. Ce listener écoute l'évènement kernel.controller, ce qui lui permet de connaître le contrôleur qui va être exécuté. L'idée est qu'il parcourt les différents ParamConverters pour exécuter celui qui convient le premier. On peut synthétiser son comportement par le code suivant :

						<?php

						foreach ($converters as $converter) {
						  if ($converter->supports($configuration)) {
							if ($converter->apply($request, $configuration)) {
							  return;
							}
						  }
						}
			
					Vous n'avez pas à écrire ce code, je vous le donne uniquement pour que vous compreniez le mécanisme interne !
			
					Dans ce code :

						La variable $converters contient la liste de tous les ParamConverters, nous voyons plus loin comment elle est construite ;
						
						La méthode $converter->supports() demande au ParamConverter si le paramètre actuel l'intéresse ;
						
						La variable $configuration contient les informations de l'annotation : le typage de l'argument, les options de l'annotation, etc. ;
						
						La méthode $converter->apply() permet d'exécuter à proprement parler le ParamConverter.
			
					L'ordre des convertisseurs est donc très important, car si le premier retourne true lors de l'exécution de sa méthode apply(), alors les éventuels autres ne seront pas exécutés.

				Comment Symfony trouve tous les convertisseurs ?

					Pour connaître tous les convertisseurs, Symfony utilise un mécanisme que nous avons déjà utilisé : les tags des services. Vous l'aurez compris, un convertisseur est avant tout un service, sur lequel on a appliqué le tag request.param_converter.

					Commençons donc par créer la définition d'un service, que nous allons implémenter en tant que ParamConverter :

						# src/OC/PlatformBundle/Resources/config/services.yml

						services:
						  oc_platform.paramconverter.json:
							class: OC\PlatformBundle\ParamConverter\JsonParamConverter
							tags:
							  - { name: request.param_converter }
			
					On a ajouté le tag request.param_converter sur notre service, ce qui permet de l'enregistrer en tant que tel. Je n'ai pas mis de priorité, mais vous pouvez en préciser une grâce à l'attribut priority dans le tag.

				Créer un convertisseur

					Créons maintenant la classe du ParamConverter. Un convertisseur doit implémenter l'interface ParamConverterInterface. Commençons par créer la classe d'un convertisseur JsonParamConverter sur ce squelette, que je place dans le répertoire ParamConverter du bundle :

						<?php
						// src/OC/PlatformBundle/ParamConverter/JsonParamConverter.php

						namespace OC\PlatformBundle\ParamConverter;

						use Sensio\Bundle\FrameworkExtraBundle\Configuration\ParamConverter;
						use Sensio\Bundle\FrameworkExtraBundle\Request\ParamConverter\ParamConverterInterface;
						use Symfony\Component\HttpFoundation\Request;

						class JsonParamConverter implements ParamConverterInterface
						{
						  function supports(ParamConverter $configuration)
						  {
						  }

						  function apply(Request $request, ParamConverter $configuration)
						  {
						  }
						}
			
					L'interface ne définit que deux méthodes : supports() et apply().

					La méthode supports()

						La méthode supports() doit retourner true lorsque le convertisseur souhaite convertir le paramètre en question, false sinon. Les informations sur le paramètre courant sont stockées dans l'argument $configuration, et contiennent :

							$configuration->getClass() : le typage de l'argument dans la méthode du contrôleur ;
							
							$configuration->getName() : le nom de l'argument dans la méthode du contrôleur ;
							
							$configuration->getOptions() : les options de l'annotation, si elles sont explicitées (vide bien sûr lorsqu'il n'y a pas l'annotation).
			
						Vous devez, avec ces trois éléments, décider si oui ou non le convertisseur compte convertir le paramètre.

					La méthode apply()

						La méthode apply() doit effectivement créer un attribut de requête, qui sera injecté dans l'argument de la méthode du contrôleur.

						Ce travail peut être effectué grâce à ses deux arguments :

							La configuration, qui contient les informations sur l'argument de la méthode du contrôleur, que nous avons vu juste au-dessus ;
			
							La requête, qui contient tout ce que vous savez, et notamment les paramètres de la route courante via $request->attributs->get('paramètre_de_route').
			
				L'exemple de notre JsonParamConverter

					Histoire de bien comprendre ce que chaque méthode et chaque variable doit faire, je vous propose un petit exemple. Imaginons que, d'une façon ou d'une autre, vous avez un paramètre de route qui contient un tableau en JSON, par exemple {"a":1,"b":2,"c":3}. On souhaite simplement transformer cette chaîne de caractères JSON en un tableau PHP, via la fonction json_decode.

					Évitons de convertir tous les paramètres de routes, c'est pourquoi on n'appliquera notre convertisseur que sur les paramètre de route ayant pour nom "json".

					La classe

						Nous avons déjà le squelette du service de notre convertisseur, il ne manque plus que l'implémentation concrète. Voici la mienne :

							<?php
							// src/OC/PlatformBundle/ParamConverter/JsonParamConverter.php

							namespace OC\PlatformBundle\ParamConverter;

							use Sensio\Bundle\FrameworkExtraBundle\Configuration\ParamConverter;
							use Sensio\Bundle\FrameworkExtraBundle\Request\ParamConverter\ParamConverterInterface;
							use Symfony\Component\HttpFoundation\Request;

							class JsonParamConverter implements ParamConverterInterface
							{
							  function supports(ParamConverter $configuration)
							  {
								// Si le nom de l'argument du contrôleur n'est pas "json", on n'applique pas le convertisseur
								if ('json' !== $configuration->getName()) {
								  return false;
								}

								return true;
							  }

							  function apply(Request $request, ParamConverter $configuration)
							  {
								// On récupère la valeur actuelle de l'attribut
								$json = $request->attributes->get('json');

								// On effectue notre action : le décoder
								$json = json_decode($json, true);

								// On met à jour la nouvelle valeur de l'attribut
								$request->attributes->set('json', $json);
							  }
							}
			
					Le contrôleur

						Pour utiliser votre convertisseur flambant neuf, il faut explicitement appliquer le convertisseur via une annotation.

						Pourquoi ? Car le listener, lorsqu'il n'y a pas d'annotation pour un argument de contrôleur, n'applique les ParamConverter que si l'argument est typé. C'était le cas tout à l'heure avec les convertisseurs Doctrine et Datetime, où nous avions typé avec Advert  et Datetime. Mais ici, ce n'est pas le cas, on n'attend pas un objet mais un simple tableau PHP.

						Ce n'est pas grave, ajoutons donc l'annotation nécessaire (simple car pas d'option particulière) :

							<?php
							// src/OC/PlatformBundle/Controller/AdvertController.php

							namespace OC\PlatformBundle\Controller;

							use Symfony\Bundle\FrameworkBundle\Controller\Controller;
							// N'oubliez pas le use pour l'annotation :
							use Sensio\Bundle\FrameworkExtraBundle\Configuration\ParamConverter;

							class AdvertController extends Controller
							{
							  /**
							   * @ParamConverter("json")
							   */
							  public function ParamConverterAction($json)
							  {
								return new Response(print_r($json, true));
							  }
							}
			
						Pas besoin de renseigner d'options dans l'annotation ici, car nous n'avons aucune option particulière à passer au ParamConverter. Mais si vous en aviez, c'est ici qu'il faut le faire donc gardez-le en tête. ;)

						Essayez le ! Créez cette route par exemple :

							# app/config/routing_dev.yml

							oc_platform_paramconverter:
							  path: /test/{json}
							  defaults:
								_controller: "OCPlatformBundle:Advert:ParamConverter"
			
						Et accédez à la page /test/{"a":1,"b":2,"c":3}. Le résultat est l'affichage par le fonction print_r d'un tableau en pur PHP, qui a donc été décodé depuis le JSON initial.

						Bien sûr l'exemple est plutôt simple, ici en une ligne vous convertissez le paramètre de JSON en PHP. Mais laissez libre cours à votre imagination, et vos convertisseurs peuvent être complexes. N'oubliez pas, ils sont avant tout des services, dans lesquels vous pouvez y injecter d'autres services pour faire des actions plus complexe que simplement décoder du JSON.

						Attention, l'exemple est incomplet. Il faudrait une gestion des erreurs, notamment lorsqu'il le paramètre de route n'est pas du JSON valide. Il suffirait pour cela de déclencher une exception BadRequestHttpException par exemple. Je vous invite à vous inspirer de ceux existants : DoctrineParamConverter et DatetimeParamConverter
			
						Un ParamConverter vous permet de créer un attribut de requête, que vous récupérez ensuite en argument de vos méthodes de contrôleur ;
			
						Il existe deux ParamConverters par défaut avec Symfony : Doctrine et Datetime ;
						
						Il est facile de créer ses propres convertisseurs pour accélérer votre développement.
						
						Le code du cours tel qu'il doit être à ce stade est disponible sur la branche iteration-20 du dépot Github.
			
		
		2. Personnaliser les pages d'erreur
		
			Théorie : remplacer les vues d'un bundle
			
				Constater les pages d'erreur

					Les pages d'erreur de Symfony sont affichées lorsque le noyau attrape une exception. Il existe deux pages différentes : celle en mode dev et celle en mode prod.

					Il est possible de personnaliser les deux, mais celle qui nous intéresse le plus ici est la page d'erreur en mode production. En effet, c'est celle qui sera affichée à nos visiteurs ; elle mérite donc toute notre attention.

					Je vous invite donc à vous remémorer ce à quoi elle ressemble. Pour cela, accédez à une URL inexistante viaapp.php, et voyez le résultat à la figure suivante.

						Une page d'erreur pas très séduisante
			
					Comme vous pouvez le constater, ce n'est pas très présentable pour nos futurs visiteurs !

				Localiser les vues concernées

					Avant de chercher à modifier des vues, il faut d'abord bien les identifier. Comme je vous l'ai précisé, les vues de ces pages d'erreur se situent dans le bundle TwigBundle, et plus précisément dans le répertoirevendor\symfony\symfony\src\Symfony\Bundle\TwigBundle\Resources\views\Exception.

					Je vous donne leur localisation pour information, mais n'allez surtout pas modifier directement les fichiers de ce répertoire ! Comme tout ce qui se situe dans le répertoirevendor, ils sont susceptibles d'être écrasés par Composer à la prochaine mise à jour.
			
				Remplacer les vues d'un bundle

					Il est très simple de remplacer les vues d'un bundle quelconque par les nôtres. Il suffit de créer le répertoireapp/Resources/NomDuBundle/views/et d'y placer nos vues à nous ! Et cela est valable quelque soit le bundle.

					Nos vues doivent porter exactement les mêmes noms que celles qu'elles remplacent. Ainsi, si notre bundle utilise une vue située dans :

						…(namespace)/RépertoireDuBundle/Resources/views/Hello/salut.html.twig
			
					alors nous devons créer la vue :

						app/Resources/NomDuBundle/views/Hello/salut.html.twig
			
					Attention,NomDuBundlecorrespond bien au nom du bundle, à savoir au nom du fichier que vous pouvez trouver à sa racine. Par exemple :OCPlatformBundleest le nom du bundle, mais il se trouve dans(src)/OC/PlatformBundle.
			
					La figure suivante présente un schéma pour bien comprendre, appliqué à la vueerror.html.twigdu bundle TwigBundle.

						Syntaxe pour remplacer une vue
			
				Comportement de Twig

					Twig, pour chaque vue qu'on lui demande de retourner, regarde d'abord dans le répertoireapp/Resourcess'il trouve la vue correspondante. S'il ne la trouve pas, il va ensuite voir dans le répertoire du bundle.

					Ainsi, ici pour chaqueTwigBundle:Exception:error.html.twig, Twig ira vérifier dans le répertoireappavant de prendre la vue du bundle TwigBundle.

					Attention, ceci n'est valable que pour les vues, car c'est le comportement de Twig. Cela ne fonctionne pas pareil pour tout ce qui est contrôleur et autres !
			
				Pourquoi il y a tous les formatserror.XXX.twigdans le répertoireException?

					C'est une très bonne question, et si vous les ouvrez vous vous rendrez compte que chaque vue d'erreur est compatible au format de son extension. Cela permet de ne pas générer des erreurs en cascade.

					Je m'explique, imaginons que vous chargiez un fichier JS, généré dynamiquement par l'un de vos contrôleurs (pourquoi pas !). Si ce contrôleur génère une erreur quelconque, et qu'il affiche cette erreur en HTML, alors votre navigateur qui attend du JavaScript sera perdu ! Il va tenter d'exécuter le retour du contrôleur en tant que JavaScript, mais le retour est en réalité du HTML et générera donc pas mal d'erreurs dans votre navigateur.

					C'est pour éviter ce comportement que Symfony fournit plusieurs formats d'erreur. Ainsi, si le format de votre réponse est défini comme du JavaScript, alors Symfony utilisera la vueerror.js.twigqui est, si vous l'ouvrez, compatible JavaScript car en commentaire. Vous remercierez Symfony la prochaine fois que cela vous arrivera !

			Pratique : remplacer les templates Exception de TwigBundle
			
				Créer la nouvelle vue

				Maintenant qu'on sait le faire, il ne reste plus qu'à le faire ! Créez donc le répertoireapp/Resources/TwigBundle/views/Exception. Et au sein de ce répertoire, le bundle utilise la convention suivante pour chaque nom de template :

					Il vérifie d'abord l'existence de la vueerror[code_erreur].html.twig, par exempleerror404.html.twigdans le cas d'une page introuvable (erreur 404) ;
			
					Si ce template n'existe pas, il utilise la vueerror.html.twig, une sorte de page d'erreur générique.
			
				Je vous conseille de créer unerror404.html.twigpour les pages non trouvées, en plus duerror.html.twiggénérique. Cela vous permet d'afficher un petit texte sympa en cas d'erreur 404 pour que l'utilisateur ne soit pas trop perdu.

			Le contenu d'une page d'erreur

				Pour savoir quoi mettre dans ces vues, je vous propose de jeter un œil à celle qui existe déjà,error.html. Vous la trouvez comme indiqué plus haut dans le répertoirevendor\symfony\src\Symfony\Bundle\TwigBundle\Resources\views\Exception, voici son contenu :

					<!DOCTYPE html>
					<html>
					  <head>
						<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
						<title>An Error Occurred: {{ status_text }}</title>
					  </head>
					  <body>
						<h1>Oops! An Error Occurred</h1>
						<h2>The server returned a "{{ status_code }} {{ status_text }}".</h2>

						<div>
						  Something is broken. Please e-mail us at [email] and let us know
						  what you were doing when this error occurred. We will fix it as soon
						  as possible. Sorry for any inconvenience caused.
						</div>
					  </body>
					</html>
			
				Vous pouvez y voir les différentes variables que vous pouvez utiliser :{{ status_text }}et{{ status_code }}. Fort de cela, vous pouvez créer la page d'erreur que vous souhaitez : vous avez toutes les clés.

				Je le rappelle : cette page d'erreur que l'on vient de personnaliser, c'est la page d'erreur générée en mode prod !
				
				Remplacer la page d'erreur du mode dev n'a pas beaucoup d'intérêt : vous seuls la voyez, et elle est déjà très complète. Cependant, si vous souhaitez quand même la modifier, alors cela n'est pas le templateerror.html.twigqu'il faut créer, mais le templateexception.html.twig. Celui-ci se trouve aussi dans le répertoireException.
			
			S'assurer de voir nos modifications

				Lorsque vous effectuez une modifications dans vos templates, il arrive parfois que vous ne les voyiez pas tout de suite au moment de rafraîchir votre page. :'( En effet, les templates twig sont convertis en templates PHP et ceux sont ces derniers qui sont utilisés pour être affiché à l'utilisateur final. En revanche, il faut savoir que ces templates convertis ne sont pas toujours mis à jour à chaque rafraîchissement de page (surtout en environnement de production) pour gagner du temps (mise en cache). Il faut donc lancer la commande suivante pour s'assurer que le template soit bien généré à nouveau :

					$ bin/console clear:cache
			
				Par ailleurs, il faut également savoir que la commande ci-dessus ne supprime pas toujours tous les fichiers générés pour les templates. :waw:

				Si vous ne voyez toujours pas vos modifications, la dernière méthode pour s'assurer que vos templates sont bien tous générés à nouveau est de simplement supprimer le dossier de cache situé dans le dossiervar/cacheen lançant la commande :

					$ rm -rf var/cache/prod/*
			 

			En résumé

				Modifier les vues d'un bundle quelconque est très pratique, votre site garde ainsi une cohérence dans son design, et ce, que ce soit sur votre bundle à vous comme sur les autres ;
			
				Personnaliser les pages d'erreur, ce n'est pas la priorité lorsque l'on démarre un projet Symfony, mais c'est impératif avant de l'ouvrir à nos visiteurs.
			
				Le code du cours tel qu'il doit être à ce stade est disponible sur la branche iteration-21 du dépot Github.
			
		
		3. Utiliser Assetic pour gérer les codes CSS et JS de votre site
		
			Théorie : entre vitesse et lisibilité, pourquoi choisir ?
			
				À propos du nombre de requêtes HTTP d'une page web

					Vous devez sûrement vous demander ce que vient faire la vitesse d'une page dans une section qui traite de code CSS. C'est une bonne question et je vais y répondre. Le temps de chargement ressenti d'une page par un visiteur comprend tout le processus du clic au rendu de la page par le navigateur. Ainsi, on y inclut :

						Le temps d'envoi de la requête au serveur lors du clic. On ne peut pas y faire grand-chose, malheureusement.
						
						Le temps d'exécution de la page côté serveur, le temps PHP, donc. Pour cela, il faut bien penser son script et essayer de l'optimiser un peu.
						
						Le temps d'envoi du code HTML par le serveur vers le navigateur. On ne peut pas y faire grand-chose non plus.
						
						Mais là ce n'est pas tout : à partir de cette page HTML que le navigateur reçoit, ce dernier doit tout recommencer pour chaque fichier CSS, chaque JavaScript et chaque image !
			
					Donc si votre page contient 5 fichiers CSS, 3 JavaScript et 15 images, cela fait un total de 23 requêtes HTTP à traiter par votre navigateur pour vous afficher l'intégralité de la page ! Et pour ces 23 requêtes, il y a les temps d'envoi et de réception qui sont incompressibles et qui prennent du temps.

					Au final, s'il faut bien sûr optimiser le code PHP côté serveur, la partie front-end qui comprend codes HTML, CSS et JavaScript ainsi que les fichiers images est bien celle qui prend le plus de temps à se charger, vu du visiteur.

				Comment optimiser le front-end ?

					L'idée est de réduire les temps incompressibles. Comme ils sont justement incompressibles, il faut que l'on en diminue le nombre. La seule solution est donc de grouper ces fichiers. L'idée est que, au lieu d'avoir cinq fichiers CSS différents, on va mettre tout notre code CSS dans un seul fichier. Comme cela, on aura une seule requête au lieu de cinq. Super !

					Mais le problème, c'est que si l'on avait trois fichiers et non un seul, ce n'était pas pour rien. Chaque fichier concernait une partie de votre site, c'était bien plus lisible. Tout regrouper vous gênerait dans le développement de vos fichiers CSS (idem pour les fichiers JavaScript, bien sûr).

					C'est là qu'Assetic va intervenir : il va grouper lui-même les fichiers et va vous permettre de garder votre séparation !

				Il est aussi possible d'améliorer le temps de chargement !

					En effet, transmettre votre unique fichier CSS de plusieurs centaines de lignes, cela prend du temps (temps qui varie en fonction de la connexion de votre serveur, de celle du visiteur, etc.). On peut améliorer ce temps en diminuant simplement la taille du fichier.

					C'est possible grâce à un outil Java appelé YUI Compressor, un outil développé par Yahoo!. Cet outil permet de diminuer la taille de vos fichiers CSS, mais surtout de vos fichiers JavaScript, en supprimant les commentaires, les espaces, en raccourcissant le nom des variables, etc. On dit qu'il « minifie » les fichiers (il ne les compresse pas comme un fichier zip). Le code devient bien sûr complètement illisible ! Mais c'est là qu'Assetic intervient de nouveau : il vous permet de garder votre version claire lorsque vous développez, mais « minifie » les fichiers pour vos visiteurs (en mode prod) !

				En action !

					Vous voulez voir ce que donne l'utilisation d'Assetic sur un vrai site internet pour bien vous rendre compte ? Je vous invite à regarder la source d'un site que j'ai réalisé, Caissin.fr, dans lequel j'utilise Assetic. Le chargement de tous les fichiers CSS se fait en 3 lignes :

						<link href="//netdna.bootstrapcdn.com/bootstrap/3.0.2/css/bootstrap.min.css">
						<link href="//netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.min.css">
						<link href="/assets/css/style.css">
			
					Je n'ai pas concaténé les deux premiers fichiers CSS avec les miens car j'utilise un CDN, des serveurs publics qui délivrent certains fichiers connus (le CSS Bootstrap ou le Javascript jQuery par exemple) très rapidement. L'idée est qu'on espère que notre visiteur ait déjà ce fichier en cache dans son navigateur, pour qu'il n'ait pas besoin de le charger à nouveau. En effet, s'il a visité un autre site qui utilise le même CDN avant de venir sur le nôtre, alors son navigateur aura déjà chargé le fichier et il sera en cache.
			
					Ce qui nous intéresse, c'est le dernier fichier, que j'ai nommé style.css. C'est ce fichier qui contient tous mes CSS perso. Ouvrez-le, vous pouvez voir que son contenu est difficilement lisible : pas d'indentation, pas d'espaces, etc. C'est cela qu'on appelle la « minification ». Vous pouvez également voir qu'il y a plusieurs fichiers concaténés en un seul. Bref, ce fichier est très dense et permet d'optimiser le chargement de tous les CSS du site, efficace !

					Il est est de même avec le fichier Javascript, je vous laisse regarder ce que cela donne.

				Conclusion

					Grâce à Assetic, on peut optimiser très facilement nos scripts CSS/JS. Par exemple, nous pouvons passer de nos huit requêtes pour 500 Ko à seulement deux requêtes (1 CSS + 1 JS) pour 200 Ko. Le temps d'affichage de la page pour nos visiteurs sera donc bien plus court, et on conserve la lisibilité du code côté développeur !

			
			Pratique : Assetic à la rescousse !
			
				L'objectif d'Assetic est de regrouper nos fichiers CSS et JavaScript comme nous venons d'en parler. Il n'est pas inclus par défaut avec Symfony, il nous faut donc l'installer ainsi que ses dépendances.

				Installer Assetic et les bibliothèques de compression

					Commençons par ajouter les dépendances dans notre composer.json  :

						"require": {
							"symfony/assetic-bundle": "^2.7.1",
							"leafo/scssphp": "~0.6",
							"patchwork/jsqueeze": "~1.0"
						},
			
					Et mettez à jour vos dépendances avec un php composer.phar update.

					Puis, ajoutez la configuration minimale du bundle AsseticBundle dans votre fichier config.yml :

						# app/config/config.yml

						assetic:
						  debug:          '%kernel.debug%'
						  use_controller: '%kernel.debug%'
			
				Servir des ressources

					Assetic peut servir au navigateur les ressources que vous lui demandez.

					Servir une seule ressource

						Allez donc dans la vue du layout, nous allons y déclarer nos fichiers CSS et JavaScript. Voici comment on déclarait nos fichiers CSS jusqu'à maintenant :

							{# src/OC/CoreBundle/Resources/views/layout.html.twig #}
							{# ou n'importe quelle vue en réalité ! #}

							<link rel="stylesheet" href="{{ asset('bundles/ocplatform/css/main.css') }}" type="text/css" />
							
						Et voici comment faire pour décharger cette responsabilité à Assetic :

							{% stylesheets 'bundles/ocplatform/css/main.css' %}
							  <link rel="stylesheet" href="{{ asset_url }}" type="text/css" />
							{% endstylesheets %}
			
						Au sein de la balise stylesheets, la variable {{ asset_url }} est définie, et vaut l'URL à laquelle le navigateur peut récupérer le CSS.
			
						Bien sûr, je considère que vous avez un fichier CSS src/OC/PlatformBundle/Resources/public/css/main.css
			
						Attention, on utilise ici le fichier CSS déployé dans le répertoire web , et non celui qui se trouve dans le répertoire src/OC/PlatformBundle/... . Cela signifie que vous devez avoir publié vos assets au préalable, grâce à la commande php bin/console assets:install .

						Pour éviter de devoir exécuter cette commande à chaque fois, je vous conseille de faire un lien (une sorte de raccourci), en ajoutant le paramètre assets:install --symlink . Ainsi, le dossier web/bundles/ocplatform  pointe en réalité vers src/OC/PlatformBundle/Resources/public , du coup lorsque vous changez l'un, vous changez l'autre ! Sous Windows, vous devez lancer l'invite de commande en mode Administrateur pour pouvoir le faire.
			
						Et voici le HTML qu'Assetic a généré avec cette balise :

							<link rel="stylesheet" href="/Symfony/web/app_dev.php/css/519c4f6_main_1.css" type="text/css" />
			
						Pas convaincant ? C'est parce que nous sommes en mode dev ! Nous verrons plus loin comment nous occuper du mode prod, qui demande un peu plus d'effort.

						Il se peut que vous ayez une erreur de route concernant Assetic, Unable to generate a URL for the named route "_assetic_7e1c02a_0" as such route does not exist. Pour la régler, videz simplement votre cache ;)
			
						En attendant, essayons de comprendre ce code généré. En mode dev, Assetic génère à la volée les ressources, d'où une URL vers un fichier CSS qui passe par le contrôleur frontal app_dev.php. En réalité, c'est bien un contrôleur d'Assetic qui s'exécute, car le fichier app_dev.php/css/519c4f6_main_1.css n'existe évidemment pas. Ce contrôleur va chercher le contenu du fichier qu'on lui a indiqué, puis le retransmet. Pour l'instant il le retransmet tel quel, mais il sera bien sûr possible d'appliquer des modifications, nous le verrons par la suite.

						Et bien sûr, le mécanisme est exactement le même pour vos fichiers JavaScript :

							{% javascripts 'bundles/ocplatform/js/main.js' %}
							  <script type="text/javascript" src="{{ asset_url }}"></script>
							{% endjavascripts %}
			
						Pensez bien à mettre les fichiers JavaScript en toute fin du code HTML. C'est parce que lorsque le navigateur intercepte une déclaration de fichier JavaScript, il arrête le rendu de la page, charge le fichier, l'exécute, et ensuite seulement continue le rendu de la page. En effet, le navigateur ne peut pas savoir d'avance si le script JavaScript veut changer quelque chose à l'apparence de la page, il est donc obligé de tout bloquer avant de continuer. Si vos scripts JavaScript sont bien faits, vous pouvez sans problème les déclarer en fin de page. Ainsi, le navigateur se bloquera pour vos fichiers JavaScript une fois que le rendu de la page sera terminé ! Ce qui fait que c'est transparent pour vos visiteurs : ils peuvent déjà profiter de la page pendant que les scripts JS se chargent en arrière-plan.
			
					Servir plusieurs ressources regroupées en une

						Cela devient déjà un peu plus intéressant. En plus du fichier CSS main.css (ou tout autre fichier, adaptez au code CSS que vous avez bien sûr), disons qu'on veut charger un deuxième fichier CSS platform.css (ou n'importe quel autre CSS que vous souhaitez utiliser bien sûr). Avec l'ancienne méthode, on aurait écrit une deuxième balise <link>, mais voici comment faire avec Assetic :

							{% stylesheets
							  'bundles/ocplatform/css/main.css'
							  'bundles/ocplatform/css/platform.css' %}
							  <link rel="stylesheet" href="{{ asset_url }}" type="text/css" />
							{% endstylesheets %}
			
						On a simplement rajouté la deuxième ressource à charger dans la balise stylesheets. Et voici le rendu HTML :

							<link rel="stylesheet" href="/Symfony/web/app_dev.php/css/03b7e21_main_1.css" type="text/css" />
							<link rel="stylesheet" href="/Symfony/web/app_dev.php/css/03b7e21_platform_2.css" type="text/css" />
			
						Mais, il n'était pas censé regrouper les deux ressources en une ?
			
						Si bien sûr… mais en mode prod ! Encore une fois, nous sommes en mode de développement, il est donc inutile de regrouper les ressources (on se fiche un peu de la rapidité), Assetic ne le fait donc pas.

						Si vous avez plusieurs fichiers CSS dans le répertoire des CSS de votre bundle, il est également possible d'utiliser un joker pour les charger tous. Ainsi, au lieu de préciser les fichiers exacts, vous pouvez utiliser le joker « * », comme ceci :

							{% stylesheets 'bundles/ocplatform/css/*' %}
			
						Ce qui chargera tous les fichiers qui sont dans le répertoire, pratique !

				Modifier les ressources servies

					En servant les ressources depuis un contrôleur PHP, Assetic a la possibilité de modifier à la volée tout ce qu'il sert. Cela est possible grâce aux filtres, que l'on peut définir directement dans les balises stylesheets ou javascripts.

					Voyons quelques filtres intéressants.

					Le filtre cssrewrite

						Si vous avez exécuté le code précédent, vous avez pu vous rendre compte qu'il se pose un petit problème lorsque vous utilisez des images dans le CSS. En effet, imaginons que votre CSS fait référence aux images via un chemin relatif ../img/exemple.png.

						Lorsque le fichier CSS était placé dans web/bundles/xxx/css, ce chemin relatif pointait bien vers web/bundles/xxx/img, là où sont nos images. Or maintenant, du point de vue du navigateur, le fichier CSS est dans app_dev.php/css, du coup le chemin relatif vers les images n'est plus bon !

						C'est ici qu'intervient le filtre cssrewrite. Voici la seule modification à apporter côté vue Twig :

							{% stylesheets filter='cssrewrite'
							  'bundles/ocplatform/css/main.css'
							  'bundles/ocplatform/css/platform.css' %}
							  <link rel="stylesheet" href="{{ asset_url }}" type="text/css" />
							{% endstylesheets %}
			
						On a juste précisé l'attribut filter à la balise. Ce filtre permet de réécrire tous les chemins relatifs contenus dans les fichiers CSS, afin de prendre en compte la modification du répertoire du CSS.

						Puis, activez le filtre cssrewrite  dans la configuration :

							# app/config/config.yml

							assetic:
							  debug:          '%kernel.debug%'
							  use_controller: '%kernel.debug%'
							  filters:
								cssrewrite: ~
			
						Actualisez votre page, vous verrez que cela fonctionne très bien ! Le chemin relatif d'accès aux images est devenu : ../../bundles/ocplatform/img/exemple.png, ce qui est correct.

					Les filtres scssphp et jsqueeze

						Ces filtres sont très utiles, ce sont ceux qui « minifient » les fichiers.

						Ces outils scssphp et jsqueeze sont ceux qu'on a téléchargé grâce à Composer un peu plus haut, leur code se trouve donc dans notre répertoire vendor. Maintenant, direction la configuration de notre application pour activer et configurer ces filtres :

							# app/config/config.yml

							assetic:
							  debug:          '%kernel.debug%'
							  use_controller: '%kernel.debug%'
							  filters:
								cssrewrite: ~
								jsqueeze:   ~
								scssphp:
								  formatter: 'Leafo\ScssPhp\Formatter\Compressed'
			
						Voilà, nous venons d'activer les filtres scssphp et jsqueeze, on peut maintenant les utiliser depuis nos vues. Ajoutez ce filtre dans vos balises :

							{% stylesheets  filter='cssrewrite, scssphp'
							  ... %}
			
						Et de même pour les fichiers JavaScript :

							{% javascripts filter='jsqueeze'
							  ... %}
							  
						Testez le rendu !

						Mais… on est toujours en mode dev et les fichiers CSS et JS sont devenus illisibles pour un éventuel débogage ! Heureusement, vous avez la possibilité de dire qu'un filtre ne s'applique pas en mode dev. Il suffit de mettre un point d'interrogation devant :

							{% stylesheets filter='?scssphp'
							  ... %}
			
						Ainsi, le filtre ne s'appliquera qu'en mode prod, tout comme le groupement des fichiers en un seul.

						Au final, notre mode dev n'a pas changé d'un poil, on garde nos différents fichiers et ces derniers sont lisibles, mais le mode prod a reçu toutes les optimisations : regroupement des fichiers ainsi que « minification ».

				Gestion du mode prod

					Si vous n'avez pas encore testé le rendu en mode prod, faites-le. Cela ne fonctionne pas ? Vos fichiers CSS et JS ne sont pas chargés ? C'est normal. :p Nous n'avons pas fini notre mise en place.
	
					Comprendre Assetic

						Pour comprendre pourquoi la gestion du mode prod demande un effort supplémentaire, vous devez comprendre la manière dont Assetic fonctionne. Lorsque l'on utilise les balises {% stylesheets %} ou {% javascripts %}, le code HTML généré en mode prod est le suivant (regardez la source de vos pages HTML) :

							<link rel="stylesheet" href="/Symfony/web/css/cd91cad.css" type="text/css" />
			
						Or ce fichier n'existe pas du tout !

						Lors du mode dev, on l'a vu, Assetic passe directement par un contrôleur pour générer à la volée nos ressources. Mais évidemment, « minifier » et regrouper des fichiers à la volée et ce pour chaque requête, cela prend beaucoup de temps. Si en mode dev on peut se le permettre, on ne le peut pas en mode prod !

						Du coup, l'astuce pour le mode prod est d'exporter en dur, une bonne fois pour toutes, les fichiers CSS et JS dont on a besoin. Ainsi, en mode prod, le fichier /css/cd91cad.css (dans mon cas) existera en dur, Assetic n'interceptera pas l'URL, et votre serveur web (souvent Apache) va envoyer directement le contenu du fichier à vos visiteurs. Plus rapide, on ne peut pas !

						Vous notez que, maintenant que nous sommes en mode prod, Assetic a bien regroupé toutes nos ressources en une seule. Il n'y a plus qu'un seul fichier CSS.
			
					Exporter ses fichiers CSS et JS

						Pour faire cet export en dur, il faut utiliser une simple commande d'Assetic :

							php bin/console assetic:dump --env=prod
			
						Cette commande devrait vous sortir un résultat de ce type :

							C:\wamp\www\Symfony>php bin/console cache:clear --env=prod

							C:\wamp\www\Symfony>php bin/console assetic:dump --env=prod
			
							Dumping all prod assets.
							Debug mode is off.

							16:13:30 [file+] C:/wamp/www/Symfony/app/../web/css/cd91cad.css
			
						Cette commande va lire toutes nos vues pour y trouver les balises {% stylesheets %} et {% javascripts %}, puis va exporter en dur dans les fichiers /web/css/XXX.css et /web/js/XXX.js.

						Et voilà, maintenant, nos fichiers existent réellement. Testez à nouveau le rendu en mode prod : c'est bon !

						Attention : exporter nos fichiers en dur est une action ponctuelle. Ainsi, à chaque fois que vous modifiez vos fichiers d'origine, vous devez exécuter la commandeassetic:dump pour mettre à jour vos fichiers pour la production ! Prenez donc l'habitude, à chaque fois que vous déployez en production, de vider le cache et d'exporter les ressources Assetic.
			
				Et bien plus encore…

					Assetic, c'est une bibliothèque complète qui permet beaucoup de choses. Vous pouvez également optimiser vos images, et construire une configuration plus poussée. Bref, n'hésitez pas à vous renseigner sur la documentation officielle.

				En réumé

					Le chargement des fichiers CSS et JS prend beaucoup de temps dans le rendu d'une page HTML sur le navigateur de vos visiteurs ;
					
					Assetic permet de regrouper tous vos fichiers CSS ainsi que tous vos fichiers JS, afin de réduire le nombre de requêtes HTTP que doivent faire vos visiteurs pour afficher une page ;
					
					Assetic permet également de minifier vos fichiers, afin de diminuer leur taille et donc accélérer leur chargement pour vos visiteurs ;
					
					Enfin, l'utilisation d'Assetic permet de garder votre confort de développement en local, vos fichiers ne sont ni regroupés, ni minifiés : indispensable pour déboguer !
					
					Le code du cours tel qu'il doit être à ce stade est disponible sur la branche iteration-22 du dépot Github.
			
		
		4. Utiliser la console directement depuis le navigateur
		
			Théorie : le composant Console de Symfony
			
				Les commandes sont en PHP

					Nous l'avons déjà évoqué au long de ce cours, les commandes Symfony sont bien de simples codes PHP ! Effectivement on les exécute depuis une console, mais cela ne les empêche en rien d'être en PHP.

					Et comme elles sont en PHP… elle peuvent tout à fait être exécutées depuis un autre script PHP. C'est en fait ce qui est déjà fait par le script PHP de la console, celui que l'on exécute à chaque fois : le fichier bin/console. Voici son contenu :

						#!/usr/bin/env php
						<?php

						use Symfony\Bundle\FrameworkBundle\Console\Application;
						use Symfony\Component\Console\Input\ArgvInput;
						use Symfony\Component\Debug\Debug;

						set_time_limit(0);

						$loader = require __DIR__.'/../app/autoload.php';

						$input = new ArgvInput();
						$env = $input->getParameterOption(array('--env', '-e'), getenv('SYMFONY_ENV') ?: 'dev');
						$debug = getenv('SYMFONY_DEBUG') !== '0' && !$input->hasParameterOption(array('--no-debug', '')) && $env !== 'prod';

						if ($debug) {
							Debug::enable();
						}

						$kernel = new AppKernel($env, $debug);
						$application = new Application($kernel);
						$application->run($input);
			
					Comme vous pouvez le voir, ce fichier ressemble beaucoup au contrôleur frontal, app.php. Il charge également le Kernel. La seule chose qu'il fait de différent, c'est d'utiliser le composant Console de Symfony, en instanciant la classe Application (ligne 21). C'est cet objet qui va ensuite exécuter les différentes commandes définies en PHP dans les bundles.

					Si vous avez remarqué, la principale différence avec nos contrôleurs frontaux, c'est que ici il n'est pas question de Request. En effet, les requêtes HTTP sont les requêtes que le navigateur envoie, mais ici pas de navigateur, donc pas de Request  !
			
			
				Exemple d'une commande

					Chaque commande est définie dans une classe PHP distincte, que l'on place dans le répertoire Command des bundles. Ces classes comprennent entres autres deux méthodes :

						configure() qui définit le nom, les arguments et la description de la commande ;
						
						execute() qui exécute la commande à proprement parler.
			
					Prenons l'exemple de la commande list, qui liste toutes les commandes disponibles dans l'application. Elle est définie dans le fichier vendor/symfony/src/Component/Console/Command/ListCommand.php, dont voici le contenu :

						<?php

						namespace Symfony\Component\Console\Command;

						use Symfony\Component\Console\Input\InputArgument;
						use Symfony\Component\Console\Input\InputOption;
						use Symfony\Component\Console\Input\InputInterface;
						use Symfony\Component\Console\Output\OutputInterface;
						use Symfony\Component\Console\Output\Output;
						use Symfony\Component\Console\Command\Command;

						/**
						 * ListCommand displays the list of all available commands for the application.
						 *
						 * @author Fabien Potencier <fabien@symfony.com>
						 */
						class ListCommand extends Command
						{
						  protected function configure()
						  {
							$this
							  ->setDefinition(array(
								new InputArgument('namespace', InputArgument::OPTIONAL, 'The namespace name'),
								new InputOption('xml', null, InputOption::VALUE_NONE, 'To output help as XML'),
							  ))
							  ->setName('list')
							  ->setDescription('Lists commands')
							  ->setHelp(<<<EOF
						The <info>list</info> command lists all commands:
						[...]
						  <info>php app/console list --xml</info>
						EOF
							  );
						  }

						  protected function execute(InputInterface $input, OutputInterface $output)
						  {
							if ($input->getOption('xml')) {
							  $output->writeln($this->getApplication()->asXml($input->getArgument('namespace')), OutputInterface::OUTPUT_RAW);
							} else {
							  $output->writeln($this->getApplication()->asText($input->getArgument('namespace')));
							}
						  }
						}
						
					Vous distinguez bien ici les deux méthodes qui composent la commande list. En vous basant sur cet exemple, vous êtes d'ailleurs capables d'écrire votre propre commande : ce n'est pas très compliqué !

					Mais revenons au but de ce chapitre, qui est de pouvoir utiliser ces commandes depuis le navigateur.

			Pratique : utiliser un ConsoleBundle
			
				ConsoleBundle ?

					Vous le savez sûrement, la communauté de Symfony est très active, et un nombre impressionnant de bundles a vu le jour depuis la sortie de Symfony. Vous pouvez les retrouver presque tous sur le site http://knpbundles.com/ qui les recense.

					Il doit sûrement y avoir plusieurs bundles qui fournissent une console dans le navigateur, mais je vous propose d'en installer un en particulier : CoreSphereConsoleBundle. C'est un bundle simple qui remplit parfaitement sa tâche, et dont l'interface est très pratique, comme le montre la figure suivante.

						Interface de CoreSphereConsoleBundle
			
				Installer CoreSphereConsoleBundle

					L'installation d'un tel bundle est vraiment simple, attaquons-la dès maintenant.

					Télécharger CoreSphereConsoleBundle

						Vous trouverez toutes les instructions sur la page du bundle : github.com/CoreSphere/ConsoleBundle. Voici comment procéder :

						Pour l'installer avec Composer, rajoutez la ligne suivante dans vos dépendances :

							// composer.json

							"require": {
								// …
								"coresphere/console-bundle": "~0.4"
							}
			
						Puis mettez à jour vos dépendances grâce à la commande suivante :

							php ../composer.phar update
			
					Enregistrement du bundle dans le Kernel

						Puis il faut enregistrer le bundle CoreSphereConsoleBundle dans app/AppKernel.php. Je ne l'active que pour le mode "dev" car on ne s'en servira que via le contrôleur frontal de développement (app_dev.php) :

							<?php
							// app/AppKernel.php

							use Symfony\Component\HttpKernel\Kernel;
							use Symfony\Component\Config\Loader\LoaderInterface;

							class AppKernel extends Kernel
							{
							  public function registerBundles()
							  {
								$bundles = array(
								  // ...
								);

								if (in_array($this->getEnvironment(), array('dev', 'test'))) {
								  // ...
								  $bundles[] = new CoreSphere\ConsoleBundle\CoreSphereConsoleBundle();
								}

								return $bundles;
							  }
							}
			
					Enregistrement des routes

						Pour paramétrer un bundle, on fait comme toujours : on lit sa documentation. La documentation se trouve soit dans le readme, soit dans le répertoire Resources/doc, cela dépend des bundles. Dans notre cas, elle se trouve dans le readme.

						Pour les routes, il faut donc enregistrer le fichier dans notre routing_dev.yml. On ne les met pas dans routing.yml, car la console ne doit être accessible qu'en mode dev, on a enregistré le bundle que pour ce mode. Ajoutez donc à la fin de app/config/routing_dev.yml :

							# app/config/routing_dev.yml

							coresphere_console:
								resource: .
								type: extra
			
					Publier les assets

						L'installation touche à sa fin, il ne reste plus qu'à rendre disponibles les nouveaux fichiers JS et CSS du bundle, ce qui se fait comme vous le savez grâce à la commande suivante :

							php bin/console assets:install web
			
						C'est fini ! Il ne reste plus qu'à utiliser notre nouvelle console.

				Utilisation de la console dans son navigateur

					Par défaut, le bundle définit la route _console pour afficher la console. Allez donc à l'adresse /_console et profitez !

					Bien entendu, pour exécuter des commandes Symfony depuis cette interface, il ne faut pas faire php bin/console la_commande, mais uniquement la_commande ! Le script PHP du bundle n'utilise pas le script bin/console, il utilise le composant Console en direct.
		
					Pour les utilisateurs de Windows, vous pouvez remarquer que le résultat des commandes est en couleurs. Eh oui, Symfony est plus fort que l'invite de commandes de Windows, il gère les couleurs !

					En plus de l'adresse /_console dédiée, il y a un petit bouton console, regardez en bas à droite dans la barre d'outils de Symfony. Cela vous permet d'accéder rapidement à la console.

				Prêts pour l'hébergement mutualisé

					Vous êtes prêts pour utiliser la console de votre application sur les hébergements mutualisés, qui n'offrent généralement pas d'accès SSH !

			En résumé

				Les commandes Symfony sont en PHP pur, il est ainsi tout à fait possible de « simuler » une console via le navigateur.
				
				Vous disposez maintenant d'une console accessible depuis votre navigateur : cela va vous simplifier la vie, croyez-moi ! ;)
				
				N'hésitez pas à faire vos retours sur le bundle directement via les issues sur GitHub : github.com/CoreSphere/ConsoleBundle/issues.
				
				Le code du cours tel qu'il doit être à ce stade est disponible sur la branche iteration-23 du dépot Github.
				
				Si vous avez des doutes sur votre code, vous pouvez aussi utiliser SensioLabsInsight, l'outil d'analyse de code de SensioLabs !
				
		
		5. Déployer son site Symfony en production
		
			Préparer son application en local
			
				Bien évidemment, la première chose à faire avant d'envoyer son application sur un serveur, c'est de bien vérifier que tout fonctionne chez soi ! Vous êtes habitués à travailler dans l'environnement de développement et c'est normal, mais pour bien préparer le passage en production, on va maintenant utiliser le mode production.

				Vider le cache, tout le cache

					Tout d'abord, pour être sûrs de tester ce qui est codé, il faut vider le cache. Faites donc un petit :

						php bin/console cache:clear
			
					Voici qui vient de vider le cache… de l'environnement de développement ! Eh oui, n'oubliez donc jamais de bien vider le cache de production, via la commande :

						php bin/console cache:clear --env=prod
			
				Tester l'environnement de production

					Pour tester que tout fonctionne correctement en production, il faut utiliser le contrôleur frontalapp.phpcomme vous le savez, et nonapp_dev.php. Mais cet environnement n'est pas très pratique pour détecter et résoudre les erreurs, vu qu'il ne les affiche pas du tout. Pour cela, ouvrez le fichierweb/app.php, on va activer le mode debugger pour cet environnement. Il correspond au deuxième argument du constructeur du Kernel :

						<?php
						// web/app.php

						// …

						$kernel = new AppKernel('prod', true); // Définissez ce 2e argument à true
			
					Dans cette configuration, vous êtes toujours dans l'environnement de production, avec tous les paramètres qui vont bien : rappelez-vous, certains fichiers commeconfig.ymlouconfig_dev.ymlsont chargés différemment selon l'environnement. L'activation du mode debugger ne change rien à cela, mais permet d'afficher à l'écran les erreurs.

					Pensez à bien remettre ce paramètre àfalselorsque vous avez fini vos tests !
			
					Lorsque le mode debugger est désactivé (ce sera le cas sur votre serveur en ligne), les erreurs ne sont certes pas affichées à l'écran, mais elles sont heureusement répertoriées dans le fichiervar/logs/prod. Si l'un de vos visiteurs vous rapporte une erreur, c'est dans ce fichier qu'il faut aller regarder pour avoir le détail, les informations nécessaires à la résolution de l'erreur.
			
			Soigner ses pages d'erreur

				En tant que développeurs, vous avez la chance de pouvoir utiliser l'environnement de développement et d'avoir de très jolies pages d'erreur, grâce à Symfony. Mais mettez-vous à la place de vos visiteurs : créez volontairement une erreur sur l'une de vos pages (une fonction Twig mal orthographiée par exemple), et regardez le résultat depuis l'environnement de production (et sans le mode debugger bien sûr !), visible à la figure suivante.

					Une page d'erreur pas très séduisante
			
				Pas très joli, n'est-ce pas ? C'est pour cela qu'il faut impérativement que vous personnalisiez les pages d'erreur de l'environnement de production. Un chapitre entier est dédié à ce point important, je vous invite à lire « Personnaliser les pages d'erreur ».

			Installer une console sur navigateur

				En fonction de l'hébergement que vous avez, vous n'avez pas forcément l'accès SSH nécessaire pour exécuter les commandes Symfony. Heureusement, les commandes Symfony sont de simples scripts PHP, il est alors tout à fait possible de les exécuter depuis un navigateur. Il existe des bundles qui émulent une console dans un navigateur, décrits dans un chapitre dédié : je vous invite à lire le chapitre « Utiliser la console directement depuis le navigateur ».

			Vérifier la qualité de votre code

				L'importance d'écrire un code de qualité n'est plus à démontrer. En utilisant Symfony plutôt que de tout coder vous-mêmes, j'imagine que vous êtes déjà sensible à cela.

				Cependant, Symfony étant un framework très puissant, le code que vous faites  se doit d'être à la hauteur, et il n'est pas évident le passer entièrement en revue pour s'en assurer. Heureusement, il existe un outil qui permet de vérifier automatiquement un grand nombre de points particuliers dans votre code. Il s'agit d'un outil en ligne,  SensioLabs Insight : insight.sensiolabs.com.

				Je vous invite à aller voir, à l'adresse précédente, les points que cet outil vérifie. Ils sont tous intéressants à prendre en compte si vous voulez avoir une application Symfony de grande qualité. La figure suivante montre par exemple ce que donne l'analyse sur le code source de notre plateforme d'annonce créée dans ce cours.

					Notre code source obtient la médaille de Bronze
			
				Comme la figure le montre, il reste quelques points à corriger : 2 points majeurs, 10 mineurs et 12 recommendations. Il reste encore un peu de travail avant d'obtenir la médaille Platinium !

				Vous pouvez utiliser gratuitement l'outil sur vos projets publics, c'est-à-dire que votre projet doit avoir un Git publiquement accessible. Si vous avez votre code sur Github, c'est parfait.

			Vérifier la sécurité de vos dépendances

				Un projet Symfony contient beaucoup de dépendances : cela se voit très bien en constatant le nombre de bibliothèques dans le répertoire vendor. Il est impossible de se tenir au courant des failles de sécurité découverte dans toutes ces dépendances... mais pourtant cela serait indispensable ! Vous n'imaginez pas envoyer en ligne votre application alors qu'une de vos dépendances contient une faille de sécurité.

				Pour cela, il existe un outil également créé par SensioLabs : Security Checker (security.sensiolabs.org). Vous avez deux solutions pour vérifier vos dépendances.

				La première est d'envoyer manuellement votre fichiercomposer.lock sur l'interface en ligne de l'outil. C'est lui qui contient les versions exactes des dépendances que vous utilisez, cela permet donc à l'outil de vérifier avec sa base de données internes des failles de sécurité.

					Mes dépendances n'ont pas de faille connues
			
				La deuxième solution est d'utiliser l'outil fourni en ligne de commande. Il est déjà inclu dans la version standard de Symfony, vous l'avez donc déjà. Il s'agit de la commandesecurity:check, que vous pouvez exécuter comme n'importe quelle commande Symfony :

					C:\wamp\www\Symfony>php bin/console security:check
					Security Check Report
					~~~~~~~~~~~~~~~~~~~~~
					Checked file: C:\wamp\www\Symfony\composer.lock

					 [OK]
					 0 packages have known vulnerabilities

					 This checker can only detect vulnerabilities that are referenced
					 Disclaimer in the SensioLabs security advisories database. Execute this
					 command regularly to check the newly discovered vulnerabilities.
			
				Si vous avez une dépendance avec une faille connue, renseignez-vous dessus sur Internet. La plupart du temps, la bibliothèque aura corrigé la faille dans une version plus récente : vous devez alors la mettre à jour dans votre projet.

			Vérifier et préparer le serveur de production
			
				Vérifier la compatibilité du serveur

					Évidemment, pour déployer une application Symfony sur votre serveur, encore faut-il que celui-ci soit compatible avec les besoins de Symfony ! Pour vérifier cela, on peut distinguer deux cas.

					Vous avez déjà un hébergeur

						Ce cas est le plus simple, car vous avez accès au serveur. Symfony intègre un petit fichier PHP qui fait toutes les vérifications de compatibilité nécessaires, utilisons-le ! Il s'agit du fichierweb/config.php, mais avant de l'envoyer sur le serveur il nous faut le modifier un petit peu. En effet, ouvrez-le, vous pouvez voir qu'il y a une condition sur l'IP qui appelle le fichier :

							<?php
							// web/config.php

							// …

							if (!in_array(@$_SERVER['REMOTE_ADDR'], array(
							  '127.0.0.1',
							  '::1',
							))) {
							  header('HTTP/1.0 403 Forbidden');
							  exit('This script is only accessible from localhost.');
							}
			
						Comme ce fichier n'est pas destiné à rester sur votre serveur, supprimez simplement ce bloc et envoyez le fichier sur votre serveur. Ouvrez la page web qui lui correspond, par exemplewww.votre-serveur.com/config.php. Vous devriez obtenir la figure suivante.

							Le fichier de configuration s'affiche
			
						Comme vous le voyez, mon serveur est compatible avec Symfony, car il n'y a pas de partie « Major Problems », juste des « Recommendations ». Bien évidemment, essayez de respecter les recommandations avec votre hébergeur/administrateur si cela est possible. Notamment, comme Symfony l'indique, installer un accélérateur PHP comme APC est très important, cela augmentera très sensiblement les performances. Si celles-ci n'étaient pas importantes en local, elles le seront en ligne !

						Si vous avez envoyé seulement le fichierconfig.php, vous aurez bien sûr les deux problèmes majeurs comme quoi Symfony ne peut pas écrire dans le répertoire var. Pas d'inquiétude, on enverra tous les autres fichiers un peu plus tard.
			
					Vous n'avez pas encore d'hébergeur et en cherchez un compatible.

						Dans ce cas, vous ne pouvez pas exécuter le petit script de test inclus dans Symfony. Ce n'est pas bien grave, vous allez le faire à la main ! Voici les points obligatoires qu'il faut que votre serveur respecte pour pouvoir faire tourner Symfony :

							La version de PHP doit être supérieure ou égale à PHP 5.5.9 ;
							
							L'extension SQLite 3 doit être activée ;
							
							L'extension JSON doit être activée ;
							
							L'extension Ctype doit être activée ;
							
							Le paramètredate.timezonedoit être défini dans lephp.ini.
			
						Il y a bien entendu d'autres points qu'il vaut mieux vérifier, bien qu'ils ne soient pas obligatoires. La liste complète est disponible dans la documentation officielle.

			Déployer votre application
			
				Il y a deux cas pour déployer votre application sur votre serveur :

					Soit vous n'avez pas accès en SSH à votre serveur (la plupart des hébergements mutualisés, etc.) : dans ce cas vous devez envoyer vos fichiers à la main ;
					
					Soit vous avez accès en SSH à votre serveur (VPS, serveur dédiés, etc.) : dans ce cas il vous faut utiliser Capifony, un outil fait pour automatiser le déploiement.
					
				Méthode 1 : Envoyer les fichiers sur le serveur par FTP

					Dans un premier temps, il faut bien évidemment envoyer les fichiers sur le serveur. Pour éviter d'envoyer des fichiers inutiles et lourds, videz d'abord le cache de votre application : celui-ci est de l'ordre de 1 à 10 Mo. Attention, pour cette fois il faut le vider à la main, en supprimant tout son contenu, car la commandecache:clearne fait pas que supprimer le cache, elle le reconstruit en partie, il restera donc des fichiers qu'on ne veut pas. Ensuite, envoyez tous vos fichiers et dossiers à la racine de votre hébergement, danswww/sur OVH par exemple.

					Que faire des vendors ?

						Si vous avez accès à Composer sur votre serveur, c'est le mieux. N'envoyez pas vos vendors à la main, ils sont assez lourds, mais envoyez bien les deux fichierscomposer.jsonetcomposer.lock. Ensuite, sur votre serveur, exécutez la commandephp composer.phar install. Je parle bien de la commandeinstallet nonupdate, qui va installer les mêmes versions des dépendances que vous avez en local. Cela se fait grâce au fichiercomposer.lockqui contient tous les numéros des versions installées justement.

						Si vous n'avez pas accès à Composer sur votre serveur, alors contentez-vous d'envoyer le dossiervendoren même temps que le reste de votre application.

					Régler les droits sur le dossier /var

						Vous le savez, Symfony a besoin de pouvoir écrire dans le répertoire :var pour y mettre le cache de l'application et ainsi améliorer les performances, mais aussi pour y mettre les logs, l'historiques des informations et erreurs rencontrées lors de l'exécution des pages.

						Normalement, votre client FTP devrait vous permettre de régler les droits sur les dossiers. Avec FileZilla par exemple, un clic droit sur le dossier var  vous permet de définir les droits, comme à la figure suivante.

							Modifiez les droits des dossiers
			
						Assurez-vous d'accorder tous les droits (777) pour que Symfony puisse écrire à souhait dans ce dossier.

				Méthode 2 : Utiliser l'outil Capifony pour envoyer votre application

					La méthode précédente est très sommaire. Cela permet juste de vous expliquer quels sont les points particuliers du déploiement d'un projet Symfony. Mais si votre projet est assez grand, vous devez penser à utiliser des outils adaptés pour le déployer sur votre serveur. Je vous invite notamment à jeter un œil à Capifony : capifony.org, un outil Ruby qui permet d'automatiser pas mal de choses que nous venons de voir.

					Je n'irai pas plus loin sur ce point, car c'est un outil à part entière qui mériterait un cours dédié. Cependant, sachez que c'est outil qui a été conçu pour justement déployer une application Symfony. Il fait donc toutes les tâches nécessaires et ce de façon automatique : envoyer le code source, installer les dépendances avec Composer, vider le cache, etc. Cerise sur le gâteau : si l'une de vos mises en production échoue (vous vous rendez compte d'une erreur une fois en ligne), vous pouvez facilement revenir à la version antérieure !

					Bref, à vous d'investiguer cet outil indispensable !

			Les derniers préparatifs
			
				Maintenant que votre application est sur votre serveur, il reste quelques points à ne pas oublier avant de donner l'adresse à tout le monde.

				S'autoriser l'environnement de développement

					Pour exécuter les commandes Symfony, notamment celles pour créer la base de données, il nous faut avoir accès à l'environnement de développement. Or, essayez d'accéder à votreapp_dev.php… accès interdit ! En effet, si vous l'ouvrez, vous remarquez qu'il y a le même test sur l'IP qu'on avait rencontré dansconfig.php. Cette fois-ci, ne supprimez pas la condition, car vous aurez besoin d'accéder à l'environnement de développement dans le futur. Il faut donc que vous complétiez la condition avec votre adresse IP. Obtenez votre IP surwww.whatismyip.com, et rajoutez-la :

						<?php
						// web/app_dev.php

						// …

						if (!in_array(@$_SERVER['REMOTE_ADDR'], array(
						  '127.0.0.1',
						  '::1',
						  '123.456.789.1'
						))) {
						  header('HTTP/1.0 403 Forbidden');
						  exit('You are not allowed to access this file. Check '.basename(__FILE__).' for more information.');
						}
			
					Voilà, vous avez maintenant accès à l'environnement de développement et, surtout, à la console. ;)

					Bien sûr, si vous avez une IP dynamique, il vous faudra la mettre à jour à chaque changement.
			
				Mettre en place la base de données

					Il ne manque pas grand-chose avant que votre site ne soit opérationnel. Il faut notamment s'attaquer à la base de données. Pour cela, modifiez le fichierapp/config/parameters.ymlde votre serveur afin d'adapter les valeurs des paramètresdatabase_*.

					Généralement sur un hébergement mutualisé vous n'avez pas le choix dans la base de données, et vous n'avez pas les droits pour en créer. Mais si ce n'est pas le cas, alors il faut créer la base de données que vous avez renseignée dans le fichierparameters.yml, en exécutant cette commande :

						php bin/console doctrine:database:create
			
					Puis, dans tous les cas, remplissez la base de données avec les tables correspondant à vos entités :

						php bin/console doctrine:schema:update --force
			
				S'assurer que tout fonctionne

					Ça y est, votre site devrait être opérationnel dès maintenant ! Vérifiez que tout fonctionne bien dans l'environnement de production.

					En cas de page blanche ou d'erreur 500 pas très bavarde : soit vous allez voir les logs dansvar/logs/prod, soit vous activez le mode debugger dansapp.phpcomme on l'a fait précédemment. Dans tous les cas, pas de panique : si votre site fonctionnait très bien en local, l'erreur est souvent très bête sur le serveur (problème de casse, de droit sur le répertoire de cache, oubli, etc.).
			
				Avoir de belles URL

					Si votre site fonctionne bien, vous devez sûrement avoir ce genre d'URL pour l'instant :www.votre-site.com/web/app.php. On est d'accord, on ne va pas rester avec ces horribles URL !

					Pour cela, il faut utiliser l'URL Rewriting, une fonctionnalité du serveur web Apache (rien à voir avec Symfony). L'objectif est que les requêtes/platform et/css/style.cssarrivent respectivement sur/web/platform et/web/css/style.css.

				Méthode.htaccess

					Pour faire cela avec un.htaccess, rajoutez donc ces lignes dans un.htaccessà la racine de votre serveur :

						<IfModule mod_rewrite.c>
							RewriteEngine On
							RewriteCond %{REQUEST_FILENAME} !-f
							RewriteRule ^(.*)$ web/$1 [QSA,L]
						</IfModule>
			
					C'est tout ! En effet, c'est déjà bon pour les fichiers CSS, mais pour l'URL/platform il faut qu'au final elle arrive sur/web/app.php/platform. En fait il y a déjà un.htaccessdans le répertoire/web. Ouvrez-le, il contient ce qu'il faut. Pour résumer, l'URL/platform va être réécrite en/web/platform par notre.htaccessà la racine, puis être à nouveau réécrite en/web/app.php/platform par le.htaccessde Symfony situé dans le répertoire/web.

				Méthode VirtualHost

					Si vous avez accès à la configuration du serveur HTTP Apache sur votre serveur, cette solution est à préférer. Vous pouvez l'essayer sur votre serveur local, où vous avez évidemment tous les droits.

					Pour cela il faut créer un VirtualHost, c'est-à-dire un domaine virtuel sur lequel Apache va créer un raccourci. Autrement dit, au lieu d'accéder àhttp://localhost/Symfony/web, vous allez accéder àhttp://symfony.local. On va dire à Apache que le domainesymfony.localdoit pointer directement vers le répertoireSymfony/webqui se trouve à la racine de votre serveur web.

					Je le fais ici en local avec le domaine arbitrairesymfony.local, mais si vous avez un vrai nom de domaine du genrewww.votreSite.com, adaptez le code. 
			
				Voici la configuration à rajouter dans le fichier de configuration d'Apache,httpd.conf:

					# Sous wamp : C:\wamp\bin\apache\apache2.2.22\conf\httpd.conf

					<VirtualHost *:80>
						ServerName symfony.local
						DocumentRoot "C:/wamp/www/Symfony"

						<Directory "C:/wamp/www/Symfony">
							DirectoryIndex app.php
							Options -Indexes
							AllowOverride All
							Allow from All
						</Directory>
					</VirtualHost>
			
					Pour tester en local, il reste un petit détail : faire correspondre le domaine « symfony.local » à votre propre PC, soit localhost (ou encore 127.0.0.1). Pour cela il faut modifier le fichierhosts, que vous trouverez ici :C:\Windows\System32\Drivers\etc\hosts. Rajoutez simplement une ligne avec :127.0.0.1 symfony.local. Ainsi, quand vous tapezhttp://symfony.localdans votre navigateur, Windows lui dira d'adresser sa requête à l'adresse IP 127.0.0.1, c'est-à-dire votre propre PC, et c'est votre serveur Apache qui recevra la requête.
			
				Et profitez !

					Et voilà, votre site est pleinement opérationnel, profitez-en !

					Et n'oubliez pas, à chaque modification de code source que vous envoyez sur le serveur, vous devez obligatoirement vider le cache de l'environnement de production ! L'environnement de production ne fonctionne pas comme l'environnement de développement : il ne vide jamais le cache tout seul, jamais !
			 

				Les mises à jour de la base de données

					Un dernier mot pour vous parler de la mise à jour de votre base de données. En effet, mettre à jour le code est très simple, ce sont des fichiers textes, on peut les mettre à jour facilement, revenir en arrière, etc. En ce qui concerne la base de données c'est un peu plus compliqué : il faut faire très attention aux données que vous avez déjà. Vous ne pouvez pas vous permettre de perdre des données lors d'une mise à jour !

					C'est pour cela que la commande doctrine:schema:update est à bannir. Par contre, il existe une bibliothèque pour Doctrine appelée DoctrineMigration et bien sûr son bundle correspondant. Je ne détaillerai pas son utilisation ici, mais l'idée est la suivante :

						Lorsque vous modifiez ou ajoutez une entité, vous créez en même temps un fichier de migration ;
			
						Le fichier de migration reflète les changements que vous avez effectués : il contient les requêtes SQL (du SQL pur, pas du DQL !) permettant de mettre à jour la base de données pour coller à vos changements. Il contient les deux sens : pour mettre à jour (ajout d'une colonne par exemple), et pour annuler la mise à jour (suppression de la nouvelle colonne) ;
			
						Lorsque vous envoyez vos fichiers sur votre serveur de production, vous exécutez alors tous les fichiers de migrations depuis la dernière mise en production : votre base de données sur le serveur est alors bien synchronisée avec votre code !
			
					Les fichiers de migrations sont automatiquement exécutés par Capifony lors des mises en production, une raison de plus pour utiliser ces deux outils !

				Une checklist pour vos déploiements

					Vous n'êtes pas sûr d'avoir pensé à tout avant de lancer définitivement votre site en ligne ? Pour cela, j'ai créé un site (avec Symfony !) contenant une liste de points à vérifier impérativement avant de vous lancer, il s'agit de symfony2-checklist.com. Servez vous en pour être serein lors de vos mises en ligne !

					Vous pensez qu'il manque un point ? Le contenu de la liste est hébergé sur Github, c'est-à-dire que tout le monde peut participer et ajouter les points qu'il pense important ! N'hésitez pas si vous avez des idées ;)

			En résumé

				Avant tout déploiement, préparez bien votre application en local.
				
				N'oubliez pas de personnaliser les pages d'erreur, d'installer une console via navigateur si vous êtes en hébergement mutualisé, et de vider le cache.
				
				Vérifiez la configuration de votre serveur, et adaptez-la si nécessaire.
				
				Envoyez tous vos fichiers sur le serveur, et assurez-vous d'avoir de belles URL grâce aux.htaccessou à un VirtualHost.
				
				C'est tout bon ! ;)
				
				Ce cours sur Symfony touche à sa fin. Mais vos développements ne font que commencer ! Symfony évolue beaucoup, la communauté ajoute sans cesse des nouvelles fonctionnalités, des nouveaux bundles, prenez le temps de rester au courant et d'être curieux sur ce que Symfony peut vous apporter. Si, grâce à ce cours, vous avez vu le plus important sur Symfony, il reste encore beaucoup à apprendre ! 

				Maintenant que vous avez pris en main le framework, n'hésitez pas à rejoindre la grande communauté des développeurs Symfony en vous inscrivant sur SensioLabsConnect !
				
				Bon apprentissage et surtout, bon développement !
			
		
		 Quiz : Quiz 5
					
















> Sommaire :
	
	Partie 1 - Vue d'ensemble de Symfony
	
	1. Symfony, un framework PHP
		- Installation 
			- par composer
			- par installeur Symfony
		- Configurer 
			- les permissions d’écriture
				- chmod +a
				- les ACL
			- les variables globales
				- app/config/parameters.yml
				- app/config/config.yml
		- Test Symfony 3
	2. Vous avez dit Symfony ?
		- L'architecture des fichiers
		- Le contrôleur frontal
	3. Utilisons la console pour créer un bundle
		- La structure d'un bundle
		- Créons notre bundle avec la console
		- Test du bundle et correction de bugs
		- Vider le cache
	4. Aux origines de Symfony (interview)
		- 
		
	 Quiz : Quiz 1
	
	Partie 2 - Les bases de Symfony
	
	1. Mon premier « Hello World ! » avec Symfony
		- Créons notre route
		- Créons notre contrôleur
		- Créons notre twig
	2. Le routeur de Symfony
		- Le fonctionnement
		- Les routes avancées
			- dans le router du bundle
			- dans le controller
			- dans le router principal pour ajouter un préfixe lors de l'import de nos routes
		- Générer des URL
			- depuis le contrôleur
				- $url = $this->get('router')->generate('oc_platform_home');
				- $url = $this->generateUrl('oc_platform_home');
			- depuis une vue Twig
				- {{ path('oc_platform_view', { 'id': advert_id }) }}
	3. Les contrôleurs avec Symfony
		- Le rôle du contrôleur
			- manipuler l'objet Request
				- récupérer
					- Variables d'URL 			$_GET 				$request->query->get('tag')
					- Variables de formulaire 	$_POST 				$request->request->get('tag')
					- Variables de cookie 		$_COOKIE 			$request->cookies->get('tag')
					- Variables de serveur 		$_SERVER 			$request->server->get('REQUEST_URI')
					- Variables d'entête 		$_SERVER['HTTP_*'] 	$request->headers->get('USER_AGENT')
					- Paramètres de route 		n/a 				$request->attributes->get('id')
					- Méthode de la requête HTTP 					$request->isMethod('POST')
					- Type de requête AJAX 			 				$request->isXmlHttpRequest()
			- manipuler l'objet Reponse
				- retourner un simple message avec en-tête
					- $response = new Response();
					- $response->setContent("Ceci est une page d'erreur 404");
					- $response->setStatusCode(Response::HTTP_NOT_FOUND);
					- return $response;
				- retourner une vue
					- return $this->get('templating')->renderResponse(
						  'OCPlatformBundle:Advert:view.html.twig',
						  array('id'  => $id, 'tag' => $tag)
						);
					- return $this->render('OCPlatformBundle:Advert:view.html.twig', array(
						  'id'  => $id,
						  'tag' => $tag,
						));
				- retourner une réponse et redirection
					- $url = $this->get('router')->generate('oc_platform_home');
						return new RedirectResponse($url);
					- $url = $this->get('router')->generate('oc_platform_home');
						return $this->redirect($url);
					- return $this->redirectToRoute('oc_platform_home');
				- changer le content-type de la réponse
					- $response = new Response(json_encode(array('id' => $id)));
						$response->headers->set('Content-Type', 'application/json');
					- return new JsonResponse(array('id' => $id));
			- manipuler la session
				- $session = $request->getSession();
				- $userId = $session->get('user_id');
				- $session->set('user_id', 91);
				- $session->getFlashBag()->add('info', 'Annonce bien enregistrée');
				$session->getFlashBag()->add('info', 'Oui oui, elle est bien enregistrée !');
					- {% for message in app.session.flashbag.get('info') %}
	4. Le moteur de templates Twig
		- Afficher des variables
			- enregistrés des variables globales de twig: de config.yml
		- Structures de contrôle et expressions
			- Condition : {% if %}
			- Boucle : {% for %}
			- Définition : {% set %}
			- Tests
				- Defined : {% if var is defined %}
				- Even / Odd : {% if loop.index is even %}
		- Hériter et inclure des templates
			- hériter
				- template père
					- {% block title %}OC Plateforme{% endblock %}
					- {% block body %}{% endblock %}
				- templates fils
					- {% extends "OCPlatformBundle::layout.html.twig" %}
					- {% block title %}{{ parent() }} - Index{% endblock %}
					- {% block body %}
						  Notre plateforme est un peu vide pour le moment, mais cela viendra !
						{% endblock %}
			- inclusion dans les templates fils à appeler de contrôleurs
				- de templates
					- {{ include("OCPlatformBundle:Advert:form.html.twig") }}
				- de contrôleurs
					- {{ render(controller("OCPlatformBundle:Advert:menu")) }}
	5. Installer un bundle grâce à Composer
		- Installer Composer et Git
		- Installer un bundle grâce à Composer
			- Mettre à jour les dépendances et Symfony
			- Installer un bundle
				- 1. Trouver le nom du bundle
				- 2. Déterminer la version du bundle
				- 3. Déclarer le bundle à Composer
				- 4. Mettre à jour les dépendances
				- 5. Enregistrer le bundle dans le Kernel
			- Gérer l'autoload d'une bibliothèque manuellement (notamment d'un projet perso)
	6. Les services, théorie et création
		- Pourquoi utiliser des services ?
			- Qu'est-ce qu'un service ?
			- L'avantage de la programmation orientée services
				- https://fr.wikipedia.org/wiki/Architecture_orient%C3%A9e_services
			- Le conteneur de services
			- Comment définir les dépendances entre services ?
			- Le partage des services
		- Utiliser un service en pratique
			- Récupérer un service
				- Depuis un contrôleur
					- $mailer = $this->container->get('mailer');
						$antispam = $this->container->get('oc_platform.antispam');
			- Créer un service simple
				- de la classe du service
					- dans /Services du bundle
				- de la configuration du service
					- déclaration du service
						- dans /services.yml du bundle
					- création de l'injecteur du service
						- dans /DependencyInjection du bundle avec un fichier en OcPlatformBundleExtension.php
		
	 Quiz : Quiz 2
	
	 Activité : Créez votre CoreBundle pour les gouverner tous
		
		objet : créer un CoreBundle qui, nullement réutilisable entre vos projets, vient faire la glue entre tous les autres bundles utilisés, en contenant tous les éléments transversaux à l'application (mains routes, contrôler, entities modèles ($commande->getPrixTotal()), repositories, frame twig, ...).
	
	Partie 3 - Gérer la base de données avec Doctrine2
	
	1. La couche métier : les entités
		- Générer une entité : le générateur à la rescousse !
			- php bin/console doctrine:database:create
			- php bin/console doctrine:generate:entity sans les annotations
				- définir le nom de la table et les attributs avec les annotations
					- @Var string
					- @ORM\Column(name="url", type="string", length=255)
	2. Manipuler ses entités avec Doctrine2
		- Matérialiser les tables en base de données
			- php bin/console doctrine:schema:update --dump-sql
			- php bin/console doctrine:schema:update --force
		- Modifier une entité (ou définir les setters et les getters)
			- php bin/console doctrine:generate:entities OCPlatformBundle:Advert
		- Enregistrer ses entités avec l'EntityManager
			- Les services Doctrine2
				- récupérer du controller
					- $doctrine = $this->get('doctrine');
					- $doctrine = $this->getDoctrine();
				- permet de récupérer et gérer
					- différents BDD par le DBAL de Doctrine2
						- $doctrine->getConnection($name)
					- différents gestionnaires d'entités ou EntityManager
						- $doctrine->getManager($name) (sans argument EntityManager par défaut)
					- différents repositories
						- $advertRepository = $em->getRepository('OCPlatformBundle:Advert');
						- $advertRepository = $em->getRepository('OC\PlatformBundle\Entity\Advert');
					- de enregistrer ses entités en base de données
						- $advert = new Advert();
						- $advert->setTitle('Recherche développeur Symfony.');
						- ...
						- $em->persist($advert);
						- $em->flush();
					- de récupérer ses entités avec un Repository
						- $advert = $repository->find($id);
							- méthode classique
								- findAll()
								- findBy()
								- findOneBy()
							- méthode magique
								- findByX($valeur)
									- en remplaçant « X » par le nom d'une propriété de votre entité
								- findOneByX($valeur)
									- en remplaçant « X » par le nom d'une propriété de votre entité.
					- la modification d'entités enregistrées en base de données
						- $advert2 = $em->getRepository('OCPlatformBundle:Advert')->find(5);
						- $advert2->setDate(new \Datetime());
						- ...
						- $em->flush();
					- de gérer avec des commandes l'enregistrements
						- $em->detach($advert);
						- $em->clear();
						- $em->contains($advert);
						- $em->refresh($advert);
						- $em->remove($advert);
	3. Les relations entre entités avec Doctrine2
		- Présentation
			- Les différents types de relations
				- OneToOne, OneToMany et ManyToMany
			- Notions techniques d'ORM à savoir
				- Notion de propriétaire et d'inverse
				- Notion d'unidirectionnalité et de bidirectionnalité
		- Relation One-To-One
			- Entité propriétaire
				- @ORM\OneToOne(targetEntity="OC\PlatformBundle\Entity\Image", cascade={"persist"})
			- Entité inverse (n'a aucune information sur toute relation)
				- Nul besoin d'ajouter une propriété ici
			- Rendre une relation non-facultative
				- @ORM\JoinColumn(nullable=false)
		- Relation Many-To-One
			- Entité propriétaire
				- @ORM\ManyToOne(targetEntity="OC\PlatformBundle\Entity\Advert")
			- Entité inverse
				- Nul besoin de rajouter de propriété, ici
			- Rendre une relation non-facultative
				- @ORM\JoinColumn(nullable=false)
			- Appelle dans le contrôler
				- $listApplications = $em
				  ->getRepository('OCPlatformBundle:Application')
				  ->findBy(array('advert' => $advert));
		- Relation Many-To-Many (création automatique de la table intermédiaire)
			- Entité propriétaire
				- @ORM\ManyToMany(targetEntity="OC\PlatformBundle\Entity\Category", cascade={"persist"})
					@ORM\JoinTable(name="oc_advert_category") // Permet de changer le nom
				- dans le constructeur et setter / getter
					- public function __construct()
						  {
							$this->date       = new \Datetime();
							$this->categories = new ArrayCollection();
						  }
					- public function addCategory(Category $category)
						  {
							// Ici, on utilise l'ArrayCollection vraiment comme un tableau
							$this->categories[] = $category;
						  }

					- public function removeCategory(Category $category)
						  {
							// Ici on utilise une méthode de l'ArrayCollection, pour supprimer la catégorie en argument
							$this->categories->removeElement($category);
						  }
			- Entité inverse
				- Nul besoin d'ajouter une propriété ici
			- Fixture
				- Remplissons la base de données avec les fixtures
					- DataFixtures/ORM/Load_.php
					- php app/console help doctrine:fixtures:load
					- php bin/console doctrine:fixtures:load --fixtures=src/OcUserBundle/DataFixtures/ORM --append
			- Appelle dans le contrôler
				- $listCategories = $em->getRepository('OCPlatformBundle:Category')->findAll();
				// On boucle sur les catégories pour les lier à l'annonce
				foreach ($listCategories as $category) {
				  $advert->addCategory($category);
				}
			- Affichage dans le twig
				- {% if not advert.categories.empty %}
					  <p>
						Cette annonce est parue dans les catégories suivantes :
						{% for category in advert.categories %}
						  {{ category.name }}{% if not loop.last %}, {% endif %}
						{% endfor %}
					  </p>
					{% endif %}
		- Relation Many-To-Many avec attributs (création manuel de l'entité de la table intermédiaire AdvertSkill propriétaire des deux relations)
			- Création manuelle de l'entité propriétaire
				- créer les attributs de liaison
					- @ORM\ManyToOne(targetEntity="OC\PlatformBundle\Entity\Advert")
					 @ORM\JoinColumn(nullable=false)
					- @ORM\ManyToOne(targetEntity="OC\PlatformBundle\Entity\Skill")
					 @ORM\JoinColumn(nullable=false)
				- créer l'attribut
					- @ORM\Column(name="level", type="string", length=255)
			- Appelle dans le contrôler
				- $listAdvertSkills = $em
				  ->getRepository('OCPlatformBundle:AdvertSkill')
				  ->findBy(array('advert' => $advert));
			- Affichage dans le twig
				- {% if listAdvertSkills|length > 0 %}
					  <div>
						Cette annonce requiert les compétences suivantes :
						<ul>
						  {% for advertSkill in listAdvertSkills %}
							<li>{{ advertSkill.skill.name }} : niveau {{ advertSkill.level }}</li>
						  {% endfor %}
						</ul>
					  </div>
					{% endif %}
		- Relations bidirectionnelles (exemple avec Many-To-One)
			- la méthode est exactement la même pour les relations de type One-To-One ou Many-To-Many.
			- Entité inverse
				- @ORM\OneToMany(targetEntity="OC\PlatformBundle\Entity\Application", mappedBy="advert") // Dont le nom de l'attribut est au pluriel !!!!!
			- Enitié propriétaire
				- @ORM\ManyToOne(targetEntity="OC\PlatformBundle\Entity\Advert", inversedBy="applications")
				@ORM\JoinColumn(nullable=false)
				- dans le constructeur et setter / getter
					- public function __construct()
					  {
						$this->applications = new ArrayCollection();
					  }
					- public function addApplication(Application $application)
					  {
						$this->applications[] = $application;

						// On lie l'annonce à la candidature <<<<<<<<< !!!!!!!!!!!!!
						$application->setAdvert($this);
					  }

					  public function removeApplication(Application $application)
					  {
						$this->applications->removeElement($application);
						
						// Et si notre relation était facultative (nullable=true, ce qui n'est pas notre cas ici attention) :        
						// $application->setAdvert(null);
					  }

					  public function getApplications()
					  {
						return $this->applications;
					  }
					
	4. Récupérer ses entités avec Doctrine2
		- Deux façons pour construire vos requêtes de récupération des entités
			- Le Doctrine Query Language (DQL)
				- public function myFindAllDQL()
				{
				  $query = $this->_em->createQuery('SELECT a FROM OCPlatformBundle:Advert a');
				  $results = $query->getResult();

				  return $results;
				}
			- Le QueryBuilder
				- public function findByAuthorAndDate($author, $year)
				{
				  $qb = $this->createQueryBuilder('a');

				  $qb->where('a.author = :author')
					   ->setParameter('author', $author)
					 ->andWhere('a.date < :year')
					   ->setParameter('year', $year)
					 ->orderBy('a.date', 'DESC')
				  ;

				  return $qb
					->getQuery()
					->getResult()
				  ;
				}
			- La Query
				- getResult()
				- getArrayResult()
				- getScalarResult()
				- getOneOrNullResult()
				- getSingleResult()
				- getSingleScalarResult()
				- execute()
				- $qb->where($qb->expr()->in('c.name', $categoryNames));
				- $qb->setMaxResults($limit);
	5. Les évènements et extensions Doctrine
		- Les évènements Doctrine
		- Définir des callbacks de cycle de vie
			- 1. Définir l'entité comme contenant des callbacks
				- @ORM\HasLifecycleCallbacks() // sur l'annotation de la class
			- 2. Définir un callback et ses évènements associés
				- 	/**
					 * @ORM\PreUpdate
					 */
					public function updateDate()
					{
						$this->setUpdateAt(new \Datetime());
					}

					/**
					 * Set updateAt
					 *
					 * @param \DateTime $updateAt
					 *
					 * @return Advert
					 */
					public function setUpdateAt($updateAt)
					{
						$this->updateAt = $updateAt;

						return $this;
					}
		- Liste des évènements de cycle de vie
			- PrePersist
			- PostPersist
			- PreUpdate
			- PostUpdate
			- PreRemove
			- PostRemove
			- PostLoad
		- Utiliser des services pour écouter les évènements Doctrine
			- créer la class du service et le service 
			- créer l'injecteur du conteneur de service si non créé
			- créer le service callback
				- /DoctrineListener/ApplicationCreationListener.php
					- avec pour nom de méthodes les événements que nous allons écouter
						- public function postPersist(LifecycleEventArgs $args){ ... }
							- $args->getObject();			// retourne l'entité sur laquelle l'évènement est en train de se produire
							- $args->getObjectManager();	// retourne l'EntityManager nécessaire pour persister ou supprimer de nouvelles entités que vous pourriez gérer
			- créer le service
				- oc_platform.doctrine_listener.application_creation:
					class: OC\PlatformBundle\DoctrineListener\ApplicationCreationListener
					arguments:
					  - "@oc_platform.email.application_mailer"
					tags:
					  - { name: doctrine.event_listener, event: postPersist }
					  - { name: doctrine.event_listener, event: preUpdate }
			- Installer le StofDoctrineExtensionBundle
				- rajoutez cette dépendance dans votrecomposer.json  et exécutez uncomposer update
				- enregistrer le bundle dans le noyau
				- activer l'extension Sluggable, configurer app/config/config.yml
				- l'utilisation des extensions se fait grâce à de judicieuses annotations.
					- use Gedmo\Mapping\Annotation as Gedmo;
					- @Gedmo\Slug(fields={"title"}) // sur le champs $slug qui sera automatiquement rempli
			- Liste des extensions Doctrine
				- Tree
				- Translatable
				- Sluggable
				- Timestampable
				- Blameable
				- Loggable
				- Sortable
				- Softdeleteable
				- Uploadable
				- IpTraceable
	6. TP : Consolidation de notre code
		- Adaptation du contrôleur
		- Utilisation des jointures
		- Pagination des annonces sur la page d'accueil
			- objet Paginator de Doctrine à intégrer dans le répository à afficher
			- à appeler du contrôleur
			- à afficher dans le rwig
		
	 Quiz : Quiz 3
	 
	 Activité : Créer un système pour nettoyer vos entités
		
		- Ecrire un service que nous appellerons “oc_platform.purger.advert”. Ce service va récupérer et supprimer toutes les annonces dont la date de modification est plus vieille que X jours. Ce “X” doit être un paramètre de la méthode de votre service.
		Attention également à ne pas supprimer des annonces ayant au moins une candidature.
		
		
	Partie 4 - Allons plus loin avec Symfony
	
	1. Créer des formulaires avec Symfony
		- Gestion des formulaires
			- Gestion basique d'un formulaire
				- du contrôler à partir de l'entité Doctrine créer une formBuilder
					- si création
						- $advert = new Advert;
					- si modification
						- $advert = $this->getDoctrine()
						  ->getManager()
						  ->getRepository('OCPlatformBundle:Advert')
						  ->find($id);
					- $formBuilder = $this->get('form.factory')->createBuilder(FormType::class, $advert);
				- ajouter les champs de l'entité que l'on veut à notre formulaire sans oublier les uses
					- $formBuilder
					  ->add('date',      DateType::class)
					  ->add('title',     TextType::class)
					  ->add('content',   TextareaType::class)
					  ->add('author',    TextType::class)
					  ->add('published', CheckboxType::class)
					  ->add('save',      SubmitType::class)
					;
						- $formBuilder->add('published', CheckboxType::class, array('required' => false))
					- les types standards
						- https://symfony.com/doc/current/reference/forms/types.html
					- les types EntityType
						- permet de sélectionner des entités
						- $builder
							  ->add('categories', EntityType::class, array(
								'class'        => 'OCPlatformBundle:Category',
								'choice_label' => 'name',
								'multiple'     => true,
							  ));
						- options du type de champ
							- choice_label spécifie le champs que l'on veut lister
								- existe aussi display (ou autre !)
							- multiple sélectionner une ou plusieurs entités
								- suivant les valeur boolean de ces variables, on aura soit un sélect, soit des bouton radio, soit des checkbox
							- option query_builder
								- dans le répositorie en question 
									- public function getLikeQueryBuilder($pattern)
									  {
										return $this
										  ->createQueryBuilder('c')
										  ->where('c.name LIKE :pattern')
										  ->setParameter('pattern', $pattern)
										;
									  }
								 - dans le AdvertType
									- ->add('categories', EntityType::class, array(
											'class'         => 'OCPlatformBundle:Category',
											'choice_label'  => 'name',
											'multiple'      => true,
											'query_builder' => function(CategoryRepository $repository) use($pattern) {
											  return $repository->getLikeQueryBuilder($pattern);
											}
										  ))
					- le type de champ File pour envoyer des fichiers
						- préparer l'objet sous-jacent Entity/Image en ajoutant $file
							public function getFile()
						  {
							return $this->file;
						  }

						  public function setFile(UploadedFile $file = null)
						  {
							$this->file = $file;
						  }
						- adapter le formulaire ImageType
							->add('file', FileType::class)
						- manipuler le fichier envoyé
							- adapter Entity/Image avec des événements doctrines
							- ajouter une méthode formatant le chemin du fichier de la vue
							- adapter le vue
					- les types d'entités liées
						- formulaires imbriqués voir plus bas 
				- génèrer le formulaire
					- $form = $formBuilder->getForm();
				- passer la méthode createView() du formulaire à la vue
					- return $this->render('OCPlatformBundle:Advert:add.html.twig', array(
					  'form' => $form->createView(),
					));
				- afficher le form dans le twig
					- pré-configuré
						- <h3>Formulaire d'annonce</h3>
						<div class="well">
						  {{ form(form) }}
						</div>
					- suivant des besoins
						- https://symfony.com/doc/current/form/form_customization.html
							- form_start
							- form_label
							- form_row | form_widget
							- form_errors
							- form_rest // champ CSRF + champs cachés
							- form_end
			- Gestion de la soumission d'un formulaire
				- pour la gestion du formulaire envoyé a la même méthode du controler l'ayant initié, après avoir créer l'objet $form avec la méthode creatBuilder et l'entité de référence et avant le retour de la vue contenant le formulaire, insérer le code de validation des données et de traitement
					- if ($request->isMethod('POST') && $form->handleRequest($request)->isValid()){
					// On enregistre notre objet $advert dans la base de données, par exemple
					$em = $this->getDoctrine()->getManager();
					$em->persist($advert);
					$em->flush();

					$request->getSession()->getFlashBag()->add('notice', 'Annonce bien enregistrée.');

					// On redirige vers la page de visualisation de l'annonce nouvellement créée
					return $this->redirectToRoute('oc_platform_view', array('id' => $advert->getId()));
					}
			- Personnaliser l'affichage d'un formulaire
				- # app/config/config.yml
						twig:
							form_themes:
								- 'bootstrap_3_layout.html.twig'
			- Externaliser la définition de ses formulaires
				- Définition du formulaire dansAdvertType
					- php bin/console doctrine:generate:form OCPlatformBundle:Advert
					- supprimer les champs inutiles
					- rééditer le contrôler
						- $form = $this->get('form.factory')->create(AdvertType::class, $advert);
		- Les formulaires imbriqués
			- très utiles quand on a des entités liées (ex. Annonce avec image)
				- php bin/console doctrine:generate:form OCPlatformBundle:Image
				- formater les champs dont on besoins
			- Relation simple : imbriquer un seul formulaire
				- dans le builder de la class AdvertType créer la liaison
					- ->add('image',     ImageType::class, array('required' => false))
					- générés par la fonction form_rest(), l'ordre des champs peut varier, il faut donc les afficher manuellement
			- Relation multiple : imbriquer un même formulaire plusieurs fois
				- On imbrique un même formulaire plusieurs fois lorsque deux entités sont en relation Many-To-One ou Many-To-Many
				- php bin/console doctrine:generate:form OCPlatformBundle:Category
				- supprimer les champs inutiles
				- dans AdvertType
					- /*
					   * Rappel :
					   ** - 1er argument : nom du champ, ici « categories », car c'est le nom de l'attribut
					   ** - 2e argument : type du champ, ici « CollectionType » qui est une liste de quelque chose
					   ** - 3e argument : tableau d'options du champ
					   */
					  ->add('categories', CollectionType::class, array(
						'entry_type'   => CategoryType::class,
						'allow_add'    => true,
						'allow_delete' => true
					  ))
				- puis dans le twig, en analysant le html du champs, éditer du js pour pouvoir en ajouter à l'infini, et même en supprimer suivant les besoins
			- L'héritage de formulaire
				- dans le cas où on voudrait ne faire qu'une modification d'une entité d'un formulaire déjà existant
					- Copiez-collez le fichierAdvertType.phpet renommez la copie enAdvertEditType.php; en renommer les éléments
					- Remplacez la définition manuelle de tous les champs (les$builder->add()) par une simple ligne pour supprimer le champ date: $builder->remove('date') ;
					- Ajouter une méthodegetParent  qui retourne la classe du formulaire parent,AdvertType::class  ;
						- public function buildForm(FormBuilderInterface $builder, array $options)
							  {
								$builder->remove('date');
							  }

						  public function getParent()
						  {
							return AdvertType::class;
						  }
					- si je veux utiliser le même twig pour l'ajout et la modification, n'ayant plus le champs date, j'aurai une erreur
						- {% if form.date is defined %}
			- Construire un formulaire différemment selon des paramètres
				- contrainte
					- Si l'annonce n'est pas encore publiée, on peut modifier sa valeur de publication lorsqu'on modifie l'annonce;
					- Si l'annonce est déjà publiée, on ne peut plus modifier sa valeur de publication lorsqu'on modifie l'annonce.
				- code dans le AdvertType avec les uses
					- // Ajoutez ici tous vos champs sauf le champ published
					$builder = ...;

					// On ajoute une fonction qui va écouter un évènement
					$builder->addEventListener(
					  FormEvents::PRE_SET_DATA,    // 1er argument : L'évènement qui nous intéresse : ici, PRE_SET_DATA - paramètre d'événement du Form pas de Doctrine
					  function(FormEvent $event) { // 2e argument : La fonction à exécuter lorsque l'évènement est déclenché
						// On récupère notre objet Advert sous-jacent
						$advert = $event->getData();

						// Cette condition est importante, on en reparle plus loin
						if (null === $advert) {
						  return; // On sort de la fonction sans rien faire lorsque $advert vaut null
						}

						// Si l'annonce n'est pas publiée, ou si elle n'existe pas encore en base (id est null)
						if (!$advert->getPublished() || null === $advert->getId()) {
						  // Alors on ajoute le champ published
						  $event->getForm()->add('published', CheckboxType::class, array('required' => false));
						} else {
						  // Sinon, on le supprime
						  $event->getForm()->remove('published');
						}
					  }
	2. Validez vos données
		- Le composant validation est indépendant de celui du Form
			- on peut donc l'utiliser pour valider tout entités !!!!!!!!!!!
				- Le service Validator
		- Définir les règles de validation
			- use Symfony\Component\Validator\Constraints as Assert;
			- @Assert\Contrainte(option1="valeur1", option2="valeur2", …)
				- Contraintes de base
				- Contraintes sur des chaînes de caractères
				- Contraintes sur les nombres
				- Contraintes sur les dates
				- Contraintes sur les fichiers
			- Valider depuis 
				- un attribut
				- un champ unique
				- selon nos propres contraintes
					- par annotation sur l'attribut d'une contrainte appelant un service
						- AntifloodValidator->validate();
						- méthode isFlood() du répository
				- un getter
				- un Callback
		- La validation automatique sur les formulaires
			- dans le contrôler
				- if ($form->handleRequest($request)->isValid()) {
				  // ...
				}
	3. Sécurité et gestion des utilisateurs
		- Processus général depuis le security.yml
			- Un utilisateur veut accéder à une ressource protégée ;
			- Le firewall redirige l'utilisateur au formulaire de connexion ;
			- L'utilisateur soumet ses informations d'identification (par exemple login et mot de passe) ;
			- Le firewall authentifie l'utilisateur ;
			- L'utilisateur authentifié renvoie la requête initiale ;
			- Le contrôle d'accès vérifie les droits de l'utilisateur, et autorise ou non l'accès à la ressource protégée.
		- Le fichier de configuration de la sécurité
			- Section encoders
			- Section role_hierarchy
			- Section providers
			- Section firewalls
			- Section access_control
		- Cas de l'authentification par formulaire (non http)
			- d'utilisateur en in_memory
				- Première approche de la sécurité
					- définir la Section encoders
					- définir la Section role_hierarchy
					- définir la Section providers
					- définir la Section firewalls
					- définir la Section access_control
				- Mettre en place un pare-feu
					- Créer le pare-feu
					- Définir une méthode d'authentification pour le pare-feu
					- Définir les trois routes
				- Créer le bundle OCUserBundle
					- php bin/console generate:bundle
					- supprimer les éléments non nécessaire
				- Créer le formulaire de connexion du bundle
					- créer le contrôler avec la méthode
					- créer la vue
				- Les erreurs courantes
					- Ne pas oublier la définition des routes
					- Les pare-feu ne partagent pas
					- Bien mettre/login_checkderrière le pare-feu
					- Ne pas sécuriser le formulaire de connexion
				- Récupérer l'utilisateur courant
					- Depuis le contrôleur avec un service
					- Depuis une vue
				- Gestion des autorisations avec les rôles
					- Définition des rôles
					- Tester les rôles
						- depuis le contrôleur
							- if (!$this->get('security.authorization_checker')->isGranted('ROLE_AUTEUR')) {
							  // Sinon on déclenche une exception « Accès interdit »
							  throw new AccessDeniedException('Accès limité aux auteurs.');
							}
						- Utiliser les annotations
							- par méthode @Security("has_role('ROLE_AUTEUR') and has_role('ROLE_AUTRE')") // voir IS_AUTHENTICATED_REMEMBERED ou IS_AUTHENTICATED_ANONYMOUSLY
						- Depuis une vue
							- {% if is_granted('ROLE_AUTEUR') %}
							  <li><a href="{{ path('oc_platform_add') }}">Ajouter une annonce</a></li>
							{% endif %}
					- Utiliser les contrôles d'accès
						- access_control:
							- { path: ^/admin, roles: ROLE_ADMIN, ip: 127.0.0.1, requires_channel: https }
			- d'utilisateur en base avec notre bundle OCUserBundle
				- créer la classe d'utilisateurs Doctrine
					- implémenter l'interface UserInterface
				- créer quelques utilisateurs de test en base 
					- sans l'encodage du mot de passe ni la définition du salt
				- définir les paramètres de la sécurité
					- définir la Section encoders
					- définir la Section providers (entité + attribut d'identifiant)
					- définir la Section firewalls
			- d'utilisateur en base avec surcharge de notre bundle par le bundle FOSUserBundle
				- Installation de FOSUserBundle
				- Activer le bundle
				- Hériter FOSUserBundle depuis notre OCUserBundle
				- Modifier notre entité User
				- Configurer le bundle
				- Mise à jour de la table User
				- Configuration de la sécurité
					- L'encodeur
					- Le fournisseur
					- Le pare-feu
				- Ajout des utilisateurs à notre base de données
					- php bin/console fos:user:create
				- Configuration du bundle FOSUserBundle
					- Configuration des routes
						- dans routing.yml
						- dans security.yml
							- php bin/console debug:router
				- Personnalisation esthétique du bundle
					- Créer la vue
					- Traduire les messages
					- Afficher une barre utilisateur
				- Manipuler les utilisateurs avec FOSUserBundle
					- avec les routes prédéfinit du bundle
					- avec nos propres contrôleurs
	4. Les services, utilisation poussée
		- Les tags sur les services
			- permet de regrouper des services à un composant
			- Appliquer un tag à un service
				- créer la classe du service prenant en paramètre d'autres services implémentant l'interfase de liaison cu composant ici twig
				- créer le service lié par le tag au composant twig
				- tester le tag
					- php bin/console debug:container --tag=twig.extension
			- Les principaux tags
				- exemple d'ajout de ckeditor à TextareaType du Form
				- voir plus bas
		- Dépendances optionnelles : les appels de méthodes (ou calls en anglais)
			- Les dépendances optionnelles
			- Les calls
				- comme un use de fonction mais pour les services
				- l'utilité des calls est également remarquable pour l'intégration des bibliothèques externes (Zend Framework, GeSHI, etc.), qui ont besoin d'exécuter quelques méthodes en plus du constructeur
		- Les services courants de Symfony
			- doctrine.orm.entity_manager
			- event_dispatcher
			- kernel
			- logger
			- mailer
			- request_stack
			- router
			- security.token_storage
			- service_container
			- twig
			- templating
	5. Le gestionnaire d'évènements de Symfony
		- Qu'est-ce que le gestionnaire d'évènements ?
			- Dans un premier temps, des services se font connaître du gestionnaire d'évènements pour écouter tel ou tel évènement. Ils deviennent des listeners ;
			- Dans un deuxième temps, quelqu'un (qui que ce soit) déclenche un évènement, c'est-à-dire qu'il prévient le gestionnaire d'évènements qu'un certain évènement vient de se produire. À partir de là, le gestionnaire d'évènement exécute chaque service qui s'est préalablement inscrit pour écouter cet évènement précis.
			- Le mantra à garder en tête : « 1 service = 1 fonction » !
		- Métodologie
			- en plus des simples tags 
				- ajoutant / regroupant des fonctions à des / de  services ou / et composants
					 - exécutable dans leur contexte de réalisation
			- on peut automatiser des fonctions par le gestionnaire d'évènements
				- des évènements standardisés de composants de l'appli ou / et de(s) bundle(s)
					 - des services 
						 - d'une class du listener exécutant la fonction générique en dernière instance
						 - d'une class listener exécutant la fonction process_ formatant les class des événements reçus
							 - dont pour la class du listener
								 - tags de liaison à l'évènement du composant qui doit procéder à la fonction
								 - event à écouter et sur lequel réagir et récupérant la class de l'evénement du composant
								 - method à exécuter de la class du listener
				- de nos événements définit
					 - du service event_dispatcher dans le contrôler, peut se produire après l'evènement
						 - d'une class des noms des événements déclancheurs
						 - d'une class de l'evénement, de fonctions à réaliser, associé à l'évènement
					 - déclanchant
						 - des services 
							 - d'une class du listener exécutant la fonction générique en dernière instance
							 - d'une class listener exécutant la fonction process_ formatant les class des événements reçus
								 - dont pour la class du listener
									 - tags de liaison à l'évènement du composant qui doit procéder à la fonction 
									 - event à écouter et sur lequel réagir et récupérant la class de l'evénement passé en paramètre
									 - method à exécuter de la class du listener
		- Les souscripteurs d'évènements
			- Assez semblables aux listeners, au lieu d'écouter toujours le même évènement défini dans un fichier de configuration, un souscripteur peut écouter dynamiquement un ou plusieurs évènements
			- Implémenter l'interfase EventSubscriberInterface au listener et son unique méthode 
				// La méthode de l'interface que l'on doit implémenter, à définir en static
				  static public function getSubscribedEvents()
				  {
					// On retourne un tableau « nom de l'évènement » => « méthode à exécuter »
					return array(
					  PlatformEvents::POST_MESSAGE    => 'processMessage',
					  PlatformEvents::AUTRE_EVENEMENT => 'autreMethode',
					  // ...
					);
				  }
			- L'ordre d'exécution des listeners
				- permettant de stopper la propagation d'un évènement
				- depuis
					- les tags du service listener
						- - { name: kernel.event_listener, event: kernel.response, method: processBeta, priority: 2 }
					- un souscripteur
						- PlatformEvents::POST_MESSAGE => array('processMessage' => 2)
			- La propagation des évènements
				- dans une méthode process_ du listener définir
					- $event->stopPropagation(); pour arrêter la propagation
					- $event->isPropagationStopped(); pour tester l'arrêt de la propagation
					d'où les autres événements / listeners ne seront pas écoutés /exécutés
	6. Traduire son site
		- Introduction à la traduction
			- La traduction est un processus qui doit se faire tout à la fin de la réalisation d'un site
			- Bien préparer — si ce n'est de terminer — les catalogues pour une locale, puis de les dupliquer pour les autres, et non de travailler sur toutes les locales à la fois
			- En plus de votre courage, il vous faut impérativement ces trois informations
				- Ce qu'il faut traduire ;
				- La langue dans laquelle traduire ;
					- le local
						- Ce qui est déjà traduit dans la localefr_FRvous sera retourné ;
							
						Ce qui n'est pas encore traduitenfr_FR, mais existe en « français général » (localefr) : c'est cette version qui sera envoyée ;
						
						Ce qui n'est pas du tout traduit en français, mais l'est en anglais, est affiché en anglais ;
						
						Ce qui ne possède aucune traduction est affiché tel quel, ici « site.devise ». 

						Dans ce cas, quand c'est le texte original qui est affiché, c'est que vous avez oublié la traduction de ce terme.
				- Ainsi qu'un dictionnaire si besoin.
					- la casse, tout comme les accents, sont importants
					- on ne parle pas de dictionnaire, mais de catalogue que l'on va écrire pour l'appli
			- Configuration de # app/config/config.yml
				- translator:      { fallbacks: ["%locale%"] } #langue par défaut pour le service de traduction
				- default_locale: %locale% # locale de requête
			- Crée la route dans routing_dev.yml
				- car d'une part c'est une route de test (pas destinée à nos futurs visiteurs !), et d'autre part le fichier de routes de notre bundle est préfixé par/platform qu'on ne veut pas forcément ici
				- oc_platform_translation:
				  path:     /traduction/{name}
				  defaults:
					_controller: OCPlatformBundle:Advert:translatio
			- Créer le contrôler
				- public function translationAction($name)
				  {
					return $this->render('OCPlatformBundle:Advert:translation.html.twig', array(
					  'name' => $name
					));
				  }
			- Créer la vue
				- <html>
					  <body>
						Hello {{ name }}!
					  </body>
					</html>
			- La traduction est possible
				- dans un contrôleur ou un service
					- Le servicetranslator
						- // Depuis un contrôleur

							// On récupère le service translator
							$translator = $this->get('translator');

							// Pour traduire dans la locale de l'utilisateur :
							$texteTraduit = $translator->trans('Mon message à inscrire dans les logs');
				- dans une vue, la plus conseillée
					- Le filtre Twig {{ 'string'|trans }}
						- c'est le filtre trans que l'on va utiliser, prévu pour s'appliquer sur des variables ou des courtes chaînes
							- <div>
								  <p>{{ message|trans }}</p>
								  <button>{{ 'cancel'|trans }}</button>
								  <button>{{ 'validate'|trans }}</button>
								</div>
					- La balise de bloc Twig {% trans %} que du texte… {% endtrans %}
			- Le catalogue
				- fichier enregistré dans le dossierResources/translations/du bundle
					- Les formats de catalogue (pour traduire de l'anglais au français, et non l'inverse) encoder en UTF-8 sans BOM
						- Le format XLIFF
							- messages.fr.xlf
							- format officiel, il existe des outils pour faciliter les traductions de gros catalogues pour le format XLIFF.
						- Le format YAML
							- messages.fr.yml
						- Le format PHP
							- messages.fr.php
					- La mise en cache du catalogue
						- penser à vider le cache en prod
				- créations du fichier
					- translation:update [--prefix[="..."]] [--output-format[="..."]] [--dump-messages] [--force] locale bundle
						- va lire toutes les vues du bundle spécifié, et compilera toutes les chaînes sources dans un catalogue
						- --dump-messages tient compte des messages déjà traduits, donc pas de souci que votre précédent travail soit écrasé et possiblité de changer de format
						- --forceeffectue la mise à jour des catalogues, tout en conservant une sauvegarde des versions précédentes, s'occupe automatiquement des éventuels doublons
						- --prefix="...", vous pouvez changer la partie __ de cible par ce que vous voulez
						- mais ne marche pas pour
							- toute définition dans les contrôlers
							- le contenu des variables
			- Récupérer la locale de l'utilisateur
				- Déterminer la locale
					- L'utilisateur clique sur un lien qui traduit la page sur laquelle il se trouve ; (La plupart des sites multilingues affichent la locale dans l'URL)
					- L'utilisateur envoie ses préférences dans les en-têtes des requêtes ;
					- Les paramètres par défaut.
				- Routing et locale
					- Le paramètre d'URL
						- # app/config/routing_dev.yml

							oc_platform_translation:
							  path: /{_locale}/traduction/{name}
							  defaults:
								_controller: "OCPlatformBundle:Advert:translation"
						- # app/config/routing.yml

								oc_platform:
									resource: "@OCPlatformBundle/Resources/config/routing.yml"
									prefix:   /{_locale}/platform # Ici, on ajoute {_locale} au préfixe !
								    requirements:
									  _locale: en|fr # les locales disponibles, séparées par des pipes « | »
			- Organiser vos catalogues
				- Possibilités disponibles que dans les catalogues au format YAML.
				- Utiliser des mots-clés plutôt que du texte comme chaînes sources
					- utiliser un catalogue par langue, avec aussi celui par défaut
					- d'où
						- dans un catalogue
							- site.devise: The website where you learn it all... from scratch!
						- dans la vue
							- {% trans %}site.devise{% endtrans %}
								{# ou #}
								{{ 'site.devise'|trans }}
				- Nicher les traductions
					- C'est une possibilité qui découle de l'utilisation des mots-clés.
						- de
							- advert.edit.title: Édition d'une annonce
							advert.edit.submit_button: Valider
							advert.show.edit_button: Éditer l'annonce
							advert.show.create_button: Créer une nouvelle annonce
						- on passe à 
							- advert:
								edit:
									title:         Édition d'une annonce
									submit_button: Valider
								show:
									edit_button:   Éditer l'annonce
									create_button: Créer une nouvelle annonce
						- structure
							- oc:                     # Le namespace racine que vous utilisez
								platform:             # Le nom du bundle, sans la partie Bundle
									advert :          # Le nom de l'entité ou de la section
										list: liste   # Les différents messages, pages et/ou actions
										new:  nouveau # Etc.
				- Permettre le retour à la ligne au milieu des chaînes cibles
					- Le chevron « > »
					- La pipe « | »
				- Utiliser des listes
					- Les éléments de liste sont précédés d'un tiret en YAML
					- et dans la vue
						- {% for i in 0..2 %}
							<p>{{ ('charte.donnee.' ~ i )|trans }}</p>
						{% endfor %}
				- Utiliser les domaines
					- Définition du catalogue
						- il est intéressant de regrouper les traductions par domaine
						- le domaine par défaut estmessages
						- vous pouvez donc créer autant de fichiers/domaines que vous voulez
					- Emploi du domaine
						- C'est un argument à donner à la balise, au filtre ou à la fonctiontrans, tout simplement :
						Balise :{% trans from 'domaine' %}chaîne{% endtrans %}.
						Filtre :{{ 'chaîne'|trans({}, 'domaine') }}.
						Service :$translator->trans('chaîne', array(), 'domaine')
					- Domaines et bundles
						- les domaines n'ont rien à voir avec les bundles
						- les bouts de catalogue de domaine « A » vont s'additionner pour former le catalogue complet du domaine « A »
						- une vue du bundle « A » pourra alors utiliser une traduction définie dans le bundle « B », et inversement, à condition que le domaine soit le même
					- Un domaine spécial : validators
						- placer les traductions de messages d'erreurs dans le fichiervalidators.fr.yml
			- Traductions dépendantes de variables
				- Les placeholders
					- dans les catalogues
						- # src/OC/PlatformBundle/Resources/translations/messages.fr.yml

						hello: Bonjour %name% !
						Et

						# src/OC/PlatformBundle/Resources/translations/messages.en.yml

						hello: Hello %name%!
					- emploi
						- Balise :{% trans with {'%name%': name} %}hello{% endtrans %}
						Filtre :{{ 'hello'|trans({'%name%': name}) }}
						Service :$translator->trans('hello', array('%name%' => $name))
				- Les placeholders dans le domaine validators
					- les messages d'erreurs ne sont pas traduits par message
					- dans le catalogue, en fonction des contraintes définits (quelque soit le type de classe) du composant Validator
						- # src/OC/PlatformBundle/Resources/translations/validators.fr.yml

							password:
							  length:
								short: "Vous avez entré {{ value }} caractères. Or, le mot de passe ne peut en comporter moins de {{ limit }}"
								long:  "Vous avez entré {{ value }} caractères. Or, le mot de passe ne peut en comporter plus de {{ limit }}"
					- La raison de cette exception est que le validateur n'envoie pas les valeurs de ces variables au traducteur, il les garde pour lui et fait la substitution après le retour de la chaîne traduite par le traducteur.
				- Gestion des pluriels
					- dans les catalogues
						- advert:
							nombre: "[0,1]Il y a %count% annonce|[2,+Inf]Il y a %count% annonces"
					- emploi
						- Le filtre :
						{{ 'advert.nombre'|transchoice(nombre) }}
						La balise :
							{% transchoice nombre %}advert.nombre{% endtranschoice %}
						Le service :
							<?php
							$translator->transchoice('advert.nombre', $nombre);
				- Afficher des dates au format local
					- Si vous n'avez pas les extensions ICU et intl installées et activées sur votre serveur, la lecture de ce paragraphe ne vous servira à rien
					- Vérifiez si votre serveur de production possède ces extensions en accédant auconfig.php disponible dans le répertoire/web
						- sudo apt-get install libicu-dev
						- sudo apt-get install php7.0-intl
						- http://site.icu-project.org/
						- http://userguide.icu-project.org/
					
	 Quiz : Quiz 4
	
	Partie 5 - Préparer la mise en ligne
	
	1. Convertir les paramètres de requêtes
		- Les ParamConverters
			- un simple listener, qui écoute l'évènement kernel.controller
			- sont avant tout des services, dans lesquels vous pouvez y injecter d'autres services pour faire des actions plus complexe
			- agissant après le routeur, mais avant le contrôleur, pour venir transformer à souhait ces paramètres
			- le résultat des ParamConverters est stocké dans les attributs de requête, c'est-à-dire qu'on peut les injecter dans les arguments de l'action du contrôleur
		- Il existe deux ParamConverters par défaut avec Symfony : Doctrine et Datetime
			- DoctrineParamConverter
				- route
					- oc_platform_view:
							  path: /advert/{advert_id}/applications/{application_id}
							  defaults:
								_controller: OCPlatformBundle:Advert:view
				- contrôleur
					- use Sensio\Bundle\FrameworkExtraBundle\Configuration\ParamConverter;
					/**
					 * @ParamConverter("advert",      options={"mapping": {"advert_id": "id"})
					 * @ParamConverter("application", options={"mapping": {"application_id": "id"})
					 */
					public function viewAction(Advert $advert, Application $application)
			- DatetimeParamConverter
				- route
					- oc_platform_list:
							  path: /list/{date}
							  defaults:
								_controller: OCPlatformBundle:Advert:viewList
				- contrôleur
					- use Sensio\Bundle\FrameworkExtraBundle\Configuration\ParamConverter;
					/**
					 * @ParamConverter("date", options={"format": "Y-m-d"})
					 */
					public function viewListAction(\Datetime $date)
		- Il est facile de créer ses propres convertisseurs pour accélérer votre développement
			- Aller plus loin : créer ses propres ParamConverters
				- créer un convertisseur implémentant ParamConverterInterface
					- avec deux méthodes
						- supports(ParamConverter $configuration)
						- apply(Request $request, ParamConverter $configuration)
				- créer la définition d'un service
				- l'implémenter dans la méthode du contrôleur
				- tester l'url avec des valeur valide et invalides
	2. Personnaliser les pages d'erreur
		- Constater les pages d'erreur
			- Les pages d'erreur de Symfony sont affichées lorsque le noyau attrape une exception
			- Il existe deux pages différentes qu'il est possible de personnaliser
				- mode dev
				- mode prod (celle qu'on va surcharger)
		- Localiser les vues concernées
			- Les vues de ces pages d'erreur se situent dans le bundle TwigBundle
				- vendor\symfony\symfony\src\Symfony\Bundle\TwigBundle\Resources\views\Exception
		- Remplacer les vues d'un bundle
			- Nos vues doivent porter exactement les mêmes noms que celles qu'elles remplacent
				- si source
					- …(namespace)/RépertoireDuBundle/Resources/views/Hello/salut.html.twig
				- alors nous devons créer la vue
					- app/Resources/NomDuBundle/views/Hello/salut.html.twig
			- Comportement de Twig
				- Twig, pour chaque vue qu'on lui demande de retourner, regarde d'abord dans le répertoireapp/Resourcess'il trouve la vue correspondante
					- il cherchera error[code_erreur].html.twig sinon error.html.twig
				- S'il ne la trouve pas, il va ensuite voir dans le répertoire du bundle
				- avec un twig par format de fichier à retourner (error.js.twig, error.css.twig, ...)
			- Créer la nouvelle vue
				- dans app/Resources/TwigBundle/views/Exception
					- mode prod
						- error404.html.twig
						- error.html.twig
						- les différentes variables que vous pouvez utiliser 
							- {{ status_text }}
							- {{ status_code }}
							- nos variables de messages d'erreurs de traduction
					- mode dev (optionnel)
						- exception.html.twig
				- Le contenu d'une page d'erreur
			- Affichage
				- recharger le cache
					- $ bin/console clear:cache
						- ne supprime pas toujours tous les fichiers générés pour les templates
							- à défaut
								- $ rm -rf var/cache/prod/*
	3. Utiliser Assetic pour gérer les codes CSS et JS de votre site (n'est pas inclus par défaut avec Symfony)
		- Si votre page contient 5 fichiers CSS, 3 JavaScript et 15 images, cela fait un total de 23 requêtes HTTP à traiter par votre navigateur pour vous afficher l'intégralité de la page !
		- Comment optimiser le front-end ?
			- Grâce à Assetic, on peut optimiser très facilement nos scripts CSS/JS
				- Par exemple, nous pouvons passer de nos huit requêtes (5 CSS + 3 JS) pour 500 Ko à seulement deux requêtes (1 CSS + 1 JS) pour 200 Ko
					- le regroupement de fichier ne s'effectue qu'en mode prod
			- Utiliser de dépôts CDN (le CSS Bootstrap ou le Javascript jQuery par exemple) au maximums
				- si ces fichiers génériques sont déjà dans le cache du navigateur du client, lorsqu'il visite notre site, chargé sur un site précédent, ils ne seront pas rechargés
			- Mettre tout les balises de link avant </body>
		- Pratique : Assetic à la rescousse !
			- Installer Assetic et les bibliothèques de compression
				- ajouter les dépendances dans notre composer
					- "require": {
							"symfony/assetic-bundle": "^2.7.1",
							"leafo/scssphp": "~0.6",
							"patchwork/jsqueeze": "~1.0"
						},
				- configuration minimale du bundle AsseticBundle
					- assetic:
						  debug:          '%kernel.debug%'
						  use_controller: '%kernel.debug%'
			- Servir des ressources
				- Servir une seule ressource
					- avec 
						- src/OC/PlatformBundle/Resources/public/css/main.css
					- sinon
						- publié vos assets au préalable
							- php bin/console assets:install
						- pour éviter de devoir exécuter cette commande à chaque fois
							- faire un lien (une sorte de raccourci), en ajoutant le paramètre assets:install --symlink
								- de là, le dossier web/bundles/ocplatform pointe en réalité vers src/OC/PlatformBundle/Resources/public
					- de
						- <link rel="stylesheet" href="{{ asset('bundles/ocplatform/css/main.css') }}" type="text/css" />
					- procéder à
						- {% stylesheets 'bundles/ocplatform/css/main.css' %}
							  <link rel="stylesheet" href="{{ asset_url }}" type="text/css" />
							{% endstylesheets %}
					- de même
						- {% javascripts 'bundles/ocplatform/js/main.js' %}
							  <script type="text/javascript" src="{{ asset_url }}"></script>
							{% endjavascripts %}
				- Servir plusieurs ressources regroupées en une
					- listé
						- {% stylesheets
							  'bundles/ocplatform/css/main.css'
							  'bundles/ocplatform/css/platform.css' %}
							  <link rel="stylesheet" href="{{ asset_url }}" type="text/css" />
							{% endstylesheets %}
					- d'un dossier complet avec le joker « * »
						- {% stylesheets 'bundles/ocplatform/css/*' %}
				- Modifier les ressources servies
					- https://github.com/kriswallsmith/assetic
					- Le filtre cssrewrite
						- permet de regénérer les chemins des images et fichiers liés
						- emploi de la vue
							- {% stylesheets filter='cssrewrite'
							  'bundles/ocplatform/css/main.css'
							  'bundles/ocplatform/css/platform.css' %}
							  <link rel="stylesheet" href="{{ asset_url }}" type="text/css" />
							{% endstylesheets %}
						- activation
							- assetic:
							  debug:          '%kernel.debug%'
							  use_controller: '%kernel.debug%'
							  filters:
								cssrewrite: ~
					- Les filtres scssphp et jsqueeze
						- « minifient » les fichiers
						- emploi de la vue
							- stylesheets
								- {% stylesheets  filter='cssrewrite, scssphp'
							  ... %}
							- javascripts
								- {% javascripts filter='jsqueeze'
							  ... %}
							- pour bloquer l'emploi de ces filtres en mode dev, bloquant le développement, utiliser un marqueur « ? »
								- {% stylesheets filter='?scssphp'
							  ... %}
						- activation
							- assetic:
							  debug:          '%kernel.debug%'
							  use_controller: '%kernel.debug%'
							  filters:
								cssrewrite: ~
								jsqueeze:   ~
								scssphp:
								  formatter: 'Leafo\ScssPhp\Formatter\Compressed'
				- Gestion du mode prod
					- le fichier unique css ou / et js n'existe pas
					- à chaque fois que vous déployez en production, 
						- vider le cache 
							- en production un cache
								- si modification apporté
									- php bin/console cache:clear --no-warmup --env=prod
							- en développement caches
								- si modification apporté
									- php bin/console cache:clear --no-warmup
						- exporter les ressources Assetic
							- php bin/console assetic:dump --env=prod
	4. Utiliser la console directement depuis le navigateur
		- Installer CoreSphereConsoleBundle
			- Télécharger CoreSphereConsoleBundle
			- Enregistrement du bundle dans le Kernel
			- Enregistrement des routes
			- Publier les assets
		- Utilisation de la console dans son navigateur
	5. Déployer son site Symfony en production, sauvegardes et maintenances
		- ressources
			- https://buddy.works/guides/5-ways-to-deploy-php-applications
			- http://jonathannicol.com/blog/2013/11/19/automated-git-deployments-from-bitbucket/
			- https://www.digitalocean.com/community/tutorials/how-to-automate-php-app-deployment-process-using-capistrano-on-ubuntu-13
			- https://www.smashingmagazine.com/2015/07/development-to-deployment-workflow/
			- https://github.com/Lyquix/php-git-deploy
		- Préparer son application en local
			- Tester l'environnement de production
				- Développer Monolog pour notifier des erreurs
				- Pour le cas d'erreur de hack d'une faille de bundle, appli ou Php (car si le server web tombe on aura pas accès aux autres server)
					- voir si possible de créer un script léger sur index.php dans le dossier www/ du dns
						- qui fait l'interphase les requêtes et l'appli
						- test le retour de l'appli en gérant l'url
							- si pas d'erreur il renvoi la réponse
							- sinon 
								- blocage des ressources
								- notification
								- redirection
				- Tester ses pages d'erreur
					- 
				- Installer 
					- une console sur navigateur
					- APC
						- Complément manquant du manuel en ligne Symfony3
			- Configurer les paramètres 
				- de connexion à la base
				- de la variable secret
				- setter l'ip dans app_dev.php 
					- pour autoriser l'environnement de développement et notamment à la console
					- urls à reécrire et à protéger par un accès pas mot de passe
						- app_dev
						- _console
					- mettre en place un sitemap pour les bots
				- mettre en place le favicon
				- configurer 
					- Monolog
					- Doctrine Cache avec APC
			- Vérifier la qualité de votre code
				- à partir de Git sur insight.sensiolabs.com
			- Vérifier la sécurité de vos dépendances
				- à partir du composer.json sur security.sensiolabs.org
				- en local avec php bin/console security:check
			- Vider le cache, tout le cache
				- php bin/console cache:clear	// et //	php bin/console cache:clear --env=prod
		- Vérifier et préparer le serveur de production
			- Vérifier la compatibilité du serveur
				- avec config.php
					- en enlevant le block de l'ip
					- test
					- correction
					- suppression / renommage du fichier
		- Déployer votre application (http://symfony2-checklist.com)
			- par l'outil
				- Filezilla / Mobaxterm sous tls
				- Capifony sous ssh
					- Complément manquant du manuel pdf Eyrolles Symfony2
			- régler les droits sur le dossier /var
			- chargement du dossier vendors
				- si le server a composer et on a un accès à son terminal
					- n'envoyer que les fichiers composer et faire un php composer.phar install
				- sinon envoyer les fichiers
			- mettre en place la base de données
				- si on a un accès au terminal du server sous ssh
					- utiliser 
						- Doctrine
							- php bin/console doctrine:database:create
							- php bin/console doctrine:schema:update --force
							- php bin/console doctrine:fixtures:load
						- Doctrine Migration
				- sinon
					- par l'outil de gestion de la base de données
						- local
							- MySQL Workbench
						- en ligne
							- PhpMyAdmin
			- enlever 
				- les fixtures
				- les bases
			- optimiser l'autoload
			- Avoir de belles URL
				- ajouter un .htaccess dans le www/
				- dans le gestionnaire de dns
					- de l'hébergeur
						- de www/index.php à www/symfony/web/app.php
			- Vider les caches et mettre à jours les assets
			- S'assurer que tout fonctionne
				- avec un crowler de site map
				- avec authentification d'url redirigé
					- accès à app_dev
						- pour tester des url en ligne en cas d'erreur
					- accès à la console web
						- permettre 
							- l'exécution des tests
								- unitaire
								- fonctionnel
								- ...
								- profiler
								- sécurités des dépendances
							- la mise à jours des bundle
			- Référencement
				- ressources 
					- net
						- 
					- livre
						- Google Analytique
				- lien indexe complet
					- 
				- procédées essentiels
					- sitemap.txt
				- outils
					- 
				
	 Quiz : Quiz 5		
	
	Extention 1 - Complément manquant du manuel en ligne Symfony3
	
		1. Composants
			- How to Install and Use the Symfony Components
				- 
			- The Asset Component
				- 
			- The BrowserKit Component
				- 
			- The Cache Component
				- 
			- The ClassLoader Component
				- 
			- The Config Component
				- 
			- The Console Component
				- 
			- The CssSelector Component
				- 
			- The Debug Component
				- 
			- The DependencyInjection Component
				- 
			- The DomCrawler Component
				- 
			- The Dotenv Component
				- 
			- The EventDispatcher Component
				- 
			- The ExpressionLanguage Component
				- 
			- The Filesystem Component
				- 
			- The Finder Component
				- 
			- The Form Component
				- 
			- The HttpFoundation Component
				- 
			- The HttpKernel Component
				- 
			- The Intl Component
				- 
			- The Ldap Component
				- 
			- The OptionsResolver Component
				- 
			- The PHPUnit Bridge
				- 
			- The Process Component
				- 
			- The PropertyAccess Component
				- 
			- The PropertyInfo Component
				- 
			- The Routing Component
				- 
			- The Security Component
				- 
			- The Serializer Component
				- 
			- The Stopwatch Component
				- 
			- The Templating Component
				- 
			- The Translation Component
				- 
			- The Validator Component
				- 
			- The VarDumper Component
				- 
			- The Workflow Component
				- 
			- The Yaml Component
				- 
		2. Bundles
			- Doctrine project
				- DoctrineBundle
					- 
				- DoctrineFixturesBundle
					- 
				- DoctrineMongoDBBundle
					- 
				- DoctrineMigrationsBundle
					- 
				- DoctrineCacheBundle
					- 
			- https://thephpleague.com/#packages
				- 
					- 
			- https://github.com/FriendsOfSymfony
				- 
					- 
			- https://github.com/guzzle/guzzle
				- 
					- 
			- https://sonata-project.org/
				- 
					- 
			- https://github.com/snc/SncRedisBundle
				- 
					- 
			- https://github.com/php-amqplib/RabbitMqBundle
				- 
					- 
			- http://docs.sylius.org/en/latest/
				- 
					- 
			- https://github.com/KnpLabs
				- 
					- 
			- https://github.com/andreia/awesome-symfony
				- 
					- 
			- https://github.com/ziadoz/awesome-php
				- 
					- 
			- https://packagist.org/
				- 
					- 
		3. Divers
			- HTTP Cache
				- 
			- Performance
				- symfony apc fonction
			- Profiler
				- 
			- Testing
				- 
	
	
	Extention 2 - Complément manquant du manuel pdf Eyrolles Symfony2
	
		1. Sécuriser les objets avec les votants
			- Symfony\Component\Security\Core\Authorization\Voter\VoterInterface
		2. Tests
			- Unitaires
			- Fonctionnel
		3. Le déploiement complet
			- Capistrano ou Capifony
	

	Extension 3 - Procédure de développement Symfony
	
		- méthode isFlood() - fonction d'un scénario de scénarios à placer dans un sous-scénario de l'application
			- localisation 
				- de la source de la fonction
					- les classes des repository des entités Advert et Aplication (création et mise à jour)
				- de l'appelle de la fonction 
					- dans la méthode validate() de la class AntifloodValidator
			- objectif de la fonction
				- formater(agréger|granulariser)|stocker(CRUD)
					- si, oui ou non, la soumission du formulaire est un Flood
						- de part
							- la nature du message
								- lenght > 3
							- la fréquence du message
								- entre 
									- les créations d'advert ou application diffrérentes
										- si le délais entre les soumissions est respecté par rapport à l'ip courant de l'emméteur du formulaire
											- Advert
												- attribut
													- date (entre dernière création de l'ip courant en base et date de nouvelle création)
													- update_at (entre dernière mise à jour de l'ip courant en base et date de mise à jour)
													- ip
											- Application
												- attribut
													- date (entre dernière création de l'ip courant en base et date de nouvelle création)
													- ip
									- les modifications d'advert ou application
										- si le délais entre les soumissions est respecté par rapport à l'ip courant de l'emméteur du formulaire
											- Advert
												- attribut
													- date (entre dernière création de l'ip courant en base et date de nouvelle création)
													- update_at (entre dernière mise à jour de l'ip courant en base et date de mise à jour)
													- ip
											- Application
												- attribut
													- date (entre dernière création de l'ip courant en base et date de nouvelle création)
													- ip
			- suite de l'exécution de la fonction
				- dans la méthode validate() de la class AntifloodValidator
					- en testant le retour
						- on ajoute le message d'erreur de la contrainte au context de validation de l'attribut de l'entité
			- avec les paramètres
				- ip du client
					- en string d'un patterne d'entiers
					- de source
						- définit par le request dans le contexte de la fonction validate() qui appelle la fonction isFlood()
					- vérification d'intégrité
						- pas besoin de le contrôler
				- délais
					- en entier de seconde
					- source
						- définit arbitrairement dans le fonction isFlood()
					- vérification d'intégrité
						- pas besoin de le contrôler
			- niveau de granularité de fonctions génériques* suivant les besoins* dans l'application de l'algorithme de la fonction
				- logique métier
					- appelle de cette fonction du repository Advert ou Application en question
						- où on affecte à une variable, l'appelle d'un service
							- qui instancie une classe
						- d'où, dans un return, on exécute une méthode
							- avec des paramètres
				- contrainte et besoins
					- utiliser un service
						- qui irait chercher si oui ou non l'ip courante a créé une annonce ou une application dans les X dernières secondes
				- structure
					- d'implémentation
						- [[[ Bundle ] Contrôleur ] Classe ] Méthode
					- mode d'appelle
						- Rooter | Use | Service | Event Composant | Annotation
					- de localisation d'appelle
						- Rooter | Contrôler | Modèle
			- notes
				- il n'y a pas de champs de mise à jour dans la table application
					- ne pas en créer
				- on ne peut pas savoir si on est dans une création ou une modification
					- que ce soit une création ou une modification
						- se limiter dans la méthode, à checker, suivant entité
							- à partir de l'ip
								- si la dernière date, de création ou de mise à jour
									- respecte le délais
			- todo <<<<<<<<<<<< a-1
				- l'attribut ip
					- méthodologie de conception
						- Cordination des parties (à confronter)
							- Scrum + Redmine|Trello
							- Gaant + Pert
						- Cordination des développeur (à confronter)
							- UML
							- Merise
						- Mode de développement
							- TDD, BDD, DDD 
						- Normes
							- Design Pattern
							- solide
							- psr
					- de son contexte d'emploi
						- pour une création d'entités Advert et Aplication
							- est définit avant le persist de l'entité (avec ses entités liées)
							- todo <<<<<<<<<<<< a-2
								- créer l'attribut ip + annotation doctrine des paramètres du champs dans la table
									- Advert
									- Application
								- créer la fonction doctrine PrePersist d'implémentation de l'attribut dans chaque entité
									- valeur récupéré par le request
						- pour une modification d'entités Advert et Aplication
							- est 
								- récupéré du répository de l'entité (avec ses entités liées)
								- redéfinit, si on passe le Validator, avant le persist de l'entité (avec ses entités liées)
									- appelle de la fonction doctrine PrePersiste
							- todo <<<<<<<<<<<<< a-3
								- rien à faire
				- la méthode isFlood()
					- méthodologie de conception
						- Cordination des parties (à confronter)
							- Scrum + Redmine|Trello
							- Gaant + Pert
						- Cordination des développeur (à confronter)
							- UML
							- Merise
						- Mode de développement
							- TDD, BDD, DDD
						- Normes
							- Design Pattern
							- solide
							- psr
					- de son contexte d'emploi
						- pour une création ou une modification d'entités Advert et Aplication
							- est définit dans la méthode validate() de la class AntifloodValidator
							- todo <<<<<<<<<<< a-4
								- créer une méthode isFlood() dans le répository de l'entité en question
									- qui instencie dans une variable, par l'appelle d'un un service
										- l'objet d'une classe générique**
									- de laquelle on appellerait une méthode check(), en return
										- avec pour paramètre
											- l'entité manager
											- un tableau d'attributs
												- entity
													=> OcPlatformBundle:Advert
														=> champs date
															[ update_at, date]
													ou
													=> OcPlatformBundle:Application
														=> champs date
															[ date ]
												- ip => l'ip courant
												- periode => timestamp
										- qui**
											- en DQL, dans une variable $query
												- créer la requête de sélection, de l'entity manager 
													- par la méthode createQuery
														 - du répository de l'entité
															- l'entités en base, 
																- dont le champs de l'ip correspond à celui du client
																- dont la dernière date égale à
																	[- si exist de modification non null]
																	- de création
																- dont la période, entre cette date et maintenant, est suppérieur à la periode fournis
											- que l'on exécute et teste 
												- si vide ou null
													- renvoyer true
												- sinon
													- revoyer false
		
	
	Extension 4 - Idées de développement
	
		> Bundle de système
			- de gestion de destruction sécurisées de classes instanciées
			- de gestion des exceptions et de redirecion
			- d'accès à l'url de dev_app et d'exécutions de test
			- de gestion des sauvegardes et de maintenance
		
		> Bundle de sécurité
			- Développer Monolog pour notifier des erreurs
			- Pour le cas d'erreur de hack d'une faille de bundle, appli ou Php (car si le server web tombe on aura pas accès aux autres server)
				- voir si possible de créer un script léger sur index.php dans le dossier www/ du dns
					- qui fait l'interphase les requêtes et l'appli
					- test le retour de l'appli en gérant l'url
						- si pas d'erreur il renvoi la réponse
						- sinon 
							- blocage des ressources
							- notification
							- redirection
		
		> Bundle documentation et de mode d'emploi appli par profil
			- comme Crédit Mutuel ou Google Form, faire un mode d'emploi animé en js
				- décrivant tous les url et fonctionnalité par page avec description animé du process
				- un index des fonctionnalités avec description animé du process
				
		> Bundle user interface
			- savoir faire un menu reponsive
				- comme celui de la configuration de wordpress
	
	
	Extension 5 - Compléments divers ressources
	
		> console
		
			> composer
				- composer show
					- voir le détails sur les bundle installés
			
			> symfony
				- php bin/console debug:container --tag=twig.extension
					- voir tous les services implémentant un certain tag
				- php bin/console debug:router
					- voir les routes 
		
		> configuration
			
			> environnements
				- https://symfony.com/doc/current/configuration/environments.html
			
			> services
				- https://symfony.com/doc/current/bundles/configuration.html#processing-the-configs-array
				
				
		> log
			- https://symfony.com/doc/current/logging.html
			
		
		> doctrine
			- https://symfony.com/doc/master/doctrine.html
			- http://www.doctrine-project.org/api/orm/2.5/class-Doctrine.ORM.EntityManager.html
			- http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/basic-mapping.html
			- http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/dql-doctrine-query-language.html
			- http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/query-builder.html
			- http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/association-mapping.html
			- http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/working-with-associations.html
			- http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/events.html#lifecycle-callbacks-event-argument
			- http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/dql-doctrine-query-language.html
			
			> composer
				- https://packagist.org/packages/jupeter/doctrine-dump-fixtures-bundle
					
					- In the latest version just use " composer show "
					- notes
						- ne marche que pour les entités sans liaisons à d'autres
						- à essayer
		
		> db
			- https://openclassrooms.com/courses/les-moteurs-de-stockage-de-mysql-2
			- https://www.w3resource.com/mysql/mysql-tutorials.php
			
		
		> fixtures
			- https://symfony.com/doc/current/bundles/DoctrineFixturesBundle/index.html
			- http://tcuvelier.developpez.com/tutoriels/php/symfony2/doctrine2/data-fixtures/
			- https://www.sitepoint.com/data-fixtures-symfony2/
		
				php app/console help doctrine:fixtures:load
				
					Usage:
					 doctrine:fixtures:load [--fixtures[="..."]] [--append] [--em="..."] [--purge-with-truncate]

					Options:
					 --fixtures             The directory or file to load data fixtures from. (multiple values allowed)
					 --append               Append the data fixtures instead of deleting all data from the database first.
					 --em                   The entity manager to use for this command.
					 --purge-with-truncate  Purge data by using a database-level TRUNCATE statement
			
				php bin/console doctrine:fixtures:load --fixtures=src/OcUserBundle/DataFixtures/ORM --append
			
				
		> services
			- https://symfony.com/doc/current/components/dependency_injection.html
		
			> tags (regroupement de services par tags - emploi de tags de bundles et applicatifs : ok | créer mes propre tags, emploi : ?)
				- https://symfony.com/doc/current/reference/dic_tags.html
				- https://symfony.com/doc/current/service_container/tags.html
				- https://symfony.com/doc/current/reference/dic_tags.html
		
		> sécurité et authorisation
			- https://legissa.ovh/internet-se-proteger-des-pirates-et-hackers.html
			- https://symfony.com/doc/current/security.html
			- https://symfony.com/doc/current/reference/configuration/security.html
			- https://symfony.com/doc/current/security/entity_provider.html
			- https://symfony.com/doc/3.4/security/access_denied_handler.html
				- dans le cas d'un appelle d'un url spécifique, 
				si dans l'annotation de méthode d'accès à une ressource le test d'accès a échoué du rôle, 
				pour rediriger vers une route avec un flashbag
		
		
		> authentification
			- https://symfony.com/doc/current/security/form_login_setup.html
			- https://symfony.com/doc/current/bundles/SensioFrameworkExtraBundle/annotations/security.html
			- https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Security/Core/User/UserInterface.php
			- https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Security/Core/User/User.php
			- https://symfony.com/doc/master/bundles/FOSUserBundle/index.html
			- https://symfony.com/doc/master/bundles/FOSUserBundle/groups.html
			- https://symfony.com/doc/current/security/acl.html
			- OAuth 2.0
		
		
		> cache servers, proxy, reverse proxy et terminaux clients
			- https://symfony.com/doc/current/bundles/SensioFrameworkExtraBundle/annotations/cache.html
		
		
		> divers
			- https://symfony.com/doc/current/bundles/SensioFrameworkExtraBundle/index.html
		
			
		> twig
			
			> tag service
				- https://twig.symfony.com/doc/2.x/advanced.html#creating-an-extension
				- https://symfony.com/doc/current/templating.html
		
		> formulaire validation
			- https://symfony.com/doc/current/form/form_customization.html
			- https://symfony.com/doc/current/components/form.html#creating-a-simple-form
			- https://knpuniversity.com/screencast/question-answer-day/custom-validation-property-path
			- http://symfony.com/doc/current/validation/custom_constraint.html
			- https://symfony.com/doc/current/validation.html
		
		
		> bundles
			https://packagist.org/
			http://symfony.com/doc/current/components/index.html
			https://thephpleague.com/#packages
			https://github.com/FriendsOfSymfony
			https://github.com/guzzle/guzzle
			https://packagist.org/packages/csa/guzzle-bundle
			https://sonata-project.org/
			https://github.com/snc/SncRedisBundle
			https://github.com/php-amqplib/RabbitMqBundle
			http://docs.sylius.org/en/latest/
			https://github.com/KnpLabs
			https://github.com/andreia/awesome-symfony
			https://github.com/ziadoz/awesome-php
			https://packagist.org/packages/sentry/sentry-symfony
			https://github.com/EnMarche/en-marche.fr
		
			> test
				- https://www.ibm.com/developerworks/library/wa-webapptesting/
				- http://blog.nalis.fr/index.php?post/2009/01/14/les-tests-theorie
				- http://noeticforce.com/php-web-app-auto-testing-tools
				- http://www.hongkiat.com/blog/automated-php-test/
				- https://insight.sensiolabs.com
				- http://symfony.com/doc/current/best_practices/tests.html
				- https://symfony.com/doc/current/testing.html
				- https://symfony.com/doc/current/debug/debugging.html
			
			> mailer
				- https://swiftmailer.symfony.com/docs/introduction.html
				- http://symfony.com/doc/current/email.html
			
			> assetic
				- http://symfony.com/doc/current/assetic.html

